<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="464" clone_windows="0"/>
<globals body_outline_ratio="0.40000000000000002">
	<global_window_position top="192" left="184" height="600" width="914"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="davidmcnab.041604122248" a="E"><vh>FLWM</vh>
<v t="davidmcnab.041604122248.1" a="E"><vh>CONSTRUCTION/PACKAGING</vh>
<v t="davidmcnab.041604122248.2"><vh>@file README</vh></v>
<v t="davidmcnab.041604122248.3"><vh>@file INSTALL</vh></v>
<v t="davidmcnab.041604122248.4"><vh>@file LICENSE</vh></v>
<v t="davidmcnab.041604122248.5" a="M" tnodeList="davidmcnab.041604122248.5"><vh>@file Makefile</vh></v>
<v t="davidmcnab.041604122248.6" tnodeList="davidmcnab.041604122248.6"><vh>@file setup.py</vh></v>
</v>
<v t="davidmcnab.041604122248.7"><vh>ABSTRACT VIEWS</vh>
<v t="davidmcnab.041604122248.8" a="E"><vh>EXECUTION PATHS</vh>
<v t="davidmcnab.041604122248.9" a="E"><vh>EVENTS</vh>
<v t="davidmcnab.041604122248.10"><vh>on startup</vh>
<v t="davidmcnab.041604122248.11" a=""><vh>main</vh></v>
<v t="davidmcnab.041604122248.12"><vh>py_on_startup</vh></v>
<v t="davidmcnab.041604122248.13"><vh>WM.on_startup</vh></v>
</v>
<v t="davidmcnab.041604122248.14"><vh>on create window</vh>
<v t="davidmcnab.041604122248.15" a=""><vh>Frame</vh></v>
<v t="davidmcnab.041604122248.16"><vh>py_on_create</vh></v>
<v t="davidmcnab.041604122248.17"><vh>WM._addWin</vh></v>
<v t="davidmcnab.041604122248.18" a="E"><vh>window.__init__</vh></v>
<v t="davidmcnab.041604122248.19"><vh>window.getname</vh></v>
<v t="davidmcnab.041604122248.20"><vh>WM.on_create</vh></v>
<v t="davidmcnab.041604122248.21"><vh>myWM.on_create</vh></v>
</v>
<v t="davidmcnab.041604122248.22" a="E"><vh>on destroy window</vh>
<v t="davidmcnab.041604122248.23" a=""><vh>~Frame</vh></v>
<v t="davidmcnab.041604122248.24"><vh>py_on_destroy</vh></v>
<v t="davidmcnab.041604122248.25"><vh>WM.on_destroy</vh></v>
<v t="davidmcnab.041604122248.26"><vh>myWM.on_destroy</vh></v>
<v t="davidmcnab.041604122248.27"><vh>WM._delWin</vh></v>
</v>
<v t="davidmcnab.041604122248.28" a="E"><vh>on activate window</vh>
<v t="davidmcnab.041604122248.29" a=""><vh>Frame::activate</vh></v>
<v t="davidmcnab.041604122248.30"><vh>py_on_activate</vh></v>
<v t="davidmcnab.041604122248.31"><vh>WM.on_activate</vh></v>
</v>
<v t="davidmcnab.041604122248.32" a="E"><vh>on deactivate window</vh>
<v t="davidmcnab.041604122248.33" a=""><vh>Frame::deactivate</vh></v>
<v t="davidmcnab.041604122248.34"><vh>py_on_deactivate</vh></v>
<v t="davidmcnab.041604122248.35"><vh>WM.on_deactivate</vh></v>
</v>
<v t="davidmcnab.041604122248.36" a="E"><vh>on resize window</vh>
<v t="davidmcnab.041604122248.37" a=""><vh>Frame::set_size</vh></v>
<v t="davidmcnab.041604122248.38"><vh>py_on_resize</vh></v>
<v t="davidmcnab.041604122248.39"><vh>WM.on_resize</vh></v>
<v t="davidmcnab.041604122248.40"><vh>myWM.on_resize</vh></v>
</v>
<v t="davidmcnab.041604122248.41"><vh>on keystroke</vh>
<v t="davidmcnab.041604122248.42" a=""><vh>Handle_Hotkey</vh></v>
<v t="davidmcnab.041604122248.43"><vh>py_on_keyEvent</vh></v>
<v t="davidmcnab.041604122248.44"><vh>WM.on_keyEvent</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.45" a="E"><vh>ACTIONS</vh>
<v t="davidmcnab.041604122248.46"><vh>get window position</vh>
<v t="davidmcnab.041604122248.47" a=""><vh>window.position</vh></v>
<v t="davidmcnab.041604122248.48"><vh>flwm_.getPos</vh></v>
<v t="davidmcnab.041604122248.49" a=""><vh>flwm_getPos</vh></v>
</v>
<v t="davidmcnab.041604122248.50"><vh>get window size</vh>
<v t="davidmcnab.041604122248.51" a=""><vh>window.size</vh></v>
<v t="davidmcnab.041604122248.52"><vh>flwm_.getSize</vh></v>
<v t="davidmcnab.041604122248.53" a=""><vh>flwm_getSize</vh></v>
</v>
<v t="davidmcnab.041604122248.54"><vh>set window position</vh>
<v t="davidmcnab.041604122248.47" a=""><vh>window.position</vh></v>
<v t="davidmcnab.041604122248.55"><vh>flwm_.setPos</vh></v>
<v t="davidmcnab.041604122248.56" a=""><vh>flwm_setPos</vh></v>
</v>
<v t="davidmcnab.041604122248.57"><vh>set window size</vh>
<v t="davidmcnab.041604122248.51" a=""><vh>window.size</vh></v>
<v t="davidmcnab.041604122248.58"><vh>flwm_.setSize</vh></v>
<v t="davidmcnab.041604122248.59" a=""><vh>flwm_setSize</vh></v>
</v>
<v t="davidmcnab.041604122248.60" a="E"><vh>close a window</vh>
<v t="davidmcnab.041604122248.61"><vh>window.close</vh></v>
<v t="davidmcnab.041604122248.62"><vh>flwm_.closeWindow</vh></v>
<v t="davidmcnab.041604122248.63" a=""><vh>flwm_closeWindow</vh></v>
</v>
<v t="davidmcnab.041604122248.64" a="E"><vh>bind a key</vh>
<v t="davidmcnab.041604122248.65" a="E"><vh>@file examples/example3.py</vh></v>
<v t="davidmcnab.041604122248.66"><vh>WM.bindKey</vh></v>
<v t="davidmcnab.041604122248.67"><vh>flwm_.keycode</vh></v>
<v t="davidmcnab.041604122248.68" a=""><vh>flwm_keyCode</vh></v>
<v t="davidmcnab.041604122248.69"><vh>flwm_.bindKey</vh></v>
<v t="davidmcnab.041604122248.70" a=""><vh>flwm_bindKey</vh></v>
<v t="davidmcnab.041604122248.71" a=""><vh>Hotkeys_bindKey</vh></v>
</v>
</v>
</v>
<v t="davidmcnab.041604122248.72" a="E"><vh>FLTK wrapper</vh>
<v t="davidmcnab.041604122248.73" a="E"><vh>Python FLTK classes</vh>
<v t="davidmcnab.041604122248.74"><vh>class Fl_Window</vh></v>
<v t="davidmcnab.041604122248.75" a=""><vh>fltk imports</vh></v>
<v t="davidmcnab.041604122248.76" a=""><vh>Fl_Window_*</vh></v>
<v t="davidmcnab.041604122248.77" a=""><vh>Fl_Button_*</vh></v>
<v t="davidmcnab.041604122248.78" a=""><vh>Fl_Select_Browser_*</vh></v>
</v>
<v t="davidmcnab.041604122248.79" a="E"><vh>flwmapi FLTK wrappers</vh>
<v t="davidmcnab.041604122248.80"><vh>dispatchCallbackToPython</vh></v>
<v t="davidmcnab.041604122248.81"><vh>fltk_window_*</vh></v>
<v t="davidmcnab.041604122248.82"><vh>fltk_button_*</vh></v>
<v t="davidmcnab.041604122248.83"><vh>fltk_repeat_button_*</vh></v>
<v t="davidmcnab.041604122248.84"><vh>fltk_select_browser_*</vh></v>
<v t="davidmcnab.041604122248.85"><vh>fltk_hold_browser_*</vh></v>
<v t="davidmcnab.041604122248.86"><vh>fltk_input_*</vh></v>
<v t="davidmcnab.041604122248.87"><vh>fltk_color</vh></v>
</v>
</v>
</v>
<v t="davidmcnab.041604122248.88" a="E"><vh>PHYSICAL CODE</vh>
<v t="davidmcnab.041604122248.89" a="E"><vh>WM ENVIRONMENT</vh>
<v t="davidmcnab.041604122248.90"><vh>@file pywm-run.py</vh></v>
<v t="davidmcnab.041604122248.91"><vh>@file src-python/fltk.py</vh>
<v t="davidmcnab.041604122248.92"><vh>imports</vh></v>
<v t="davidmcnab.041604122248.93"><vh>class Fl_Window</vh></v>
<v t="davidmcnab.041604122248.94"><vh>class Fl_Button</vh></v>
<v t="davidmcnab.041604122248.95"><vh>class Fl_Select_Browser</vh></v>
</v>
<v t="davidmcnab.041604122248.96" a="E"><vh>@file src-pyrex/fltk_.pyx</vh>
<v t="davidmcnab.041604122248.75" a=""><vh>fltk imports</vh></v>
<v t="davidmcnab.041604122248.76" a=""><vh>Fl_Window_*</vh></v>
<v t="davidmcnab.041604122248.77" a=""><vh>Fl_Button_*</vh></v>
<v t="davidmcnab.041604122248.78" a=""><vh>Fl_Select_Browser_*</vh></v>
</v>
<v t="davidmcnab.041604122248.97"><vh>@file src-c/fltkshim.cpp</vh>
<v t="davidmcnab.041604122248.98"><vh>includes</vh></v>
<v t="davidmcnab.041604122248.79" a=""><vh>flwmapi FLTK wrappers</vh>
<v t="davidmcnab.041604122248.80"><vh>dispatchCallbackToPython</vh></v>
<v t="davidmcnab.041604122248.81"><vh>fltk_window_*</vh></v>
<v t="davidmcnab.041604122248.82"><vh>fltk_button_*</vh></v>
<v t="davidmcnab.041604122248.83"><vh>fltk_repeat_button_*</vh></v>
<v t="davidmcnab.041604122248.84"><vh>fltk_select_browser_*</vh></v>
<v t="davidmcnab.041604122248.85"><vh>fltk_hold_browser_*</vh></v>
<v t="davidmcnab.041604122248.86"><vh>fltk_input_*</vh></v>
<v t="davidmcnab.041604122248.87"><vh>fltk_color</vh></v>
</v>
</v>
</v>
<v t="davidmcnab.041604122248.99" a="E"><vh>APPLICATION LEVEL</vh>
<v t="davidmcnab.041604122248.100" a="E"><vh>@file examples/example1.py</vh></v>
<v t="davidmcnab.041604122248.101" a="E"><vh>@file examples/example2.py</vh></v>
<v t="davidmcnab.041604122248.65" a=""><vh>@file examples/example3.py</vh></v>
<v t="davidmcnab.041604122248.102"><vh>@file examples/example4.py</vh></v>
<v t="davidmcnab.041604122248.103"><vh>@file examples/example5.py</vh></v>
<v t="davidmcnab.041604122248.104" a="E" tnodeList="davidmcnab.041604122248.104,davidmcnab.041604122248.105,davidmcnab.041604122248.106,davidmcnab.041604122248.107,davidmcnab.041604122248.108,davidmcnab.041604122248.109,davidmcnab.041604122248.110,davidmcnab.041604122248.111,davidmcnab.041604122248.112,davidmcnab.041604122248.113,davidmcnab.041604122248.114,davidmcnab.041604122248.115,davidmcnab.041604122248.116,davidmcnab.041604122248.117,davidmcnab.041604122248.118,davidmcnab.041604122248.119,davidmcnab.041604122248.120,davidmcnab.041604122248.121,davidmcnab.041604122248.122,davidmcnab.041604122248.123,davidmcnab.041604132426,davidmcnab.041604122248.124,davidmcnab.041604122248.125,davidmcnab.041604122248.126,davidmcnab.041604122248.127,davidmcnab.041604122248.128,davidmcnab.041604122248.129,davidmcnab.041604122248.130"><vh>@file examples/david.py</vh>
<v t="davidmcnab.041604122248.105"><vh>imports</vh></v>
<v t="davidmcnab.041604122248.106" a="E"><vh>class leftEdge</vh>
<v t="davidmcnab.041604122248.107"><vh>__init__</vh></v>
<v t="davidmcnab.041604122248.108"><vh>on_enter</vh></v>
<v t="davidmcnab.041604122248.109"><vh>on_click</vh></v>
</v>
<v t="davidmcnab.041604122248.110" a="E"><vh>class popupWindow</vh>
<v t="davidmcnab.041604122248.111"><vh>__init__</vh></v>
<v t="davidmcnab.041604122248.112"><vh>cb</vh></v>
</v>
<v t="davidmcnab.041604122248.113" a="E"><vh>class myWindowClass</vh>
<v t="davidmcnab.041604122248.114"><vh>__init__</vh></v>
<v t="davidmcnab.041604122248.115"><vh>_moveDown</vh></v>
<v t="davidmcnab.041604122248.116"><vh>hallucinate</vh></v>
</v>
<v t="davidmcnab.041604122248.117"><vh>function cbTimer</vh></v>
<v t="davidmcnab.041604122248.118" a="E"><vh>class myWindowManagerClass</vh>
<v t="davidmcnab.041604122248.119"><vh>__init__</vh></v>
<v t="davidmcnab.041604122248.120" a="EV"><vh>on_startup</vh></v>
<v t="davidmcnab.041604122248.121"><vh>on_resize</vh></v>
<v t="davidmcnab.041604122248.122"><vh>on_create</vh></v>
<v t="davidmcnab.041604122248.123"><vh>on_destroy</vh></v>
<v t="davidmcnab.041604132426"><vh>on_keyEvent</vh></v>
<v t="davidmcnab.041604122248.124"><vh>cbTimer</vh></v>
<v t="davidmcnab.041604122248.125"><vh>cbShowEdges</vh></v>
<v t="davidmcnab.041604122248.126"><vh>flShow</vh></v>
<v t="davidmcnab.041604122248.127"><vh>hackconspyre</vh></v>
<v t="davidmcnab.041604122248.128"><vh>position_conspyre</vh></v>
</v>
<v t="davidmcnab.041604122248.129"><vh>function run</vh></v>
<v t="davidmcnab.041604122248.130"><vh>mainline</vh></v>
</v>
<v t="davidmcnab.041604122248.131"><vh>@file examples/examplen.py</vh>
<v t="davidmcnab.041604122248.132"><vh>&lt;&lt; test declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.133" a="E"><vh>class myWindow</vh>
<v t="davidmcnab.041604122248.134"><vh>myWindow.on_resize</vh></v>
</v>
<v t="davidmcnab.041604122248.135" a="E"><vh>class myWM</vh>
<v t="davidmcnab.041604122248.136"><vh>myWM.__init__</vh></v>
<v t="davidmcnab.041604122248.137"><vh>myWM.on_create</vh></v>
<v t="davidmcnab.041604122248.138"><vh>myWM.on_destroy</vh></v>
<v t="davidmcnab.041604122248.139"><vh>myWM.on_resize</vh></v>
<v t="davidmcnab.041604122248.140"><vh>myWM.on_buttonPress</vh></v>
<v t="davidmcnab.041604122248.141"><vh>myWM.on_keyEvent</vh></v>
<v t="davidmcnab.041604122248.142"><vh>myWM.on_enter</vh></v>
<v t="davidmcnab.041604122248.143"><vh>myWM.on_leave</vh></v>
</v>
<v t="davidmcnab.041604122248.144"><vh>run</vh></v>
<v t="davidmcnab.041604122248.145"><vh>MAINLINE</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.146" a="E"><vh>PYWM MODULES</vh>
<v t="davidmcnab.041604122248.147" a="E"><vh>@file src-python/applets.py</vh>
<v t="davidmcnab.041604122248.148"><vh>class tasklist</vh></v>
<v t="davidmcnab.041604122248.149"><vh>class navigator</vh></v>
<v t="davidmcnab.041604122248.150"><vh>class quicklaunch</vh></v>
<v t="davidmcnab.041604122248.151"><vh>class shellbox</vh></v>
<v t="davidmcnab.041604122248.152"><vh>class xapp</vh></v>
</v>
<v t="davidmcnab.041604122248.153" a="E" tnodeList="davidmcnab.041604122248.153,davidmcnab.041604122248.154,davidmcnab.041604122248.155,davidmcnab.041604122248.156,davidmcnab.041604122248.157,davidmcnab.041604122248.160,davidmcnab.041604122248.161,davidmcnab.041604122248.162,davidmcnab.041604122248.163,davidmcnab.041604122248.164,davidmcnab.041604122248.165,davidmcnab.041604122248.166,davidmcnab.041604122248.167,davidmcnab.041604122248.168,davidmcnab.041604122248.169,davidmcnab.041604122248.170,davidmcnab.041604122248.171,davidmcnab.041604122248.172,davidmcnab.041604122248.173,davidmcnab.041604122248.175,davidmcnab.041604122248.176,davidmcnab.041604122248.177,davidmcnab.041604122248.178,davidmcnab.041604122248.179,davidmcnab.041604122248.181,davidmcnab.041604122248.182,davidmcnab.041604122248.183,davidmcnab.041604122248.184,davidmcnab.041604122248.185,davidmcnab.041604122248.186,davidmcnab.041604122248.187,davidmcnab.041604122248.188,davidmcnab.041604122248.189,davidmcnab.041604122248.190,davidmcnab.041604122248.191,davidmcnab.041604122248.192,davidmcnab.041604122248.193,davidmcnab.041604122248.194,davidmcnab.041604122248.195,davidmcnab.041604122248.197,davidmcnab.041604122248.198,davidmcnab.041604122248.199,davidmcnab.041604122248.200,davidmcnab.041604122248.201,davidmcnab.041604122248.203,davidmcnab.041604122248.204,davidmcnab.041604122248.205,davidmcnab.041604122248.206,davidmcnab.041604122248.207,davidmcnab.041604122248.209,davidmcnab.041604122248.210,davidmcnab.041604122248.211,davidmcnab.041604122248.212,davidmcnab.041604122248.213,davidmcnab.041604122248.215,davidmcnab.041604122248.216,davidmcnab.041604122248.217,davidmcnab.041604122248.218,davidmcnab.041604122248.219,davidmcnab.041604122248.222,davidmcnab.041604122248.223,davidmcnab.041604122248.224,davidmcnab.041604122248.225,davidmcnab.041604122248.226,davidmcnab.041604122248.227,davidmcnab.041604122248.228,davidmcnab.041604122248.229,davidmcnab.041604122248.230,davidmcnab.041604122248.231,davidmcnab.041604122248.233,davidmcnab.041604122248.234,davidmcnab.041604122248.235,davidmcnab.041604122248.236,davidmcnab.041604122248.237,davidmcnab.041604122248.238,davidmcnab.041604122248.239,davidmcnab.041604122248.240,davidmcnab.041604122248.241,davidmcnab.041604122248.242,davidmcnab.041604122248.243,davidmcnab.041604122248.244,davidmcnab.041604122248.245,davidmcnab.041604122248.246,davidmcnab.041604122248.247,davidmcnab.041604122248.248,davidmcnab.041604122248.249,davidmcnab.041604122248.250,davidmcnab.041604122248.251,davidmcnab.041604122248.252,davidmcnab.041604122248.253,davidmcnab.041604122248.254,davidmcnab.041604122248.255,davidmcnab.041604122248.256,davidmcnab.041604122248.257,davidmcnab.041604122248.258,davidmcnab.041604122248.259,davidmcnab.041604122248.260,davidmcnab.041604122248.261,davidmcnab.041604122248.262,davidmcnab.041604122248.263,davidmcnab.041604122248.264,davidmcnab.041604122248.265,davidmcnab.041604122248.266,davidmcnab.041604122248.267,davidmcnab.041604122248.268,davidmcnab.041604122248.269,davidmcnab.041604122248.270,davidmcnab.041604122248.271,davidmcnab.041604122248.272,davidmcnab.041604122248.273,davidmcnab.041604122248.274,davidmcnab.041604122248.275"><vh>@file src-python/__init__.py</vh>
<v t="davidmcnab.041604122248.154"><vh>Python imports</vh></v>
<v t="davidmcnab.041604122248.155"><vh>__all__</vh></v>
<v t="davidmcnab.041604122248.156" a="E"><vh>class window</vh>
<v t="davidmcnab.041604122248.157"><vh>Attributes</vh></v>
<v t="davidmcnab.041604122248.158" a="E"><vh>Actions</vh>
<v t="davidmcnab.041604122248.159" a="E"><vh>Raw</vh>
<v t="davidmcnab.041604122248.160"><vh>window.close</vh></v>
<v t="davidmcnab.041604122248.161"><vh>window.raise_</vh></v>
<v t="davidmcnab.041604122248.162"><vh>window.lower</vh></v>
<v t="davidmcnab.041604122248.163"><vh>window.iconise</vh></v>
<v t="davidmcnab.041604122248.164"><vh>window.getname</vh></v>
<v t="davidmcnab.041604122248.165"><vh>window.position</vh></v>
<v t="davidmcnab.041604122248.166"><vh>window.size</vh></v>
<v t="davidmcnab.041604122248.167"><vh>window.setborder</vh></v>
<v t="davidmcnab.041604122248.168"><vh>window.hide</vh></v>
<v t="davidmcnab.041604122248.169"><vh>window.unhide</vh></v>
<v t="davidmcnab.041604122248.170"><vh>window.activate</vh></v>
<v t="davidmcnab.041604122248.171"><vh>window.deactivate</vh></v>
<v t="davidmcnab.041604122248.172"><vh>window.lock</vh></v>
<v t="davidmcnab.041604122248.173"><vh>window.unlock</vh></v>
</v>
<v t="davidmcnab.041604122248.174" a="E"><vh>Derived</vh>
<v t="davidmcnab.041604122248.175"><vh>window.__init__</vh></v>
<v t="davidmcnab.041604122248.176"><vh>window.__repr__</vh></v>
<v t="davidmcnab.041604122248.177"><vh>window.getScreenSize</vh></v>
<v t="davidmcnab.041604122248.178"><vh>window.width</vh></v>
<v t="davidmcnab.041604122248.179"><vh>window.height</vh></v>
<v t="davidmcnab.041604122248.180"><vh>Movement methods</vh>
<v t="davidmcnab.041604122248.181"><vh>window.moveRel</vh></v>
<v t="davidmcnab.041604122248.182"><vh>window.moveUp</vh></v>
<v t="davidmcnab.041604122248.183"><vh>window.moveDown</vh></v>
<v t="davidmcnab.041604122248.184"><vh>window.moveLeft</vh></v>
<v t="davidmcnab.041604122248.185"><vh>window.moveRight</vh></v>
<v t="davidmcnab.041604122248.186"><vh>window.goNorth</vh></v>
<v t="davidmcnab.041604122248.187"><vh>window.goNorthEast</vh></v>
<v t="davidmcnab.041604122248.188"><vh>window.goEast</vh></v>
<v t="davidmcnab.041604122248.189"><vh>window.goSouthEast</vh></v>
<v t="davidmcnab.041604122248.190"><vh>window.goSouth</vh></v>
<v t="davidmcnab.041604122248.191"><vh>window.goSouthWest</vh></v>
<v t="davidmcnab.041604122248.192"><vh>window.goWest</vh></v>
<v t="davidmcnab.041604122248.193"><vh>window.goNorthWest</vh></v>
<v t="davidmcnab.041604122248.194"><vh>window.goCentre</vh></v>
<v t="davidmcnab.041604122248.195"><vh>window.go</vh></v>
</v>
<v t="davidmcnab.041604122248.196"><vh>Size Methods</vh>
<v t="davidmcnab.041604122248.197"><vh>toggleMax</vh></v>
<v t="davidmcnab.041604122248.198"><vh>toggleMaxWidth</vh></v>
<v t="davidmcnab.041604122248.199"><vh>toggleMaxHeight</vh></v>
<v t="davidmcnab.041604122248.200"><vh>window.resizeRel</vh></v>
<v t="davidmcnab.041604122248.201"><vh>window.resize</vh></v>
<v t="davidmcnab.041604122248.202"><vh>Grow methods</vh>
<v t="davidmcnab.041604122248.203"><vh>window.grow</vh></v>
<v t="davidmcnab.041604122248.204"><vh>window.growLeft</vh></v>
<v t="davidmcnab.041604122248.205"><vh>window.growRight</vh></v>
<v t="davidmcnab.041604122248.206"><vh>window.growTop</vh></v>
<v t="davidmcnab.041604122248.207"><vh>window.growBottom</vh></v>
</v>
<v t="davidmcnab.041604122248.208"><vh>Shrink methods</vh>
<v t="davidmcnab.041604122248.209"><vh>window.shrink</vh></v>
<v t="davidmcnab.041604122248.210"><vh>window.shrinkLeft</vh></v>
<v t="davidmcnab.041604122248.211"><vh>window.shrinkRight</vh></v>
<v t="davidmcnab.041604122248.212"><vh>window.shrinkTop</vh></v>
<v t="davidmcnab.041604122248.213"><vh>window.shrinkBottom</vh></v>
</v>
</v>
</v>
</v>
<v t="davidmcnab.041604122248.214" a="E"><vh>Callbacks</vh>
<v t="davidmcnab.041604122248.215"><vh>window.on_resize</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.216" a="E"><vh>class WM</vh>
<v t="davidmcnab.041604122248.217"><vh>WM attribs</vh></v>
<v t="davidmcnab.041604122248.218"><vh>WM.__init__</vh></v>
<v t="davidmcnab.041604122248.219"><vh>WM.addHandlers</vh></v>
<v t="davidmcnab.041604122248.220" a="E"><vh>Callbacks</vh>
<v t="davidmcnab.041604122248.221" a="E"><vh>working</vh>
<v t="davidmcnab.041604122248.222"><vh>WM.on_startup</vh></v>
<v t="davidmcnab.041604122248.223"><vh>WM.on_create</vh></v>
<v t="davidmcnab.041604122248.224"><vh>WM.on_destroy</vh></v>
<v t="davidmcnab.041604122248.225"><vh>WM.on_activate</vh></v>
<v t="davidmcnab.041604122248.226"><vh>WM.on_deactivate</vh></v>
<v t="davidmcnab.041604122248.227"><vh>WM.on_keyEvent</vh></v>
<v t="davidmcnab.041604122248.228"><vh>WM.on_buttonPress</vh></v>
<v t="davidmcnab.041604122248.229"><vh>WM.on_resize</vh></v>
</v>
<v t="davidmcnab.041604122248.230"><vh>WM.on_enter</vh></v>
<v t="davidmcnab.041604122248.231"><vh>WM.on_leave</vh></v>
</v>
<v t="davidmcnab.041604122248.232" a="E"><vh>Actions</vh>
<v t="davidmcnab.041604122248.233"><vh>WM.run</vh></v>
<v t="davidmcnab.041604122248.234"><vh>WM._addWin</vh></v>
<v t="davidmcnab.041604122248.235"><vh>WM._delWin</vh></v>
<v t="davidmcnab.041604122248.236"><vh>WM.window</vh></v>
<v t="davidmcnab.041604122248.237"><vh>WM.launch</vh></v>
<v t="davidmcnab.041604122248.238"><vh>WM.getMousePos</vh></v>
<v t="davidmcnab.041604122248.239"><vh>WM.getScreenSize</vh></v>
<v t="davidmcnab.041604122248.240"><vh>WM.bindKey</vh></v>
<v t="davidmcnab.041604122248.241"><vh>WM.goNextWindow</vh></v>
<v t="davidmcnab.041604122248.242"><vh>WM.goPrevWindow</vh></v>
<v t="davidmcnab.041604122248.243"><vh>WM.goNextDesk</vh></v>
<v t="davidmcnab.041604122248.244"><vh>WM.goPrevDesk</vh></v>
<v t="davidmcnab.041604122248.245"><vh>WM.showMenu</vh></v>
<v t="davidmcnab.041604122248.246"><vh>WM.moveCurrent</vh></v>
<v t="davidmcnab.041604122248.247"><vh>WM.resizeCurrent</vh></v>
<v t="davidmcnab.041604122248.248"><vh>WM.closeCurrent</vh></v>
<v t="davidmcnab.041604122248.249"><vh>WM.toggleMaxCurrent</vh></v>
<v t="davidmcnab.041604122248.250"><vh>WM.toggleMaxWidthCurrent</vh></v>
<v t="davidmcnab.041604122248.251"><vh>WM.toggleMaxHeightCurrent</vh></v>
<v t="davidmcnab.041604122248.252"><vh>WM.cascadeWindows</vh></v>
<v t="davidmcnab.041604122248.253"><vh>WM.zoom</vh></v>
<v t="davidmcnab.041604122248.254"><vh>WM.zoomIn</vh></v>
<v t="davidmcnab.041604122248.255"><vh>WM.zoomInMouse</vh></v>
<v t="davidmcnab.041604122248.256"><vh>WM.zoomOut</vh></v>
<v t="davidmcnab.041604122248.257"><vh>WM.zoomOutMouse</vh></v>
<v t="davidmcnab.041604122248.258"><vh>WM.pan</vh></v>
<v t="davidmcnab.041604122248.259"><vh>WM.panLeft</vh></v>
<v t="davidmcnab.041604122248.260"><vh>WM.panRight</vh></v>
<v t="davidmcnab.041604122248.261"><vh>WM.panUp</vh></v>
<v t="davidmcnab.041604122248.262"><vh>WM.panDown</vh></v>
<v t="davidmcnab.041604122248.263"><vh>WM.windowFromIndex</vh></v>
<v t="davidmcnab.041604122248.264"><vh>WM.indexFromWindow</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.265"><vh>function setTimer</vh></v>
<v t="davidmcnab.041604122248.266"><vh>function repeatTimer</vh></v>
<v t="davidmcnab.041604122248.267"><vh>class Fl_Window</vh></v>
<v t="davidmcnab.041604122248.268"><vh>class Fl_Button</vh></v>
<v t="davidmcnab.041604122248.269"><vh>class Fl_Repeat_Button</vh></v>
<v t="davidmcnab.041604122248.270"><vh>class Fl_Select_Browser</vh></v>
<v t="davidmcnab.041604122248.271"><vh>class Fl_Hold_Browser</vh></v>
<v t="davidmcnab.041604122248.272"><vh>class Fl_Input</vh></v>
<v t="davidmcnab.041604122248.273"><vh>class appletBase</vh></v>
<v t="davidmcnab.041604122248.274"><vh>class appletBar</vh></v>
<v t="davidmcnab.041604122248.275"><vh>function color</vh></v>
</v>
<v t="davidmcnab.041604122248.276" a="E"><vh>@file src-pyrex/flwm_.pyx</vh>
<v t="davidmcnab.041604122248.277" a="E"><vh>C header imports</vh>
<v t="davidmcnab.041604122248.278"><vh>System</vh>
<v t="davidmcnab.041604122248.279"><vh>string.h</vh></v>
<v t="davidmcnab.041604122248.280"><vh>stdio.h</vh></v>
<v t="davidmcnab.041604122248.281"><vh>stdlib.h</vh></v>
<v t="davidmcnab.041604122248.282"><vh>math.h</vh></v>
</v>
<v t="davidmcnab.041604122248.283"><vh>X</vh></v>
<v t="davidmcnab.041604122248.284" a="E"><vh>Python</vh>
<v t="davidmcnab.041604122248.285"><vh>python.h</vh></v>
</v>
<v t="davidmcnab.041604122248.286"><vh>flwm c/c++ imports</vh></v>
<v t="davidmcnab.041604122248.287" a="E"><vh>Python FLTK classes</vh>
<v t="davidmcnab.041604122248.288"><vh>class Fl_Window</vh></v>
<v t="davidmcnab.041604122248.289"><vh>fltk imports</vh></v>
<v t="davidmcnab.041604122248.290"><vh>Fl_Window_*</vh></v>
<v t="davidmcnab.041604122248.291"><vh>Fl_Button_*</vh></v>
<v t="davidmcnab.041604122248.292"><vh>Fl_Repeat_Button_*</vh></v>
<v t="davidmcnab.041604122248.293"><vh>Fl_Select_Browser_*</vh></v>
<v t="davidmcnab.041604122248.294"><vh>Fl_Hold_Browser_*</vh></v>
<v t="davidmcnab.041604122248.295"><vh>Fl_Input_*</vh></v>
<v t="davidmcnab.041604122248.296"><vh>color</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.297"><vh>Python Imports</vh></v>
<v t="davidmcnab.041604122248.298" a="E"><vh>CALLBACKS from flwm</vh>
<v t="davidmcnab.041604122248.299"><vh>globals</vh></v>
<v t="davidmcnab.041604122248.300"><vh>py_on_startup</vh></v>
<v t="davidmcnab.041604122248.301"><vh>py_on_create</vh></v>
<v t="davidmcnab.041604122248.302"><vh>py_on_destroy</vh></v>
<v t="davidmcnab.041604122248.303"><vh>py_on_activate</vh></v>
<v t="davidmcnab.041604122248.304"><vh>py_on_deactivate</vh></v>
<v t="davidmcnab.041604122248.305"><vh>py_onSize</vh></v>
<v t="davidmcnab.041604122248.306"><vh>py_on_resize</vh></v>
<v t="davidmcnab.041604122248.307"><vh>py_on_buttonPress</vh></v>
<v t="davidmcnab.041604122248.308"><vh>py_on_keyEvent</vh></v>
<v t="davidmcnab.041604122248.309"><vh>py_on_enter</vh></v>
<v t="davidmcnab.041604122248.310"><vh>py_on_leave</vh></v>
</v>
<v t="davidmcnab.041604122248.311" a="E"><vh>ACTIONS to FLWM</vh>
<v t="davidmcnab.041604122248.312"><vh>flwm_.run</vh></v>
<v t="davidmcnab.041604122248.313"><vh>flwm_.getMousePos</vh></v>
<v t="davidmcnab.041604122248.314"><vh>flwm_.getScreenSize</vh></v>
<v t="davidmcnab.041604122248.315"><vh>flwm_.keycode</vh></v>
<v t="davidmcnab.041604122248.316"><vh>flwm_.bindKey</vh></v>
<v t="davidmcnab.041604122248.317"><vh>flwm_.getLabel</vh></v>
<v t="davidmcnab.041604122248.318"><vh>flwm_.getSize</vh></v>
<v t="davidmcnab.041604122248.319"><vh>flwm_.setSize</vh></v>
<v t="davidmcnab.041604122248.320"><vh>flwm_.getPos</vh></v>
<v t="davidmcnab.041604122248.321"><vh>flwm_.setPos</vh></v>
<v t="davidmcnab.041604122248.322"><vh>flwm_.setBorder</vh></v>
<v t="davidmcnab.041604122248.323"><vh>flwm_.closeWindow</vh></v>
<v t="davidmcnab.041604122248.324"><vh>flwm_.raiseWindow</vh></v>
<v t="davidmcnab.041604122248.325"><vh>flwm_.lowerWindow</vh></v>
<v t="davidmcnab.041604122248.326"><vh>flwm_.iconiseWindow</vh></v>
<v t="davidmcnab.041604122248.327"><vh>flwm_.activateWindow</vh></v>
<v t="davidmcnab.041604122248.328"><vh>flwm_.deactivateWindow</vh></v>
<v t="davidmcnab.041604122248.329"><vh>flwm_.goNextWindow</vh></v>
<v t="davidmcnab.041604122248.330"><vh>flwm_.goPrevWindow</vh></v>
<v t="davidmcnab.041604122248.331"><vh>flwm_.goNextDesk</vh></v>
<v t="davidmcnab.041604122248.332"><vh>flwm_.goPrevDesk</vh></v>
<v t="davidmcnab.041604122248.333"><vh>flwm_.showMenu</vh></v>
<v t="davidmcnab.041604122248.334"><vh>flwm_.test</vh></v>
<v t="davidmcnab.041604122248.335"><vh>flwm_.setTimer</vh></v>
<v t="davidmcnab.041604122248.336"><vh>flwm_.repeatTimer</vh></v>
</v>
</v>
</v>
<v t="davidmcnab.041604122248.337"><vh>PYTHON/FLWM INTERFACE</vh>
<v t="davidmcnab.041604122248.338"><vh>@file src-c/pycallbacks.h</vh></v>
<v t="davidmcnab.041604122248.339" a="E" tnodeList="davidmcnab.041604122248.339,davidmcnab.041604122248.340,davidmcnab.041604122248.341,davidmcnab.041604122248.80,davidmcnab.041604122248.81,davidmcnab.041604122248.82,davidmcnab.041604122248.83,davidmcnab.041604122248.84,davidmcnab.041604122248.85,davidmcnab.041604122248.86,davidmcnab.041604122248.87,davidmcnab.041604122248.68,davidmcnab.041604122248.70,davidmcnab.041604122248.63,davidmcnab.041604122248.342,davidmcnab.041604122248.343,davidmcnab.041604122248.344,davidmcnab.041604122248.345,davidmcnab.041604122248.346,davidmcnab.041604122248.347,davidmcnab.041604122248.348,davidmcnab.041604122248.349,davidmcnab.041604122248.350,davidmcnab.041604122248.351,davidmcnab.041604122248.352,davidmcnab.041604122248.49,davidmcnab.041604122248.56,davidmcnab.041604122248.53,davidmcnab.041604122248.59,davidmcnab.041604122248.353,davidmcnab.041604122248.354,davidmcnab.041604122248.355,davidmcnab.041604122248.356,davidmcnab.041604122248.357"><vh>@file src-c/flwmapi.cpp</vh>
<v t="davidmcnab.041604122248.340"><vh>includes</vh></v>
<v t="davidmcnab.041604122248.341"><vh>imported funcs</vh></v>
<v t="davidmcnab.041604122248.79" a="E"><vh>flwmapi FLTK wrappers</vh>
<v t="davidmcnab.041604122248.80"><vh>dispatchCallbackToPython</vh></v>
<v t="davidmcnab.041604122248.81"><vh>fltk_window_*</vh></v>
<v t="davidmcnab.041604122248.82"><vh>fltk_button_*</vh></v>
<v t="davidmcnab.041604122248.83"><vh>fltk_repeat_button_*</vh></v>
<v t="davidmcnab.041604122248.84"><vh>fltk_select_browser_*</vh></v>
<v t="davidmcnab.041604122248.85"><vh>fltk_hold_browser_*</vh></v>
<v t="davidmcnab.041604122248.86"><vh>fltk_input_*</vh></v>
<v t="davidmcnab.041604122248.87"><vh>fltk_color</vh></v>
</v>
<v t="davidmcnab.041604122248.68" a=""><vh>flwm_keyCode</vh></v>
<v t="davidmcnab.041604122248.70" a=""><vh>flwm_bindKey</vh></v>
<v t="davidmcnab.041604122248.63" a=""><vh>flwm_closeWindow</vh></v>
<v t="davidmcnab.041604122248.342"><vh>flwm_goNextWindow</vh></v>
<v t="davidmcnab.041604122248.343"><vh>flwm_goPrevWindow</vh></v>
<v t="davidmcnab.041604122248.344"><vh>flwm_goNextDesk</vh></v>
<v t="davidmcnab.041604122248.345"><vh>flwm_goPrevDesk</vh></v>
<v t="davidmcnab.041604122248.346"><vh>flwm_showMenu</vh></v>
<v t="davidmcnab.041604122248.347"><vh>flwm_raiseWindow</vh></v>
<v t="davidmcnab.041604122248.348"><vh>flwm_lowerWindow</vh></v>
<v t="davidmcnab.041604122248.349"><vh>flwm_iconiseWindow</vh></v>
<v t="davidmcnab.041604122248.350"><vh>flwm_activateWindow</vh></v>
<v t="davidmcnab.041604122248.351"><vh>flwm_deactivateWindow</vh></v>
<v t="davidmcnab.041604122248.352"><vh>flwm_geLlabel</vh></v>
<v t="davidmcnab.041604122248.49" a=""><vh>flwm_getPos</vh></v>
<v t="davidmcnab.041604122248.56" a=""><vh>flwm_setPos</vh></v>
<v t="davidmcnab.041604122248.53" a=""><vh>flwm_getSize</vh></v>
<v t="davidmcnab.041604122248.59" a=""><vh>flwm_setSize</vh></v>
<v t="davidmcnab.041604122248.353"><vh>flwm_getMousePos</vh></v>
<v t="davidmcnab.041604122248.354"><vh>flwm_getScreenSize</vh></v>
<v t="davidmcnab.041604122248.355"><vh>flwm_test</vh></v>
<v t="davidmcnab.041604122248.356"><vh>flwm_setTimer</vh></v>
<v t="davidmcnab.041604122248.357"><vh>flwm_setBorder</vh></v>
</v>
</v>
<v t="davidmcnab.041604122248.358"><vh>FLWM ENGINE</vh>
<v t="davidmcnab.041604122248.359"><vh>@file src-c/config.h</vh></v>
<v t="davidmcnab.041604122248.360"><vh>@file src-c/main.cpp</vh>
<v t="davidmcnab.041604122248.361"><vh>&lt;&lt; main #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.362"><vh>&lt;&lt; main declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.363"><vh>xerror_handler</vh></v>
<v t="davidmcnab.041604122248.364"><vh>handle</vh></v>
<v t="davidmcnab.041604122248.365"><vh>flwm_event_handler</vh></v>
<v t="davidmcnab.041604122248.366"><vh>flwm_update_clock</vh></v>
<v t="davidmcnab.041604122248.367"><vh>flwm_clock_alarm_on</vh></v>
<v t="davidmcnab.041604122248.368"><vh>flwm_clock_alarm_off</vh></v>
<v t="davidmcnab.041604122248.369"><vh>color_setup</vh></v>
<v t="davidmcnab.041604122248.370"><vh>parse_fl_color</vh></v>
<v t="davidmcnab.041604122248.371"><vh>initialize</vh></v>
<v t="davidmcnab.041604122248.372"><vh>arg</vh></v>
<v t="davidmcnab.041604122248.11" a=""><vh>main</vh></v>
<v t="davidmcnab.041604122248.373"><vh>getWindowName</vh></v>
</v>
<v t="davidmcnab.041604122248.374"><vh>@file src-c/Desktop.h</vh></v>
<v t="davidmcnab.041604122248.375"><vh>@file src-c/Desktop.cpp</vh>
<v t="davidmcnab.041604122248.376"><vh>&lt;&lt; Desktop #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.377"><vh>&lt;&lt; Desktop declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.378"><vh>max_number</vh></v>
<v t="davidmcnab.041604122248.379"><vh>available_number</vh></v>
<v t="davidmcnab.041604122248.380"><vh>send_desktops</vh></v>
<v t="davidmcnab.041604122248.381"><vh>Desktop</vh></v>
<v t="davidmcnab.041604122248.382"><vh>Desktop</vh></v>
<v t="davidmcnab.041604122248.383"><vh>name</vh></v>
<v t="davidmcnab.041604122248.384"><vh>current</vh></v>
<v t="davidmcnab.041604122248.385"><vh>number</vh></v>
<v t="davidmcnab.041604122248.386"><vh>init_desktops</vh></v>
</v>
<v t="davidmcnab.041604122248.387" tnodeList="davidmcnab.041604122248.387"><vh>@file src-c/Frame.h</vh></v>
<v t="davidmcnab.041604122248.388" a="E" tnodeList="davidmcnab.041604122248.388,davidmcnab.041604122248.389,davidmcnab.041604122248.390,davidmcnab.041604122248.391,davidmcnab.041604122248.392,davidmcnab.041604122248.15,davidmcnab.041604122248.393,davidmcnab.041604122248.394,davidmcnab.041604122248.23,davidmcnab.041604122248.395,davidmcnab.041604122248.396,davidmcnab.041604122248.397,davidmcnab.041604122248.398,davidmcnab.041604122248.399,davidmcnab.041604122248.400,davidmcnab.041604122248.401,davidmcnab.041604122248.402,davidmcnab.041604122248.403,davidmcnab.041604122248.404,davidmcnab.041604122248.405,davidmcnab.041604122248.406,davidmcnab.041604122248.29,davidmcnab.041604122248.33,davidmcnab.041604122248.407,davidmcnab.041604122248.408,davidmcnab.041604122248.409,davidmcnab.041604122248.410,davidmcnab.041604122248.411,davidmcnab.041604122248.412,davidmcnab.041604122248.413,davidmcnab.041604122248.414,davidmcnab.041604122248.37,davidmcnab.041604122248.415,davidmcnab.041604122248.416,davidmcnab.041604122248.417,davidmcnab.041604122248.418,davidmcnab.041604122248.419,davidmcnab.041604122248.420,davidmcnab.041604122248.421,davidmcnab.041604122248.422,davidmcnab.041604122248.423,davidmcnab.041604122248.424,davidmcnab.041604122248.425,davidmcnab.041604122248.426,davidmcnab.041604122248.427,davidmcnab.041604122248.428,davidmcnab.041604122248.429,davidmcnab.041604122248.430,davidmcnab.041604122248.431,davidmcnab.041604122248.432,davidmcnab.041604122248.433,davidmcnab.041604122248.434,davidmcnab.041604122248.435,davidmcnab.041604122248.436,davidmcnab.041604122248.437,davidmcnab.041604122248.438,davidmcnab.041604122248.439,davidmcnab.041604122248.440"><vh>@file src-c/Frame.cpp</vh>
<v t="davidmcnab.041604122248.389"><vh>&lt;&lt; Frame #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.390"><vh>&lt;&lt; Frame declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.391"><vh>max</vh></v>
<v t="davidmcnab.041604122248.392"><vh>min</vh></v>
<v t="davidmcnab.041604122248.15" a="M"><vh>Frame</vh></v>
<v t="davidmcnab.041604122248.393"><vh>force_x_onscreen</vh></v>
<v t="davidmcnab.041604122248.394"><vh>force_y_onscreen</vh></v>
<v t="davidmcnab.041604122248.23" a=""><vh>~Frame</vh></v>
<v t="davidmcnab.041604122248.395"><vh>getLabel</vh></v>
<v t="davidmcnab.041604122248.396"><vh>getGnomeState</vh></v>
<v t="davidmcnab.041604122248.397"><vh>getSizes</vh></v>
<v t="davidmcnab.041604122248.398"><vh>maximize_width</vh></v>
<v t="davidmcnab.041604122248.399"><vh>maximize_height</vh></v>
<v t="davidmcnab.041604122248.400"><vh>getProtocols</vh></v>
<v t="davidmcnab.041604122248.401"><vh>getMotifHints</vh></v>
<v t="davidmcnab.041604122248.402"><vh>getColormaps</vh></v>
<v t="davidmcnab.041604122248.403"><vh>installColormap</vh></v>
<v t="davidmcnab.041604122248.404"><vh>fix_transient_for</vh></v>
<v t="davidmcnab.041604122248.405"><vh>is_transient_for</vh></v>
<v t="davidmcnab.041604122248.406"><vh>activate_if_transient</vh></v>
<v t="davidmcnab.041604122248.29" a=""><vh>Frame::activate</vh></v>
<v t="davidmcnab.041604122248.33" a=""><vh>Frame::deactivate</vh></v>
<v t="davidmcnab.041604122248.407"><vh>click_raise</vh></v>
<v t="davidmcnab.041604122248.408"><vh>throw_focus</vh></v>
<v t="davidmcnab.041604122248.409"><vh>state</vh></v>
<v t="davidmcnab.041604122248.410"><vh>setStateProperty</vh></v>
<v t="davidmcnab.041604122248.411"><vh>raise</vh></v>
<v t="davidmcnab.041604122248.412"><vh>lower</vh></v>
<v t="davidmcnab.041604122248.413"><vh>iconize</vh></v>
<v t="davidmcnab.041604122248.414"><vh>desktop</vh></v>
<v t="davidmcnab.041604122248.37" a=""><vh>Frame::set_size</vh></v>
<v t="davidmcnab.041604122248.415"><vh>Frame::setBorder</vh></v>
<v t="davidmcnab.041604122248.416"><vh>sendConfigureNotify</vh></v>
<v t="davidmcnab.041604122248.417"><vh>warp_pointer</vh></v>
<v t="davidmcnab.041604122248.418"><vh>updateBorder</vh></v>
<v t="davidmcnab.041604122248.419"><vh>show_hide_buttons</vh></v>
<v t="davidmcnab.041604122248.420"><vh>resize</vh></v>
<v t="davidmcnab.041604122248.421"><vh>close</vh></v>
<v t="davidmcnab.041604122248.422"><vh>kill</vh></v>
<v t="davidmcnab.041604122248.423"><vh>save_protocol</vh></v>
<v t="davidmcnab.041604122248.424"><vh>draw</vh></v>
<v t="davidmcnab.041604122248.425"><vh>redraw_clock</vh></v>
<v t="davidmcnab.041604122248.426"><vh>draw</vh></v>
<v t="davidmcnab.041604122248.427"><vh>button_cb</vh></v>
<v t="davidmcnab.041604122248.428"><vh>button_cb_static</vh></v>
<v t="davidmcnab.041604122248.429"><vh>mouse_location</vh></v>
<v t="davidmcnab.041604122248.430"><vh>set_cursor</vh></v>
<v t="davidmcnab.041604122248.431"><vh>auto_raise</vh></v>
<v t="davidmcnab.041604122248.432"><vh>handle</vh></v>
<v t="davidmcnab.041604122248.433"><vh>handle</vh></v>
<v t="davidmcnab.041604122248.434"><vh>getProperty</vh></v>
<v t="davidmcnab.041604122248.435"><vh>getProperty</vh></v>
<v t="davidmcnab.041604122248.436"><vh>getIntProperty</vh></v>
<v t="davidmcnab.041604122248.437"><vh>getIntProperty</vh></v>
<v t="davidmcnab.041604122248.438"><vh>setProperty</vh></v>
<v t="davidmcnab.041604122248.439"><vh>setProperty</vh></v>
<v t="davidmcnab.041604122248.440"><vh>sendMessage</vh></v>
</v>
<v t="davidmcnab.041604122248.441"><vh>@file src-c/FrameWindow.h</vh></v>
<v t="davidmcnab.041604122248.442"><vh>@file src-c/FrameWindow.cpp</vh>
<v t="davidmcnab.041604122248.443"><vh>&lt;&lt; FrameWindow #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.444"><vh>&lt;&lt; FrameWindow declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.445"><vh>show</vh></v>
<v t="davidmcnab.041604122248.446"><vh>hide</vh></v>
<v t="davidmcnab.041604122248.447"><vh>handle</vh></v>
</v>
<v t="davidmcnab.041604122248.448"><vh>@file src-c/Menu.cpp</vh>
<v t="davidmcnab.041604122248.449"><vh>&lt;&lt; Menu #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.450"><vh>window_deleted</vh></v>
<v t="davidmcnab.041604122248.451"><vh>frame_callback</vh></v>
<v t="davidmcnab.041604122248.452"><vh>move_frame_callback</vh></v>
<v t="davidmcnab.041604122248.453"><vh>frame_label_draw</vh></v>
<v t="davidmcnab.041604122248.454"><vh>frame_label_measure</vh></v>
<v t="davidmcnab.041604122248.455"><vh>label_draw</vh></v>
<v t="davidmcnab.041604122248.456"><vh>label_measure</vh></v>
<v t="davidmcnab.041604122248.457"><vh>cancel_cb</vh></v>
<v t="davidmcnab.041604122248.458"><vh>desktop_cb</vh></v>
<v t="davidmcnab.041604122248.459"><vh>delete_desktop_cb</vh></v>
<v t="davidmcnab.041604122248.460"><vh>new_desktop_ok_cb</vh></v>
<v t="davidmcnab.041604122248.461"><vh>new_desktop_cb</vh></v>
<v t="davidmcnab.041604122248.462"><vh>new_desktop_cb</vh></v>
<v t="davidmcnab.041604122248.463"><vh>exit_cb</vh></v>
<v t="davidmcnab.041604122248.464"><vh>logout_cb</vh></v>
<v t="davidmcnab.041604122248.465"><vh>spawn_cb</vh></v>
<v t="davidmcnab.041604122248.466"><vh>init</vh></v>
<v t="davidmcnab.041604122248.467"><vh>scan_wmx_dir</vh></v>
<v t="davidmcnab.041604122248.468"><vh>wmxCompare</vh></v>
<v t="davidmcnab.041604122248.469"><vh>load_wmx</vh></v>
<v t="davidmcnab.041604122248.470"><vh>is_active_frame</vh></v>
<v t="davidmcnab.041604122248.471"><vh>testhook</vh></v>
<v t="davidmcnab.041604122248.472"><vh>ShowTabMenu</vh></v>
<v t="davidmcnab.041604122248.473"><vh>ShowMenu</vh></v>
</v>
<v t="davidmcnab.041604122248.474"><vh>@file src-c/Hotkeys.cpp</vh>
<v t="davidmcnab.041604122248.475"><vh>&lt;&lt; Hotkeys #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.476"><vh>&lt;&lt; Hotkeys declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.477"><vh>NextWindow</vh></v>
<v t="davidmcnab.041604122248.478"><vh>PreviousWindow</vh></v>
<v t="davidmcnab.041604122248.479"><vh>NextDesk</vh></v>
<v t="davidmcnab.041604122248.480"><vh>PreviousDesk</vh></v>
<v t="davidmcnab.041604122248.481"><vh>DeskNumber</vh></v>
<v t="davidmcnab.041604122248.482"><vh>Raise</vh></v>
<v t="davidmcnab.041604122248.483"><vh>Lower</vh></v>
<v t="davidmcnab.041604122248.484"><vh>Iconize</vh></v>
<v t="davidmcnab.041604122248.485"><vh>Close</vh></v>
<v t="davidmcnab.041604122248.486"><vh>keybindings[]</vh></v>
<v t="davidmcnab.041604122248.42" a=""><vh>Handle_Hotkey</vh></v>
<v t="davidmcnab.041604122248.487"><vh>Grab_Hotkeys</vh></v>
<v t="davidmcnab.041604122248.71" a=""><vh>Hotkeys_bindKey</vh></v>
</v>
<v t="davidmcnab.041604122248.488"><vh>@file src-c/Rotated.h</vh></v>
<v t="davidmcnab.041604122248.489" a="E" tnodeList="davidmcnab.041604122248.489,davidmcnab.041604122248.490,davidmcnab.041604122248.491,davidmcnab.041604122248.492,davidmcnab.041604122248.493,davidmcnab.041604122248.494,davidmcnab.041604122248.495,davidmcnab.041604122248.496,davidmcnab.041604122248.497,davidmcnab.041604122248.498,davidmcnab.041604122248.499,davidmcnab.041604122248.500,davidmcnab.041604122248.501,davidmcnab.041604122248.502,davidmcnab.041604122248.503"><vh>@file src-c/Rotated.cpp</vh>
<v t="davidmcnab.041604122248.490"><vh>&lt;&lt; Rotated #includes &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.491"><vh>&lt;&lt; Rotated declarations &gt;&gt;</vh></v>
<v t="davidmcnab.041604122248.492"><vh>XRotLoadFont</vh></v>
<v t="davidmcnab.041604122248.493"><vh>XRotUnloadFont</vh></v>
<v t="davidmcnab.041604122248.494"><vh>XRotDrawString</vh></v>
<v t="davidmcnab.041604122248.495"><vh>XRotTextWidth</vh></v>
<v t="davidmcnab.041604122248.496"><vh>draw_rotated</vh></v>
<v t="davidmcnab.041604122248.497"><vh>draw_rotated</vh></v>
<v t="davidmcnab.041604122248.498"><vh>draw_rot90</vh></v>
<v t="davidmcnab.041604122248.499"><vh>draw_rotated90</vh></v>
<v t="davidmcnab.041604122248.500"><vh>draw_rot180</vh></v>
<v t="davidmcnab.041604122248.501"><vh>draw_rotated180</vh></v>
<v t="davidmcnab.041604122248.502"><vh>draw_rot270</vh></v>
<v t="davidmcnab.041604122248.503"><vh>draw_rotated270</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="davidmcnab.041604122248"></t>
<t tx="davidmcnab.041604122248.1"></t>
<t tx="davidmcnab.041604122248.2">@language
-------------------------------------------------------
*** README file for PYWM pythonic window manager

by David McNab &lt;david@rebirthing.co.nz&gt;

For information on compiling and installing, refer to the
INSTALL file in this toplevel directory.

--------------------------------------------------------
** What is PYWM?

PYWM is a comfortable, fast light window manager for X11
desktops that can be controlled via Python script.

Aim of PYWM is to create a window management infrastructure
that is easily learned, approachable, extensible and powerful.

With PYWM, you can customise almost any aspect of window
management. For example:

 * auto-launch selected programs when your window manager
   starts, and place them at certain sizes and positions when
   they start up.
 
 * create hotkeys to manipulate windows - move, resize, close,
   move to other desktops
 
 * schedule things to occur after a delay, or at regular
   intervals
 
 * dock two or more windows together
 
 * react to specific windows being created, moved, resized or
   closed - for instance, have a different set of hotkeys active
   for each particular window, or, ensure that certain windows
   always be opened with a fixed size and position
 
Also, you can create popup windows for your own custom menus.
(although this is currently under development - contributions
welcome!)

PYWM uses FLWM (Fast Light Window Manager - http://flwm.sf.net)
as its engine. Some hacks to the FLWM code have seen it
being repackaged as a python binary module, which is imported
by PYWM and launched.

I chose FLWM as the engine because it is fast, light and
simple, and in my mind, it gives the best trade-off between
size, speed, features and overall usage comfort.

--------------------------------------------------------
*** How do I use PYWM?

Easily.

Once you have properly installed PYWM (refer to the INSTALL
file), you can just put into your ~/.xinitrc file the
following command:

  /usr/bin/pywm-run.py

This will launch a 'chooser' program when X starts up, which
will let you launch your choice of PYWM script, or an X-Term
fallback. The first time pywm-run.py runs, it will create
a directory '.pywm' in your home directory and populate it
with one of the examples, plus the xterm fallback.

Refer to the README file in ~/.pywm for info on adding
options to this menu.

But if you find yourself hating pywm-launch.py, and just
want X to start up with your own PYWM script, then put
the following into ~/.xinitrc:

  python /path/to/my/pywm/script.py

Building your own custom window manager setup is as simple
as importing 'pywm' into your python script, subclassing the
basic window manager class, then launching it.

The simplest PYWM script is:

  #!/usr/bin/env python
  
  import pywm
  
  class myWindowManagerClass(pywm.WM):
    pass

  def main():
    myWindowManager = myWindowManagerClass()
    myWindowManager.run()
  
  if __name__ == '__main__':
    run()
  
--------------------------------------------------------
*** How do I customise PYWM?

In your window manager script, you can create a subclass of
pywm.WM, and in this subclass, you can define 'event handler'
methods which override the defaults. In these handlers, you
can take various actions according to your tastes.

Comprehensive API Doco can be found in the 'html' directory.

Here is a more complete boilerplate for a PYWM script:

   #!/usr/bin/env python
   
   import pywm
   
   class myWindowManagerClass(pywm.WM):
      def __init__(self, *args, **kwds):
         # add pre-initialisation commands here
         ...
         pywm.WM.__init__(self, **kwds)
         
         # add post-initialisation commands here
         ...
      
      def on_startup(self):
         """
         This is a callback which fires just befure the
         wm engine enters its event loop. Put your
         initialisations here, such as keybindings,
         launch commands etc
         """
         ...

      # add more callback routines here
      ...

   def run():
      myWindowManager = myWindowManagerClass()
      myWindowManager.run()
   
   if __name__ == '__main__':
      run()
   
Refer to the examples directory, which contains window manager
scripts ranging from very basic to quite complex.

----------------------------------------------------------
*** WHAT THE HECK IS THIS 'code.leo' FILE?

Leo - http://leo.sourceforge.net - is a phenomenally excellent
programmers editor 

The 'literate programming' school of thought has beme a
viable reality with Leo, which is arguably the first practical
and usable visual literate editor.

With Leo, you can create multiple distinct 'views' of your
source code, arranged in a tree structure. These different
views help enormously to make your cude more understandable
and coherent. Also, via 'cloned nodes', Leo lets you share
segments of code between different files.

Yes - many code editors have a 'tree pane'. But what makes Leo
different is that this tree structure is totally under your
control. You are not confined to a strict module/class/method
hierarchy.

Install Leo, and open up code.leo, and you will see what I mean.
The 'code.leo' file makes this whole project far easier to
understand and work with.

</t>
<t tx="davidmcnab.041604122248.3">@language
------------------------------------------------------
INSTALL file for PYWM - Python Window Manager
http://pywm.sourceforge.net
------------------------------------------------------
*** RUNTIME REQUIREMENTS

To run PYWM, you will need:

 * Python 2.2.1 or later
 * FLTK graphical toolkit - STRICTLY VERSION 1.0
   library and headers. If your distro does not have
   it, you can get it from http://fltk.sourceforge.net
 * xlibmesa3
 * libgl1
 * xlibs
 * libstdc++ - libs plus headers
 
------------------------------------------------------
*** INSTALLING BINARY PACKAGE

 * If you feel impatient, or you just hate building
   stuff from source, you could try the binary module
   included in this package.

 * The binary package is quite likely to work if your system
   has glibc version 2.2 or later, as well as Python 2.2.1 or
   later.
 
 * Note that this binary package is statically linked against
   FLTK version 1.0, so you need not bother downloading and
   installing FLTK version 1.0
    
 * To install the binary:
 
    (i)   Create a directory called 'flwm' and put it
          in your Python load path (quite often, this
          is /usr/lib/python2.2/site-packages).
    
    (ii)  Uncompress the file 'flwm_.so.bz2' with bunzip2
          then copy it into the 'flwm' directory
    
    (iii) Copy all the files in src-python into the
          'flwm' directory.

------------------------------------------------------
*** BUILDING FROM SOURCE

This section describes how to compile PYWM completely
from source and install it to your system.

------------------------------------------------------
**** COMPILATION REQUIREMENTS

Building from source will require the following:

  * python 2.2.1 or later
  * FLTK graphical toolkit - VERSION 1.0!
    at least the linkable libraries and header files.
    FLTK is available from http://fltk.sourceforge.net
    Make sure you have FLTK version 1.0 installed before
    trying to build PYWM.
  * Pyrex - Python&lt;-&gt;C interface generator. Best thing
    since Python itself. Get yours from:
    http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/
  * Development versions of the following libraries:
    libstdc++, xlibmesa3, libgl1, xlibs

------------------------------------------------------
*** COMPILATION INSTRUCTIONS

If you have successfully [built and] installed FLTK, you
can log in as root and type:
    
    make install

If the make completes successfully, you will have:
 
  * The PYWM launcher utility, installed as
    /usr/bin/pywm-run.py
    This program pops up a window of available window
    manager scripts, as well as an xterm fallback
    
  * The directory 'pywm' installed in your Python
    site-packages directory. Note that within this pywm
    directory is a copy of the examples directory.

------------------------------------------------------
*** HOW DO I RUN A WINDOW MANAGER?

Perhaps the most comfortable way to do this is to put
into your ~/.xinitrc file the command:

    pywm-run.py

When you restart your X server, you should see a menu on
the screen listing 2 options - 'example1' and 'X-Term'.

To add your own window manager scripts to this menu,
simply place or symlink these scripts into ~/.pywm.

Note that if you are adding a Python file, you will
need to copy or symlink it in with a .py or .pyc
extension. Anything with a different extension will be
ignored, while anything without an extension will be
launched with a shell instead of with python.
    
Look in the examples/ directory for some working
examples, which should give you some ideas for building
your own heavenly window managers.

Refer to the README file, plus the API reference manual
(in the html/ directory) for more information.

*** ALTERNATELY

You could simply put into your ~/.xinit file the command
  python /path/to/my/pywm/examples/example1.py
(replace example1.py with whatever script you are using).
</t>
<t tx="davidmcnab.041604122248.4">----------------------------------------------------------------
PYWM is Copyright (C) 2003 by
David McNab &lt;david@rebirthing.co.nz&gt;
PYWM website is http://pywm.sourceforge.net

Contains modified versions of modules from FLWM,
Copyright (C) 1998-1999 by Bill Spitzak
FLWM website is http://pywm.sourceforge.net
----------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this software; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA. Alternatively, you can download a copy of this license from
the GNU website at http://www.gnu.org
-----------------------------------------------------------------
</t>
<t tx="davidmcnab.041604122248.5">#
# Makefile for pywm window manager
#

# set this to your Python 2.2 interpreter
PYTHONCMD=/usr/bin/python2.3
BINDIR=/usr/bin

# set this to the full command for your favourite documentation generator
DOCCMD = epydoc -n "PYWM Reference Manual" --show-imports pywm

all:
	echo "Available targets:"
	echo "  pywm - build the pywm window manager"
	echo "  install - install pywm into python load path (requires root)"
	echo "  doc - generate pywm documentation"

pywm:
	$(PYTHONCMD) setup.py build

install:
	$(PYTHONCMD) setup.py install
	cp pywm-run.py $(BINDIR)

doc:
	$(DOCCMD)

</t>
<t tx="davidmcnab.041604122248.6">from distutils.core import setup
from distutils.extension import Extension
from Pyrex.Distutils import build_ext

import sys

pyIncludes = '/usr/include/python2.2'
libdirs = ['/usr/X11R6/lib']
defines = []
#libs = ['X11', 'Xext', 'fltk', 'm']
libs = ['X11', 'Xext', 'm']

# edit this to point to your FLTK **VERSON 1.0** static library
#extra_link_args = ['fltk-1.0.11/lib/libfltk.a']
extra_link_args = ['/usr/lib/libfltk.a']

# edit this to point to your FLTK **VERSION 1.0** headers
fltkInclude = '../fltk-1.0.11'

flwmSources=['src-pyrex/flwm_.pyx',
             'src-c/main.cpp',
             'src-c/Menu.cpp',
             'src-c/Hotkeys.cpp',
             'src-c/Rotated.cpp',
             'src-c/Desktop.cpp',
             'src-c/Frame.cpp',
             'src-c/FrameWindow.cpp',
             'src-c/flwmapi.cpp',
             ]

ext_flwm = [Extension('pywm.flwm_',
                      flwmSources,
                      include_dirs=[fltkInclude,
                                    pyIncludes,
                                    "/usr/include",
                                    "../src-c",
                                    "../src-pyrex"
                                    ],
                      define_macros=defines,
                      libraries=libs,
                      library_dirs=libdirs,
                      extra_link_args=extra_link_args
                      )]
                      
setup(
  name = "pywm",
  packages = ["pywm", "pywm.examples"],
  package_dir = {'pywm':'src-python',
                 'pywm.examples':'examples'},
  version = '0.1',
  ext_modules=ext_flwm,
  cmdclass = {'build_ext': build_ext}
)
</t>
<t tx="davidmcnab.041604122248.7"></t>
<t tx="davidmcnab.041604122248.8"></t>
<t tx="davidmcnab.041604122248.9"></t>
<t tx="davidmcnab.041604122248.10"></t>
<t tx="davidmcnab.041604122248.11">
int main0(int argc, char** argv, PyObject *wmobj) {
  int i;

  pyClient = wmobj;
  Py_INCREF(wmobj);
  
  //program_name = filename_name(argv[0]);

  printf("*********** LAUNCHING FLWM *******************\n");
  //printf("main: argc=%d\n", argc);
  //for (i = 0; i &lt; argc; i++)
  //{
  //    printf("main: argv[%d] = %s\n", i, argv[i]);
  //}

  if (Fl::args(argc, argv, i, arg) &lt; argc) Fl::error(
"options are:\n"
" -d[isplay] host:#.#\tX display &amp; screen to use\n"
" -v[isual] #\t\tvisual to use\n"
" -g[eometry] WxH+X+Y\tlimits windows to this area\n"
" -m[aximum] WxH\t\tsize of maximized windows\n"
" -x\t\t\tmenu says Exit instead of logout\n"
" -bg color\t\tFrame color\n"
" -fg color\t\tLabel color\n"
" -bg2 color\t\tText field color\n"
" -c[ursor] #\t\tCursor number for root\n"
" -cfg color\t\tCursor color\n"
" -abg color\t\tActive window frame color\n"
" -cbg color\t\tCursor outline color"
);
#ifndef FL_NORMAL_SIZE // detect new versions of fltk where this is a variable
  FL_NORMAL_SIZE = 12;
#endif
  Fl::set_color(FL_SELECTION_COLOR,0,0,128);
  Root = new Fl_Root(wmobj);
  Root-&gt;show(argc,argv); // fools fltk into using -geometry to set the size
  XSetErrorHandler(xerror_handler);
  initialize();

  Fl::check();

  // ****************************************
  py_on_startup(wmobj);
  // ****************************************

  return Fl::run();
}

extern "C" int flwm_main(int argc, char **argv, PyObject *wmobj)
{
  return main0(argc, argv, wmobj);
}


</t>
<t tx="davidmcnab.041604122248.12">cdef public py_on_startup(object wm):
    printf("on_startup: entered\n")
    wm.on_startup()
    printf("on_startup: done\n")
</t>
<t tx="davidmcnab.041604122248.13">def on_startup(self):
    print "WM.on_startup: entered"
    print "WM.on_startup: binding a key"

    print "WM.on_startup: keybinding ok"
</t>
<t tx="davidmcnab.041604122248.14"></t>
<t tx="davidmcnab.041604122248.15">

@ The constructor is by far the most complex part, as it collects
all the scattered pieces of information about the window that
X has and uses them to initialize the structure, position the
window, and then finally create it.
@c

int dont_set_event_mask = 0; // used by FrameWindow

// "existing" is a pointer to an XWindowAttributes structure that is
// passed for an already-existing window when the window manager is
// starting up.  If so we don't want to alter the state, size, or
// position.  If null than this is a MapRequest of a new window.
Frame::Frame(Window window, XWindowAttributes* existing) :
  Fl_Window(0,0),
  window_(window),
  state_flags_(0),
  flags_(0),
  transient_for_xid(None),
  transient_for_(0),
  revert_to(active_),
  colormapWinCount(0),
  close_button(BUTTON_LEFT,BUTTON_TOP,BUTTON_W,BUTTON_H,"X"),
  iconize_button(BUTTON_LEFT,BUTTON_TOP,BUTTON_W,BUTTON_H,"i"),
  max_h_button(BUTTON_LEFT,BUTTON_TOP+3*BUTTON_H,BUTTON_W,BUTTON_H,"h"),
  max_w_button(BUTTON_LEFT,BUTTON_TOP+BUTTON_H,BUTTON_W,BUTTON_H,"w"),
  min_w_button(BUTTON_LEFT,BUTTON_TOP+2*BUTTON_H,BUTTON_W,BUTTON_H,"W")
{
  int pyres;
    
  close_button.callback(button_cb_static);
  iconize_button.callback(button_cb_static);
  max_h_button.type(FL_TOGGLE_BUTTON);
  max_h_button.callback(button_cb_static);
  max_w_button.type(FL_TOGGLE_BUTTON);
  max_w_button.callback(button_cb_static);
  min_w_button.type(FL_TOGGLE_BUTTON);
  min_w_button.callback(button_cb_static);
  end();
  box(FL_NO_BOX); // relies on background color erasing interior
  next = first;
  first = this;

  // do this asap so we don't miss any events...
  if (!dont_set_event_mask)
    XSelectInput(fl_display, window_,
		 ColormapChangeMask | PropertyChangeMask | FocusChangeMask
		 );

  if (!wm_state) {
    // allocate all the atoms if this is the first time
    wm_state		= XInternAtom(fl_display, "WM_STATE",		0);
    wm_change_state	= XInternAtom(fl_display, "WM_CHANGE_STATE",	0);
    wm_protocols	= XInternAtom(fl_display, "WM_PROTOCOLS",	0);
    wm_delete_window	= XInternAtom(fl_display, "WM_DELETE_WINDOW",	0);
    wm_take_focus	= XInternAtom(fl_display, "WM_TAKE_FOCUS",	0);
    wm_save_yourself	= XInternAtom(fl_display, "WM_SAVE_YOURSELF",	0);
    wm_colormap_windows	= XInternAtom(fl_display, "WM_COLORMAP_WINDOWS",0);
    _motif_wm_hints	= XInternAtom(fl_display, "_MOTIF_WM_HINTS",	0);
    kwm_win_decoration	= XInternAtom(fl_display, "KWM_WIN_DECORATION",	0);
#if DESKTOPS
    kwm_win_desktop	= XInternAtom(fl_display, "KWM_WIN_DESKTOP",	0);
    kwm_win_sticky	= XInternAtom(fl_display, "KWM_WIN_STICKY",	0);
#endif
//  wm_client_leader	= XInternAtom(fl_display, "WM_CLIENT_LEADER",	0);
    _wm_quit_app	= XInternAtom(fl_display, "_WM_QUIT_APP",	0);
  }

  label_y = label_h = label_w = 0;
  getLabel();
  // getIconLabel();

  {XWindowAttributes attr;
  if (existing) attr = *existing;
  else {
    // put in some legal values in case XGetWindowAttributes fails:
    attr.x = attr.y = 0; attr.width = attr.height = 100;
    attr.colormap = fl_colormap;
    attr.border_width = 0;
    XGetWindowAttributes(fl_display, window, &amp;attr);
  }
  left = top = dwidth = dheight = 0; // pretend border is zero-width for now
  app_border_width = attr.border_width;
  x(attr.x+app_border_width); restore_x = x();
  y(attr.y+app_border_width); restore_y = y();
  w(attr.width); restore_w = w();
  h(attr.height); restore_h = h();
  colormap = attr.colormap;}

  getColormaps();

  //group_ = 0;
  {XWMHints* hints = XGetWMHints(fl_display, window_);
  if (hints) {
    if ((hints-&gt;flags &amp; InputHint) &amp;&amp; !hints-&gt;input) set_flag(NO_FOCUS);
    //if (hints &amp;&amp; hints-&gt;flags&amp;WindowGroupHint) group_ = hints-&gt;window_group;
  }
  switch (getIntProperty(wm_state, wm_state, 0)) {
  case NormalState:
    state_ = NORMAL; break;
  case IconicState:
    state_ = ICONIC; break;
  // X also defines obsolete values ZoomState and InactiveState
  default:
    if (hints &amp;&amp; (hints-&gt;flags&amp;StateHint) &amp;&amp; hints-&gt;initial_state==IconicState)
      state_ = ICONIC;
    else
      state_ = NORMAL;
  }
  if (hints) XFree(hints);}
  // Maya sets this, seems to mean the same as group:
  // if (!group_) group_ = getIntProperty(wm_client_leader, XA_WINDOW);

  XGetTransientForHint(fl_display, window_, &amp;transient_for_xid);

  getProtocols();

  getMotifHints();

  // get Gnome hints:
  int p = getIntProperty(_win_hints, XA_CARDINAL);
  if (p&amp;1) set_flag(NO_FOCUS);		// WIN_HINTS_SKIP_FOCUS
  // if (p&amp;2)				// WIN_HINTS_SKIP_WINLIST
  // if (p&amp;4)				// WIN_HINTS_SKIP_TASKBAR
  // if (p&amp;8) ...			// WIN_HINTS_GROUP_TRANSIENT
  if (p&amp;16) set_flag(CLICK_TO_FOCUS);	// WIN_HINTS_FOCUS_ON_CLICK

  // get KDE hints:
  p = getIntProperty(kwm_win_decoration, kwm_win_decoration, 1);
  if (!(p&amp;3)) set_flag(NO_BORDER);
  else if (p &amp; 2) set_flag(THIN_BORDER);
  if (p &amp; 256) set_flag(NO_FOCUS);

  fix_transient_for();

  if (transient_for())
  {
    if (state_ == NORMAL) state_ = transient_for()-&gt;state_;
#if DESKTOPS
    desktop_ = transient_for()-&gt;desktop_;
#endif
  }

#if DESKTOPS
  // see if anybody thinks window is "sticky:"
  else if ((getIntProperty(_win_state, XA_CARDINAL) &amp; 1) // WIN_STATE_STICKY
      || getIntProperty(kwm_win_sticky, kwm_win_sticky)) {
    desktop_ = 0;
  } else {
    // get the desktop from either Gnome or KDE (Gnome takes precedence):
    p = getIntProperty(_win_workspace, XA_CARDINAL, -1) + 1; // Gnome desktop
    if (p &lt;= 0) p = getIntProperty(kwm_win_desktop, kwm_win_desktop);
    if (p &gt; 0 &amp;&amp; p &lt; 25)
      desktop_ = Desktop::number(p, 1);
    else
      desktop_ = Desktop::current();
  }
  if (desktop_ &amp;&amp; desktop_ != Desktop::current())
    if (state_ == NORMAL) state_ = OTHER_DESKTOP;
#endif

  int autoplace = getSizes();
  // some Motif programs assumme this will force the size to conform :-(
  if (w() &lt; min_w || h() &lt; min_h) {
    if (w() &lt; min_w) w(min_w);
    if (h() &lt; min_h) h(min_h);
    XResizeWindow(fl_display, window_, w(), h());
  }

  // try to detect programs that think "transient_for" means "no border":
  if (transient_for_xid &amp;&amp; !label() &amp;&amp; !flag(NO_BORDER)) {
    set_flag(THIN_BORDER);
  }
  updateBorder();
  show_hide_buttons();

  if (autoplace &amp;&amp; !existing &amp;&amp; !(transient_for() &amp;&amp; (x() || y()))) {
    // autoplacement (stupid version for now)
    x(Root-&gt;x()+(Root-&gt;w()-w())/2);
    y(Root-&gt;y()+(Root-&gt;h()-h())/2);
    // move it until it does not hide any existing windows:
    const int delta = TITLE_WIDTH+LEFT;
    for (Frame* f = next; f; f = f-&gt;next) {
      if (f-&gt;x()+delta &gt; x() &amp;&amp; f-&gt;y()+delta &gt; y() &amp;&amp;
	  f-&gt;x()+f-&gt;w()-delta &lt; x()+w() &amp;&amp; f-&gt;y()+f-&gt;h()-delta &lt; y()+h()) {
	x(max(x(),f-&gt;x()+delta));
	y(max(y(),f-&gt;y()+delta));
	f = this;
      }
    }
  }
  // move window so contents and border are visible:
  x(force_x_onscreen(x(), w()));
  y(force_y_onscreen(y(), h()));

  // guess some values for the "restore" fields, if already maximized:
  if (max_w_button.value()) {
    restore_w = min_w + ((w()-dwidth-min_w)/2/inc_w) * inc_w;
    restore_x = x()+left + (w()-dwidth-restore_w)/2;
  }
  if (max_h_button.value()) {
    restore_h = min_h + ((h()-dheight-min_h)/2/inc_h) * inc_h;
    restore_y = y()+top + (h()-dheight-restore_h)/2;
  }

  const int mask = CWBorderPixel | CWColormap | CWEventMask | CWBitGravity
    | CWBackPixel | CWOverrideRedirect;
  XSetWindowAttributes sattr;
  sattr.event_mask = XEventMask;
  sattr.colormap = fl_colormap;
  sattr.border_pixel = fl_xpixel(FL_GRAY0);
  sattr.bit_gravity = NorthWestGravity;
  sattr.override_redirect = 1;
  sattr.background_pixel = fl_xpixel(FL_GRAY);
  Fl_X::set_xid(this, XCreateWindow(fl_display, fl_xid(Root),
			     x(), y(), w(), h(), 0,
			     fl_visual-&gt;depth,
			     InputOutput,
			     fl_visual-&gt;visual,
			     mask, &amp;sattr));

  setStateProperty();

// vvvvv
  if (!dont_set_event_mask) XAddToSaveSet(fl_display, window_);

  if (existing)
      set_state_flag(IGNORE_UNMAP);

    XReparentWindow(fl_display, window_, fl_xid(this), left, top);

// ^^^^^^^

  XSetWindowBorderWidth(fl_display, window_, 0);

  if (state_ == NORMAL)
      XMapWindow(fl_display, window_);
  sendConfigureNotify(); // many apps expect this even if window size unchanged

#if CLICK_RAISES || CLICK_TO_TYPE
  XGrabButton(fl_display, AnyButton, AnyModifier, window, False,
	      ButtonPressMask, GrabModeSync, GrabModeAsync, None, None);
#endif

  if (state_ == NORMAL) {
    XMapWindow(fl_display, fl_xid(this));
    if (!existing) activate_if_transient();
  }

  // *********************************************
  //printf("Frame:: this=0x%lx, label=%s\n", this, this-&gt;label());
  //printf("pywmNesting=%d\n", pywmNesting);
  pywmNesting++;
  py_on_create(pyClient, (long)this);
  pywmNesting--;
  // *********************************************


}
</t>
<t tx="davidmcnab.041604122248.16">cdef public py_on_create(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    #print "py_on_create: win=%lx" % hWin
    pWin = wm._addWin(hWin)
    wm.on_create(pWin)
    #print "py_on_create: made it"


</t>
<t tx="davidmcnab.041604122248.17">def _addWin(self, hWin):
    """
    Makes a window known to this wm object
    
    Used by the lower level window create event handler.
    Don't call this yourself.
    """
    #print "WM._addWin 1: hWin=0x%lx" % hWin
    #print dir(self)
    #print type(self.windowclass)
    #print "WM._addWin 2"
    #print self.windowclass.__class__

    win = self.windowclass(hWin)
    #win = window(hWin)

    #print "WM._addWin 3"
    self.windows[hWin] = win
    self.currentWindow = win
    return win

</t>
<t tx="davidmcnab.041604122248.18">def __init__(self, hWin):
    """
    You should not instantiate windows yourself.
    This constructor gets called when the WM engine detects that a
    window has been created (or a previously known window has been
    restored into view).
    """
    #print "window.__init__: entered, hWin=0x%lx" % hWin
    self.hWin = hWin        # save the ptr for later use
    #print "window.__init__:2: entered, hWin=0x%lx" % hWin
    self.name = self.getname()           # get titlebar text

    print "getting screen size"
    self.screenWidth, self.screenHeight = self.getScreenSize()
    print "got screen size"
    
    self.isMax = False
    self.isMaxWidth = False
    self.isMaxHeight = False

    #print "window.__init__:3"
    #print "window.__init__:name=%s" % self.name


</t>
<t tx="davidmcnab.041604122248.19">def getname(self):
    """
    Call this to return the current setting of the window's title bar
    """
    #print "window.getname 1"
    name = flwm_.getLabel(self.hWin)
    #print "window.getname 2"
    return name



</t>
<t tx="davidmcnab.041604122248.20">def on_create(self, win):
    """
    Called when a new window is created (or an existing one un-hidden).
    
    Single argument is 'win', a ref to a window object
    
    Return 1 if you want the window framed, or 0 if not
    """
    print "WM.on_create: created window '%s'" % win.name
    return 1</t>
<t tx="davidmcnab.041604122248.21">def on_create(self, win):

    print "myWM.on_create: created window '%s'" % win.name
    #return

    x, y = win.position()
    #print "myWM:on_create: win.position succeeded"
    w, h = win.size()
    #print "myWM:on_create: win.size succeeded"
    #print "myWM:on_create: x=%d y=%d w=%d h=%d" % (x, y, w, h)
    #return
 
    # move the window
    if win.name == "xterm":
        #print "got xterm,, but bailing for now"
        #return
        self.xterm = win
        #print "myWM.on_create: trying to reposition and resize xterm"
        win.position(0, 0)
        win.size(600, 600)
        #print "myWM.on_create: repos/resize seems ok"
        return
        if self.vi:
            print "trying to close vi window"
            self.vi.close()

    if win.name == "vi":
        #print "myWM.on_create: got vi started"
        self.vi = win
        #return 
        self.launch("xterm")
        #print "myWM.on_create: tried to launch xterm"

</t>
<t tx="davidmcnab.041604122248.22"></t>
<t tx="davidmcnab.041604122248.23">@ destructor
The destructor is called on DestroyNotify, so I don't have to do anything
to the contained window, which is already been destroyed.
fltk bug: it does not clear these pointers when window is deleted,
causing flwm to crash on window close sometimes:
@c

extern Fl_Window *fl_xfocus;
extern Fl_Window *fl_xmousewin;

Frame::~Frame() {

  // It is possible for the frame to be destroyed while the menu is
  // popped-up, and the menu will still contain a pointer to it.  To
  // fix this the menu checks the state_ location for a legal and
  // non-withdrawn state value before doing anything.  This should
  // be reliable unless something reallocates the memory and writes
  // a legal state value to this location:
  state_ = UNMAPPED;

  // fix fltk bug:
  fl_xfocus = 0;
  fl_xmousewin = 0;
  Fl::focus_ = 0;

  // remove any pointers to this:
  Frame** cp; for (cp = &amp;first; *cp; cp = &amp;((*cp)-&gt;next))
    if (*cp == this) {*cp = next; break;}
  for (Frame* f = first; f; f = f-&gt;next) {
    if (f-&gt;transient_for_ == this) f-&gt;transient_for_ = transient_for_;
    if (f-&gt;revert_to == this) f-&gt;revert_to = revert_to;
  }
  throw_focus(1);

  if (colormapWinCount) {
    XFree((char *)colormapWindows);
    delete[] window_Colormaps;
  }
  //if (iconlabel()) XFree((char*)iconlabel());
  if (label())     XFree((char*)label());

  // ********************************************************
  py_on_destroy(pyClient, (long)this);
  // ********************************************************

}
</t>
<t tx="davidmcnab.041604122248.24">cdef public py_on_destroy(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("on_destroy: entered - got instance\n", win)
    wm.on_destroy(pWin)
    wm._delWin(hWin)

</t>
<t tx="davidmcnab.041604122248.25">def on_destroy(self, win):
    """
    Called when an existing window is being destroyed (or hidden)
    
    If overriding in a subclass, call this parent method just before you exit
    """
    print "WM.on_destroy: destroying '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.26">def on_destroy(self, win):
    print "myWM:on_destroy: destroyed window '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.27">def _delWin(self, hWin):
    """
    Deletes a window's mapping from our dict.
    
    Called by underlying handler of window delete events.
    
    Don't call this yourself
    """
    if self.windows.has_key(win):
        print "wm._delWin: destroyed '%s'" % self.windows[win].name
        del self.windows[win]
    else:
        print "WM._delWin destroying unknown window??!?"
</t>
<t tx="davidmcnab.041604122248.28"></t>
<t tx="davidmcnab.041604122248.29">
////////////////////////////////////////////////////////////////

int Frame::activate(int warp) {

  // see if a modal &amp; newer window is up:
  for (Frame* c = first; c &amp;&amp; c != this; c = c-&gt;next)
    if (c-&gt;flag(MODAL) &amp;&amp; c-&gt;transient_for() == this)
      if (c-&gt;activate(warp)) return 1;
  // ignore invisible windows:
  if (state() != NORMAL || w() &lt;= dwidth) return 0;
  // always put in the colormap:
  installColormap();
  // move the pointer if desired:
  // (note that moving the pointer is pretty much required for point-to-type
  // unless you know the pointer is already in the window):
  if (!warp || Fl::event_state() &amp; (FL_BUTTON1|FL_BUTTON2|FL_BUTTON3)) {
    ;
  } else if (warp==2) {
    // warp to point at title:
    XWarpPointer(fl_display, None, fl_xid(this), 0,0,0,0, left/2+1,
                 min(label_y+label_w/2+1,h()/2));
  } else {
    warp_pointer();
  }
  // skip windows that don't want focus:
  if (flag(NO_FOCUS)) return 0;
  // set this even if we think it already has it, this seems to fix
  // bugs with Motif popups:
  XSetInputFocus(fl_display, window_, RevertToPointerRoot, fl_event_time);
  if (active_ != this) {
    if (active_) active_-&gt;deactivate();
    active_ = this;
#if defined(ACTIVE_COLOR)
    XSetWindowAttributes a;
    a.background_pixel = fl_xpixel(FL_SELECTION_COLOR);
    XChangeWindowAttributes(fl_display, fl_xid(this), CWBackPixel, &amp;a);
    labelcolor(contrast(FL_BLACK, FL_SELECTION_COLOR));
    XClearArea(fl_display, fl_xid(this), 2, 2, w()-4, h()-4, 1);
#else
#if defined(SHOW_CLOCK)
    redraw();
#endif
#endif
    if (flag(TAKE_FOCUS_PROTOCOL))
      sendMessage(wm_protocols, wm_take_focus);
  }

  // ************************************************
  py_on_activate(pyClient, (long)this);
  // ************************************************

  return 1;
}
</t>
<t tx="davidmcnab.041604122248.30">cdef long lastActiveWindow

cdef public py_on_activate(object wm, unsigned long win):
    global lastActiveWindow
    if win != lastActiveWindow:
        lastActiveWindow = win
        hWin = PyLong_FromLong(win)
        pWin = wm.window(hWin)
        #printf("on_activate: entered - got instance\n", win)
        wm.on_activate(pWin)
</t>
<t tx="davidmcnab.041604122248.31">def on_activate(self, win):
    """
    Called when an existing window is activated
    """
    print "WM.on_activate: activated '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.32"></t>
<t tx="davidmcnab.041604122248.33">@ this private function should only be called by constructor and if
the window is active():
@c

void Frame::deactivate()
{
    //printf("Frame::deactivate: window %s\n", this-&gt;label());

#if defined(ACTIVE_COLOR)
    XSetWindowAttributes a;
    a.background_pixel = fl_xpixel(FL_GRAY);
    XChangeWindowAttributes(fl_display, fl_xid(this), CWBackPixel, &amp;a);
    labelcolor(FL_BLACK);
    XClearArea(fl_display, fl_xid(this), 2, 2, w()-4, h()-4, 1);
#else
#if defined(SHOW_CLOCK)
    redraw();
#endif
#endif

  // ************************************************
  py_on_deactivate(pyClient, (long)this);
  // ************************************************
}
</t>
<t tx="davidmcnab.041604122248.34">cdef public py_on_deactivate(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("on_deactivate: entered - got instance\n", win)
    wm.on_deactivate(pWin)
</t>
<t tx="davidmcnab.041604122248.35">def on_deactivate(self, win):
    """
    Called when an existing window is deactivated
    """
    print "WM.on_activate: deactivated '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.36"></t>
<t tx="davidmcnab.041604122248.37">#endif

////////////////////////////////////////////////////////////////

// Resize and/or move the window.  The size is given for the frame, not
// the contents.  This also sets the buttons on/off as needed:

//void Frame::set_size(int nx, int ny, int nw, int nh, int warp=0, int no_callback=0) {
void Frame::set_size(int nx, int ny, int nw, int nh, int warp, int no_callback) {
  int dx = nx-x(); x(nx);
  int dy = ny-y(); y(ny);
  if (!dx &amp;&amp; !dy &amp;&amp; nw == w() &amp;&amp; nh == h()) return;
  int unmap = 0;
  int remap = 0;
  // use XClearArea to cause correct damage events:
  
  //printf("Frame::set_size: nx=%d ny=%d nw=%d nh=%d warp=%d\n",
  //       nx, ny, nw, nh, warp);

  // **************************************
  if (no_callback == 0)
      py_on_resize(pyClient, (long)this, nx, ny, nw, nh, warp);
  // **************************************

  if (nw != w()) {
    max_w_button.value(nw-dwidth == maximize_width());
    min_w_button.value(nw &lt;= dwidth);
    if (nw &lt;= dwidth) {
      unmap = 1;
    } else {
      if (w() &lt;= dwidth) remap = 1;
    }
    int minw = (nw &lt; w()) ? nw : w();
    XClearArea(fl_display, fl_xid(this), minw-RIGHT, 0, RIGHT, nh, 1);
    w(nw);
  }
  if (nh != h()) {
    max_h_button.value(nh-dheight == maximize_height());
    int minh = (nh &lt; h()) ? nh : h();
    XClearArea(fl_display, fl_xid(this), 0, minh-BOTTOM, w(), BOTTOM, 1);
    // see if label or close box moved, erase the minimum area:
    int old_label_y = label_y;
    int old_label_h = label_h;
    h(nh); show_hide_buttons();
#ifdef SHOW_CLOCK
    int t = label_y + 3; // we have to clear the entire label area
#else
    int t = nh;
    if (label_y != old_label_y) {
      t = label_y; if (old_label_y &lt; t) t = old_label_y;
    } else if (label_y+label_h != old_label_y+old_label_h) {
      t = label_y+label_h;
      if (old_label_y+old_label_h &lt; t) t = old_label_y+old_label_h;
    }
#endif
    if (t &lt; nh &amp;&amp; left&gt;LEFT)
      XClearArea(fl_display,fl_xid(this), 1, t, left-1, nh-t, 1);
  }
  // for maximize button move the cursor first if window gets smaller
  if (warp == 1 &amp;&amp; (dx || dy))
    XWarpPointer(fl_display, None,None,0,0,0,0, dx, dy);
  // for configure request, move the cursor first
  if (warp == 2 &amp;&amp; active() &amp;&amp; !Fl::pushed()) warp_pointer();
  XMoveResizeWindow(fl_display, fl_xid(this), nx, ny, nw, nh);
  if (nw &lt;= dwidth) {
    if (unmap) {
      set_state_flag(IGNORE_UNMAP);
      XUnmapWindow(fl_display, window_);
    }
  } else {
    XResizeWindow(fl_display, window_, nw-dwidth, nh-dheight);
    if (remap) {
      XMapWindow(fl_display, window_);
#if CLICK_TO_TYPE
      if (active()) activate();
#else
      activate();
#endif
    }
  }
  // for maximize button move the cursor second if window gets bigger:
  if (warp == 3 &amp;&amp; (dx || dy))
    XWarpPointer(fl_display, None,None,0,0,0,0, dx, dy);
  if (nw &gt; dwidth) sendConfigureNotify();
  XSync(fl_display,0);
}


</t>
<t tx="davidmcnab.041604122248.38">cdef public int py_on_resize(object wm, unsigned long win,
                             int x, int y, int w, int h, int warp):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("on_resize: entered - got instance\n")
    wm.on_resize(pWin, x, y, w, h)
</t>
<t tx="davidmcnab.041604122248.39">def on_resize(self, win, x, y, w, h):
    """
    Called when the size of the window changes.
        
    If overriding, you need to accept the arguments:
      - hWin, x, y, w, h
    where hWin is the python handle for the window
    and x, y, w, h are the new position and size for the window
    """
    label = win.name
    #print "WM.on_destroy: entered"
    print "flwm.WM.on_resize: x=%d y=%d w=%d h=%d name=%s" % (x, y, w, h, label)
    #print "label = '%s'" % label

</t>
<t tx="davidmcnab.041604122248.40">def on_resize(self, win, x, y, w, h):
    #print "on_resize"
    #print "myWM.on_resize: x=%d y=%d w=%d h=%d name=%s" % (x, y, w, h, win.name)
    return

    if win.name == 'Terminal':
        self.xterm.position(x, y-self.xterm.height())
    return 0

</t>
<t tx="davidmcnab.041604122248.41"></t>
<t tx="davidmcnab.041604122248.42">
#endif

int Handle_Hotkey()
{
  int key = Fl::event_key();

  //if (Fl::test_shortcut(FL_SHIFT + FL_ALT + key))
  //{
  //   printf("SHIFT-ALT %x\n");
  //   key += FL_SHIFT + FL_ALT;
  //}

  if (Fl::test_shortcut(FL_SHIFT + key))
    key |= FL_SHIFT + key;
  if (Fl::test_shortcut(FL_CTRL + key))
    key |= FL_CTRL + key;
  if (Fl::test_shortcut(FL_ALT + key))
    key |= FL_ALT + key;
  if (Fl::test_shortcut(FL_META + key))
    key |= FL_META + key;

  if (Fl::test_shortcut(FL_SHIFT + FL_CTRL + key))
    key |= FL_SHIFT + FL_CTRL + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_ALT + key))
    key |= FL_SHIFT + FL_ALT + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_META + key))
    key |= FL_SHIFT + FL_META + key;
  if (Fl::test_shortcut(FL_CTRL + FL_ALT + key))
    key |= FL_CTRL + FL_ALT + key;
  if (Fl::test_shortcut(FL_CTRL + FL_META + key))
    key |= FL_CTRL + FL_META + key;
  if (Fl::test_shortcut(FL_ALT + FL_META + key))
    key |= FL_ALT + FL_META + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_CTRL + FL_ALT + key))
    key |= FL_SHIFT + FL_CTRL + FL_ALT + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_CTRL + FL_META + key))
    key |= FL_SHIFT + FL_CTRL + FL_META + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_ALT + FL_META + key))
    key |= FL_SHIFT + FL_ALT + FL_META + key;
  if (Fl::test_shortcut(FL_CTRL + FL_ALT + FL_META + key))
    key |= FL_CTRL + FL_ALT + FL_META + key;
  if (Fl::test_shortcut(FL_SHIFT + FL_CTRL + FL_ALT + FL_META + key))
    key |= FL_SHIFT + FL_CTRL + FL_ALT + FL_META + key;

  //printf("Handle_Hotkey: entered - key=%x\n", key);

  if (py_on_keyEvent(pyClient, (long)key))
      return 1;
                       
  for (int i = 0; keybindings[i].key; i++) {
    if (Fl::test_shortcut(keybindings[i].key)
        || ((keybindings[i].key &amp; 0xFFFF) == FL_Delete
            	&amp;&amp; Fl::event_key() == FL_BackSpace// fltk bug?
             )
	)
    {
      keybindings[i].func();
      return 1;
    }
  }
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.43">cdef public int py_on_keyEvent(object wm, int key):
    cdef long cRes
    pKey = PyLong_FromLong(key)
    #print "py_on_keyEvent: got keystroke"
    res = wm.on_keyEvent(pKey)
    cRes = PyLong_AsLong(res)
    return cRes

</t>
<t tx="davidmcnab.041604122248.44">def on_keyEvent(self, key):
    """
    Called when a Ctrl-Alt key sequence is received.
    """
    #print "wm.on_keyEvent callback: key=%x" % key
    #print self._keyBindings
    if self._keyBindings.has_key(key):
        #print "wm.on_keyEvent: known key, launching func"
        func = self._keyBindings[key]
        arg = self._keyBindingsArg[key]
        func(arg)
        #print "wm.on_keyEvent: back from func"
        return 1
    else:
        #print "wm.on_keyEvent: unknown key"
        #print self._keyBindings.keys()
        return 0



</t>
<t tx="davidmcnab.041604122248.45"></t>
<t tx="davidmcnab.041604122248.46"></t>
<t tx="davidmcnab.041604122248.47">def position(self, x=None, y=None):
    """
    Gets or sets the window position
    
    Call with no arguments to fetch the position as a tuple
    Call with x,y to set the window position
    """
    #print "window.position: entered"
    #return 0, 0
    if x == None:
        #print "window.size: about to call flwm_.getSize"
        x, y = flwm_.getPos(self.hWin)
        #print "window.size: returned from flwm_.getSize"
        return x, y
    else:
        #print "window.position: trying to reposition"
        if y == None:
            raise Exception("Must call with no args, or x,y")
        #print "window.position: about to call flwm_.setPos"
        flwm_.setPos(self.hWin, x, y)
        #print "window.position: returned from flwm_.setPos"



</t>
<t tx="davidmcnab.041604122248.48">def getPos(hWin):
    """
    Return the position of the given window (handle) as
    an x, y tuple
    """
    cdef long cWin
    cdef int x
    cdef int y

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.getPos: calling flwm_getPos"
    flwm_getPos(cWin, &amp;x, &amp;y)
    #print "flwm_.getPos: returned from flwm_getPos"

    return x, y



</t>
<t tx="davidmcnab.041604122248.49">extern "C" void flwm_getPos(Frame *frm, int *x, int *y)
{
  //printf("flwm_getPos: start\n");
  *x = frm-&gt;x();
  *y = frm-&gt;y();
  //printf("flwm_getPos: done\n");
}
</t>
<t tx="davidmcnab.041604122248.50"></t>
<t tx="davidmcnab.041604122248.51">def size(self, w=None, h=None):
    """
    Gets or sets the window size
    
    Call with no arguments to fetch the position as a tuple
    Call with x,y to set the window position
    """
    #print "window.size: bailing"
    #return 0, 0
    if w == None:
        #print "window.size: about to call flwm_.getSize"
        x, y = flwm_.getSize(self.hWin)
        #print "window.size: returned from flwm_.getSize"
        return x, y
    else:
        #print "window.size: setting size"
        if h == None:
            raise Exception("Must call with no args, or w,h")
        #print "window.size: about to call flwm_.setSize"
        flwm_.setSize(self.hWin, w, h)
        #print "window.size: returned from flwm_.setSize"

</t>
<t tx="davidmcnab.041604122248.52">def getSize(hWin):
    """
    Return the size of the given window (arg window handle)
    as an x, y tuple
    """
    cdef long cWin
    cdef int x
    cdef int y

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.getSize: calling flwm_getSize"
    flwm_getSize(cWin, &amp;x, &amp;y)
    #print "flwm_.getSize: returned from flwm_getSize"

    return x, y


</t>
<t tx="davidmcnab.041604122248.53">extern "C" void flwm_getSize(Frame *frm, int *w, int *h)
{
  *w = frm-&gt;w();
  *h = frm-&gt;h();
}
</t>
<t tx="davidmcnab.041604122248.54"></t>
<t tx="davidmcnab.041604122248.55">def setPos(hWin, x, y):
    """
    Set the position of the given window (handle) to x, y
    """
    cdef long cWin
    cdef long cX
    cdef long cY

    cWin = PyLong_AsLong(hWin)
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)

    #print "flwm_.setPos: calling flwm_setPos"
    flwm_setPos(cWin, cX, cY)
    #print "flwm_.setPos: returned from flwm_setPos"

</t>
<t tx="davidmcnab.041604122248.56">extern "C" void flwm_setPos(Frame *frm, long x, long y)
{
  //printf("flwm_setPos: x=%d, y=%d\n", x, y);
  frm-&gt;set_size(x, y, frm-&gt;w(), frm-&gt;h(), 0, 1);
  //printf("flwm_setPos: done\n");
}
</t>
<t tx="davidmcnab.041604122248.57"></t>
<t tx="davidmcnab.041604122248.58">def setSize(hWin, w, h):
    """
    Resize the given window to x y
    """
    # declare explicitly C variables
    cdef long cWin
    cdef long cW
    cdef long cH

    # perform manual conversions
    cWin = PyLong_AsLong(hWin)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)

    #print "flwm_.setSize: calling flwm_setSize"
    flwm_setSize(cWin, cW, cH)
    #print "flwm_.setSize: returned from flwm_setSize"
</t>
<t tx="davidmcnab.041604122248.59">extern "C" void flwm_setSize(Frame *frm, long w, long h)
{
  //printf("flwm_setSize: w=%d, h=%d\n", w, h);
  frm-&gt;set_size(frm-&gt;x(), frm-&gt;y(), w, h, 0, 1);
  //printf("flwm_setSize: done\n");
}
</t>
<t tx="davidmcnab.041604122248.60"></t>
<t tx="davidmcnab.041604122248.61">def close(self):
    """
    Closes the window
    """    
    #print "window.close: trying to close window"
    flwm_.closeWindow(self.hWin)
    #print "window.close: returned"

</t>
<t tx="davidmcnab.041604122248.62">def closeWindow(hWin):
    """
    Close the current window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.closeWindow: calling flwm_closeWindow"
    flwm_closeWindow(cWin)
    #print "flwm_.closeWindow: returned from flwm_closeWindow"
</t>
<t tx="davidmcnab.041604122248.63">extern "C" void flwm_closeWindow(Frame *frm)
{
  //printf("flwm_closeWindow: trying to close\n");
  frm-&gt;close();
}
</t>
<t tx="davidmcnab.041604122248.64"></t>
<t tx="davidmcnab.041604122248.65">@first #!/usr/bin/env python
@language python

"""
example3.py

Same as example2, but demonstrates creation keywords
"""

import pywm

class myWindowClass(pywm.window):
    """
    These window classes get instantiated by the PYWM engine.
    You should never instantiate this class yourself.
    """
    def __init__(self, hWin, wm, **kwds):
        #print "myWindowClass.__init__: creating a window"
        pywm.window.__init__(self, hWin, wm, **kwds)
        print "myWindowClass.__init__: window %s created" % self.name


class myWindowManagerClass(pywm.WM):
    """
    Our custom window manager class
    """
    def __init__(self):
        pywm.WM.__init__(
            self,
            windowclass=myWindowClass,
            # display='localhost:0.0',
            # visual=0 # try different numbers here - ref FLWM doco
            # geometry=WxH+X+Y, # constrain windows to this area
            # maximum=WxH # max size of maximised windows
            fg="#ffcc00", # window decoration foreground 
            bg="#000000", # window decoration background
            bg2="#00FF00", # text colour
            abg="#900000", # colour of active window bar
            cfg="#0000FF", # Cursor foreground color
            cbg="#FFFFFF", # Cursor outline color,
            # cursor=0, # Cursor number for root window
            exit=1, # change 'logout' menu prompt to 'exit'
            )

    def on_startup(self):
        """
        If you define an 'on_startup' method in your class, this
        method will get invoked just before the eindow manager
        engine enters its event loop. Note, however, that it
        gets called *after* the existing windows are discovered
        and the corresponding on_create callbacks fired.
        """
        print "myWindowManager: on_startup"

        # bind Shift-Alt-A to run self.launch with arg 'xterm'
        self.bindKey(self.launch, "xterm",
                     'a', 1, 0, 1, 0)

        # bind Shift-Alt-Meta-A to run vi
        self.bindKey(self.launch, "xterm -e vi",
                     'a', 1, 0, 1, 1)

        # bind Shift-Alt-Meta-Insert to run emacs in terminal
        self.bindKey(self.launch, "xterm -e emacs -nw",
                     'insert', 1, 0, 1, 1)
        print "myWindowManager: key binding done"
    

def run():
    # create a window manager object using our class
    windowManager = myWindowManagerClass()

    # and launch the window manager
    windowManager.run()

if __name__ == '__main__':
    run()

</t>
<t tx="davidmcnab.041604122248.66">def bindKey(self, func, arg, key, shift, control, alt, meta):
    """
    Allows you to bind a Ctrl-Alt key combo to a function

    Arguments:
     - func - function to call when key gets pressed
     - arg - an argument to pass to the function. Can be a number,
       string, list, tuple, dict or anything you like.
     - key - key to bind - either:
         - a single character
         - one of 'f1'..'f12'
         - one of 'kp0'..'kp9', or 'kpenter'
         - one of 'enter', 'tab', 'backspace', 'intert', 'delete', 'home',
           'end', 'pageup', 'pagedown', 'up', 'down', 'left', 'right'
     - shift - whether shift key is added - 0 or 1
     - control - whether control key is added - 0 or 1
     - alt - whether alt key is added - 0 or 1
     - meta - whether meta key is added - 0 or 1
    
    When the key combination gets pressed, the function you give
    will get called with the argument you give.

    If you find it hard to remember the 'shift'/'control'/'alt'/'meta' order,
    just think 'history' - the Shift key was the first to be added (in
    typewriters), then Ctrl (with ASCII), then Alt (with the IBM PC), then
    Meta (contributed by Microsoft with Windows).
    """
    #print "WM.bindKey: entered"
    keycode = flwm_.keyCode(key, shift, control, alt, meta)
    if keycode == 0:
        print "WM.bindKey: invalid key name '%s'" % key
        return
    #print "WM.bindKey: numeric key code is 0x%lx" % keycode
    self._keyBindings[keycode] = func
    self._keyBindingsArg[keycode] = arg
    #print "WM.bindKey: added binding"
    flwm_.bindKey(keycode)
    #print "WM.bindKey: returned from flwm_bind_key"
    #print self._keyBindings.keys()

</t>
<t tx="davidmcnab.041604122248.67">def keyCode(keystr, shift, control, alt, meta):
    """
    Determines the keycode number for a given key sequence
    
    Arguments:
     - as for WM.bindKey, without the first 'func' arg
    """
    cdef char *cKeystr
    cdef int cShift
    cdef int cControl
    cdef int cAlt
    cdef int cMeta
    cdef int cRes

    cKeystr = PyString_AsString(keystr)
    cShift = &lt;int&gt;PyLong_AsLong(shift)
    cControl = &lt;int&gt;PyLong_AsLong(control)
    cAlt = &lt;int&gt;PyLong_AsLong(alt)
    cMeta = &lt;int&gt;PyLong_AsLong(meta)
    cRes = flwm_keyCode(cKeystr, cShift, cControl, cAlt, cMeta)
    res = PyLong_FromLong(&lt;long&gt;cRes)
    return res
</t>
<t tx="davidmcnab.041604122248.68">
struct flwm_keyTab
{
  char *name;
  long val;
}
flwm_keyNames[] =
{
    { "tab", FL_Tab },
    { "enter", FL_Enter },
    { "escape", FL_Escape },
    { "insert", FL_Insert },
    { "delete", FL_Delete },
    { "home", FL_Home },
    { "end", FL_End },
    { "pageup", FL_Page_Up },
    { "pagedown", FL_Page_Down },
    { "up", FL_Up },
    { "down", FL_Down },
    { "left", FL_Left },
    { "right", FL_Right },
    { "kp0", FL_KP },
    { "kp1", FL_KP+1 },
    { "kp2", FL_KP+2 },
    { "kp3", FL_KP+3 },
    { "kp4", FL_KP+4 },
    { "kp5", FL_KP+5 },
    { "kp6", FL_KP+6 },
    { "kp7", FL_KP+7 },
    { "kp8", FL_KP+8 },
    { "kp9", FL_KP+9 },
    { "kpenter", FL_KP_Enter },
    { (char *)0, 0 }
};


extern "C" long flwm_keyCode(char *keystr,
                             int shift, int ctrl, int alt, int meta)
{
    long keycode = 0;

    if (strlen(keystr) == 1)
      // literal key character
      keycode = (long)keystr[0];
    else if (strlen(keystr) == 2 &amp;&amp; tolower(keystr[0]) == 'f')
    {
      // possible F key
      int fKey = atoi(&amp;keystr[1]);
      
      if (fKey &gt;= 1 &amp;&amp; fKey &lt;= 12)
         keycode = FL_F + fKey;
    }
    else
    {
       int i;
       for (i = 0; flwm_keyNames[i].name; i++)
          if (!strcasecmp(keystr, flwm_keyNames[i].name))
          {
             keycode = flwm_keyNames[i].val;
             break;
          }
       if (keycode == 0)
          return 0;
    }

    // add shift/ctrl/alt/meta modifiers
    if (shift)
      keycode += FL_SHIFT;
    if (ctrl)
      keycode += FL_CTRL;
    if (alt)
      keycode += FL_ALT;
    if (meta)
      keycode += FL_META;

    return keycode;
}

</t>
<t tx="davidmcnab.041604122248.69">def bindKey(keynum):
    """
    Tells the FLWM engine to watch out for a certain key.combination
    
    When such key combination is pressed, the window manager object's
    on_keyEvent callback will fire
    """
    cdef long cKeyNum

    #print "flwm_.bindKey: entered"
    cKeyNum = PyLong_AsLong(keynum)
    #print "flwm_.bindKey: calling flwm_bind_key key=%x" % keynum
    flwm_bindKey(cKeyNum)
    #print "flwm_.bindKey: returned from flwm_bind_key"

</t>
<t tx="davidmcnab.041604122248.70">// flwm_bindKey - tell FLWM engine to watch out for a key

extern "C" void flwm_bindKey(long key)
{
    //printf("flwm_bindKey: want to bind key 0x%lx\n", key);
    Hotkeys_bindKey(key);
}


</t>
<t tx="davidmcnab.041604122248.71">
void Hotkeys_bindKey(long key)
{
  Window root = fl_xid(Root);

  int keycode = XKeysymToKeycode(fl_display, key &amp; 0xFFFF);
  if (!keycode)
     return;
 
  // Silly X!  we need to ignore caps lock &amp; numlock keys by grabbing
  // all the combinations:
  XGrabKey(fl_display, keycode, key &gt;&gt;16, root, 0, 1, 1);
  //printf("Hotkeys:bindKey:ok - key=%x, keycode=%x\n", key, keycode);
}

</t>
<t tx="davidmcnab.041604122248.72"></t>
<t tx="davidmcnab.041604122248.73"></t>
<t tx="davidmcnab.041604122248.74">class Fl_Window:
    """
    This class allows you to create popup windows for user
    interaction.
    
    The windows are created/managed by the FLTK graphical toolkit
    (which the FLWM engine uses), and are not managed as application
    windows (meaning - no border, no window handle etc).
    
    The python interface to Fl_Window is a close subset of the
    FLTK Fl_Window class (refer to your FLTK manual - http://fltk.sf.net
    if you don't have it locally).
    """
    def __init__(self, x, y, w, h, label=""):
        """
        Creates a new window manager popup window.
        
        Arguments:
         - x, y, w, h - x-position, y-position, width and height
         - label - probably no point to this since there's no titlebar
        """
        print "Fl_Window: entered"
        on_enter = self.on_enter
        on_click = self.on_click
        print "about to create fl window"
        self.wid = flwm_.Fl_Window_create(x, y, w, h, label,
                                          self, on_enter, on_click)

    def on_enter(self, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept 2 args, x and y,
        which will be the position of the mouse on entry.
        """
        print "Fl_Window.on_enter: mouse at %d,%d" % (x, y)

    def on_click(self, but, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept three args,
        but, x and y, which will be the button number, and
        the position of the mouse on entry.
        """
        print "Fl_Window.on_click: button %d, mouse at %d,%d" % (but, x, y)

    def end(self, arg=None):
        """
        End a window's definition phase. Call this after all widgets
        have been added to the window
        """
        flwm_.Fl_Window_end(self.wid)

    def show(self, arg=None):
        """
        Make the window visible
        """
        flwm_.Fl_Window_show(self.wid)

    def hide(self, arg=None):
        """
        Hide the window
        """
        
        #print "Fl_Window_hide??"
        flwm_.Fl_Window_hide(self.wid)

    def move(self, x, y):
        """
        Move the window to x, y
        """
        flwm_.Fl_Window_move(self.wid, x, y)

    def stayOnTop(self):
        """
        Bring the window to the top where it will hopefully stay.
        """
        flwm_.Fl_Window_stayOnTop(self.wid)


</t>
<t tx="davidmcnab.041604122248.75"># Import the C shims for FLTK funcs

cdef extern long fltk_window_create(int x, int y, int w, int h, char *label,
                                    object self, object onenter, object onclick)
cdef extern void fltk_window_destroy(long pWin)
cdef extern void fltk_window_end(long pWin)
cdef extern void fltk_window_show(long pWin)
cdef extern void fltk_window_hide(long pWin)
cdef extern void fltk_window_move(long pWin, long x, long y)
cdef extern void fltk_window_stayOnTop(long pWin)

cdef extern long fltk_button_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_button_destroy(long pWin)
cdef extern void fltk_button_show(long pWin)
cdef extern void fltk_button_hide(long pWin)
cdef extern void fltk_button_callback(long pWin, object func)

cdef extern long fltk_select_browser_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_select_browser_destroy(long pWin)
cdef extern void fltk_select_browser_show(long pWin)
cdef extern void fltk_select_browser_hide(long pWin)
cdef extern void fltk_select_browser_callback(long pWin, object func)

</t>
<t tx="davidmcnab.041604122248.76"># funcs for working with Fl_Window

def Fl_Window_create(x, y, w, h, label, self, onenter, onclick):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid

    print "Fl_Window_create: entered"

    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
    cLabel = PyString_AsString(label)

    cWid = fltk_window_create(cX, cY, cW, cH, cLabel, self, onenter, onclick)
    #printf("Fl_Window_create: cWid=0x%lx\n", cWid)
    wid = PyLong_FromLong(cWid)
    #print "Fl_Window_create: self.cWid=0x%lx" % wid
    return wid

def Fl_Window_end(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_end: cWid=0x%lx\n" % cWid
    fltk_window_end(cWid)

def Fl_Window_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_show: cWid=0x%lx\n" % cWid
    fltk_window_show(cWid)

def Fl_Window_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_hide(cWid)

def Fl_Window_move(wid, x, y):
    cdef long cWid
    cdef long cX, cY
    #print "Fl_Window_move"
    cWid = PyLong_AsLong(wid)
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_move(cWid, cX, cY)

def Fl_Window_stayOnTop(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_stayOnTop cWid=0x%lx\n" % cWid
    fltk_window_stayOnTop(cWid)
</t>
<t tx="davidmcnab.041604122248.77">def Fl_Button_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_button_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Button_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_button_show(cWid)

def Fl_Button_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_button_hide(cWid)

def Fl_Button_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Button: callback=0x%lx" % &lt;long&gt;func
    fltk_button_callback(cWid, func)

</t>
<t tx="davidmcnab.041604122248.78">def Fl_Select_Browser_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_select_browser_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Select_Browser_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_select_browser_show(cWid)

def Fl_Select_Browser_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_select_browser_hide(cWid)

def Fl_Select_Browser_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Select_Browser: callback=0x%lx" % &lt;long&gt;func
    fltk_select_browser_callback(cWid, func)

</t>
<t tx="davidmcnab.041604122248.79"></t>
<t tx="davidmcnab.041604122248.80">//
// generic callback dispatcher
//
// when it receives FLTK callbacks, it invokes the
// corresponding Python callback

static void dispatchCallbackToPython(Fl_Widget *widget, void *arg)
{
   //printf("dispatchCallbackToPython: widget=0x%lx, func=0x%lx\n", widget, arg);
   PyObject_CallObject((PyObject *)arg, NULL);
   //printf("dispatchCallbackToPython: done?\n");
}

</t>
<t tx="davidmcnab.041604122248.81">class my_Fl_Window : public Fl_Window
{
public:
  my_Fl_Window(int x, int y, int w, int h, char *label,
               PyObject *pyself,
               PyObject *pyOnEnter,
               PyObject *pyOnClick
               );
  ~my_Fl_Window();
  
  int handle(int);
  
  PyObject *pySelf;
  PyObject *pyOnEnter;
  PyObject *pyOnClick;
   
};

my_Fl_Window::my_Fl_Window(int x, int y, int w, int h,
                           char *label,
                           PyObject *pyself,
                           PyObject *pyonenter,
                           PyObject *pyonclick) :
  Fl_Window(x, y, w, h, label)
{
  pySelf = pyself; Py_INCREF(pyself);
  pyOnEnter = pyonenter; Py_INCREF(pyonenter);
  pyOnClick = pyonclick; Py_INCREF(pyonclick);
}

my_Fl_Window::~my_Fl_Window()
{
}

int my_Fl_Window::handle(int e)
{
  int x, y;

  switch (e)
  {

  case FL_SHOW:
  case FL_HIDE:
    return 0; // prevent fltk from messing things up

  case FL_ENTER:
    //printf("Mouse has entered\n");
    Fl::get_mouse(x, y);
    PyObject_CallObject(pyOnEnter,
                        Py_BuildValue("ii", x, y));
    Fl_Window::handle(e);
    
    return 1;

  case FL_PUSH:
    //printf("Mouse click\n");
    Fl::get_mouse(x, y);
    PyObject_CallObject(pyOnClick,
                        Py_BuildValue("iii", Fl::event_button(), x, y));
    Fl_Window::handle(e);
    return 1;

  default:
    return Fl_Window::handle(e);
  }
  return 0;
}


extern "C" long fltk_window_create(int x, int y, int w, int h, char *label,
                                   PyObject *self,
                                   PyObject *onenter,
                                   PyObject *onclick)
{
  printf("fltk_window_create: entered\n");
  my_Fl_Window *win = new my_Fl_Window(x, y, w, h, label,
                                       self, onenter, onclick);
  //printf("fltk_window_create: window=0x%lx\n", win);
  return (long)win;
}

extern "C" void fltk_window_destroy(long pWin)
{
    delete ((my_Fl_Window *)pWin);
}

extern "C" void fltk_window_end(long pWin)
{
    //printf("fltk_window_end: window=0x%lx\n", pWin);
    ((my_Fl_Window *)pWin)-&gt;end();
}

extern "C" void fltk_window_show(long pWin)
{
    ((my_Fl_Window *)pWin)-&gt;show();
    Fl::check();
}

extern "C" void fltk_window_hide(long pWin)
{
    //printf("fltk_window_hide: pWin=0x%lx\n", pWin);
    ((my_Fl_Window *)pWin)-&gt;hide();
    //printf("fltk_window_hide: done\n");
}

extern "C" void fltk_window_activate(long pWin)
{
    ((my_Fl_Window *)pWin)-&gt;activate();
    XSetInputFocus(fl_display, PointerRoot, RevertToPointerRoot,
		     fl_event_time);
    Fl::check();
}

extern "C" void fltk_window_set_modal(long pWin)
{
    ((my_Fl_Window *)pWin)-&gt;set_modal();
    Fl::check();
}

extern "C" void fltk_window_move(long pWin, long x, long y)
{
    //printf("fltk_window_move: pWin=0x%lx\n", pWin);
    ((my_Fl_Window *)pWin)-&gt;position(x, y);
    //printf("fltk_window_move: done\n");
}

extern "C" void fltk_window_stayOnTop(long pWin)
{
    //printf("fltk_window_stayOnTop: pWin=0x%lx\n", pWin);
    ((my_Fl_Window *)pWin)-&gt;set_non_modal();
    //printf("fltk_window_stayOnTop: done\n");
    Fl::check();
}
</t>
<t tx="davidmcnab.041604122248.82">extern "C" long fltk_button_create(int x, int y, int w, int h, char *label)
{
    return (long)(new Fl_Button(x, y, w, h, label));
}

extern "C" void fltk_button_destroy(long pBut)
{
    delete ((Fl_Button *)pBut);
}

extern "C" void fltk_button_show(long pBut)
{
    ((Fl_Button *)pBut)-&gt;show();
}

extern "C" void fltk_button_hide(long pBut)
{
    ((Fl_Button *)pBut)-&gt;hide();
}

extern "C" void fltk_button_callback(long pBut, long arg)
{
    Py_INCREF((PyObject *)arg);
    //printf("fltk_button_callback: pBut=0x%lx, arg=0x%lx\n", pBut, arg);
    ((Fl_Button *)pBut)-&gt;callback(
        dispatchCallbackToPython, (void *)arg);
}

extern "C" void fltk_button_symbollabel(long pBut)
{
    ((Fl_Button *)pBut)-&gt;labeltype(FL_SYMBOL_LABEL);
}

</t>
<t tx="davidmcnab.041604122248.83">extern "C" long fltk_repeat_button_create(int x, int y, int w, int h, char *label)
{
    return (long)(new Fl_Repeat_Button(x, y, w, h, label));
}

extern "C" void fltk_repeat_button_destroy(long pBut)
{
    delete ((Fl_Repeat_Button *)pBut);
}

extern "C" void fltk_repeat_button_show(long pBut)
{
    ((Fl_Repeat_Button *)pBut)-&gt;show();
}

extern "C" void fltk_repeat_button_hide(long pBut)
{
    ((Fl_Repeat_Button *)pBut)-&gt;hide();
}

extern "C" void fltk_repeat_button_callback(long pBut, long arg)
{
    Py_INCREF((PyObject *)arg);
    //printf("fltk_button_callback: pBut=0x%lx, arg=0x%lx\n", pBut, arg);
    ((Fl_Repeat_Button *)pBut)-&gt;callback(
        dispatchCallbackToPython, (void *)arg);
}

extern "C" void fltk_repeat_button_symbollabel(long pBut)
{
    ((Fl_Repeat_Button *)pBut)-&gt;labeltype(FL_SYMBOL_LABEL);
}

</t>
<t tx="davidmcnab.041604122248.84">extern "C" long fltk_select_browser_create(int x, int y, int w, int h, char *label)
{
    return (long)(new Fl_Select_Browser(x, y, w, h, label));
}

extern "C" void fltk_select_browser_destroy(long pBut)
{
    delete ((Fl_Select_Browser *)pBut);
}

extern "C" void fltk_select_browser_show(long pBut)
{
    ((Fl_Select_Browser *)pBut)-&gt;show();
}

extern "C" void fltk_select_browser_hide(long pBut)
{
    ((Fl_Select_Browser *)pBut)-&gt;hide();
}

extern "C" void fltk_select_browser_callback(long pBut, long arg)
{
    Py_INCREF((PyObject *)arg);
    //printf("fltk_select_browser_callback: pBut=0x%lx, arg=0x%lx\n", pBut, arg);
    ((Fl_Select_Browser *)pBut)-&gt;callback(
        dispatchCallbackToPython, (void *)arg);
}

extern "C" void fltk_select_browser_add(long pBut, char *item)
{
    ((Fl_Select_Browser *)pBut)-&gt;add(item);
}

extern "C" void fltk_select_browser_remove(long pBut, int item)
{
    ((Fl_Select_Browser *)pBut)-&gt;remove(item);
}

extern "C" void fltk_select_browser_clear(long pBut)
{
    ((Fl_Select_Browser *)pBut)-&gt;clear();
}

extern "C" void fltk_select_browser_color(long pBut, int color)
{
    //printf("fltk_Select_browser_color: col=%06lx\n", color);
    ((Fl_Select_Browser *)pBut)-&gt;color(color);
}

extern "C" void fltk_select_browser_textcolor(long pBut, int color)
{
    //printf("fltk_select_browser_textcolor: col=%06lx\n", color);
    ((Fl_Select_Browser *)pBut)-&gt;textcolor(color);
}

extern "C" void fltk_select_browser_selectioncolor(long pBut, int color)
{
    //printf("fltk_Select_browser_selectioncolor: col=%06lx\n", color);
    ((Fl_Select_Browser *)pBut)-&gt;selection_color(color);
}

extern "C" int fltk_select_browser_value(long pLst, int val)
{
    if (val == -2)
        return ((Fl_Select_Browser *)pLst)-&gt;value();
    else
    {
        ((Fl_Select_Browser *)pLst)-&gt;value(val);
        return 0;
    }
}
</t>
<t tx="davidmcnab.041604122248.85">extern "C" long fltk_hold_browser_create(int x, int y, int w, int h, char *label)
{
    return (long)(new Fl_Hold_Browser(x, y, w, h, label));
}

extern "C" void fltk_hold_browser_destroy(long pBut)
{
    delete ((Fl_Hold_Browser *)pBut);
}

extern "C" void fltk_hold_browser_show(long pBut)
{
    ((Fl_Hold_Browser *)pBut)-&gt;show();
}

extern "C" void fltk_hold_browser_hide(long pBut)
{
    ((Fl_Hold_Browser *)pBut)-&gt;hide();
}

extern "C" void fltk_hold_browser_callback(long pBut, long arg)
{
    Py_INCREF((PyObject *)arg);
    //printf("fltk_select_browser_callback: pBut=0x%lx, arg=0x%lx\n", pBut, arg);
    ((Fl_Hold_Browser *)pBut)-&gt;callback(
        dispatchCallbackToPython, (void *)arg);
}

extern "C" void fltk_hold_browser_add(long pBut, char *item)
{
    ((Fl_Hold_Browser *)pBut)-&gt;add(item);
}

extern "C" void fltk_hold_browser_remove(long pBut, int item)
{
    ((Fl_Hold_Browser *)pBut)-&gt;remove(item);
}

extern "C" void fltk_hold_browser_clear(long pBut)
{
    ((Fl_Hold_Browser *)pBut)-&gt;clear();
}

extern "C" void fltk_hold_browser_color(long pBut, int color)
{
    //printf("fltk_hold_browser_color: col=%06lx\n", color);
    ((Fl_Hold_Browser *)pBut)-&gt;color(color);
}

extern "C" void fltk_hold_browser_textcolor(long pBut, int color)
{
    //printf("fltk_hold_browser_textcolor: col=%06lx\n", color);
    ((Fl_Hold_Browser *)pBut)-&gt;textcolor(color);
}

extern "C" void fltk_hold_browser_selectioncolor(long pBut, int color)
{
    //printf("fltk_hold_browser_selectioncolor: col=%06lx\n", color);
    ((Fl_Hold_Browser *)pBut)-&gt;selection_color(color);
}

extern "C" int fltk_hold_browser_value(long pLst, int val)
{
    if (val == -2)
        return ((Fl_Hold_Browser *)pLst)-&gt;value();
    else
    {
        ((Fl_Hold_Browser *)pLst)-&gt;value(val);
        return 0;
    }
}
</t>
<t tx="davidmcnab.041604122248.86">extern "C" long fltk_input_create(int x, int y, int w, int h, char *label)
{
    Fl_Input *fld = new Fl_Input(x, y, w, h, label);
    fld-&gt;when(FL_WHEN_ENTER_KEY|FL_WHEN_NOT_CHANGED);
    fld-&gt;take_focus();
    return (long)fld;
}

extern "C" void fltk_input_callback(long pFld, long arg)
{
    Py_INCREF((PyObject *)arg);
    //printf("fltk_input_callback: pBut=0x%lx, arg=0x%lx\n", pBut, arg);
    ((Fl_Input *)pFld)-&gt;callback(
        dispatchCallbackToPython, (void *)arg);
}

extern "C" void fltk_input_color(long pFld, int color)
{
    //printf("fltk_input_color: col=%06lx\n", color);
    ((Fl_Input *)pFld)-&gt;color(color);
}

extern "C" void fltk_input_textcolor(long pFld, int color)
{
    //printf("fltk_input_textcolor: col=%06lx\n", color);
    ((Fl_Input *)pFld)-&gt;textcolor(color);
}

extern "C" void fltk_input_selectioncolor(long pFld, int color)
{
    //printf("fltk_input_selectioncolor: col=%06lx\n", color);
    ((Fl_Input *)pFld)-&gt;selection_color(color);
}

extern "C" char *fltk_input_value(long pFld, char *val)
{
    //printf("fltk_input_value: val=0x%lx\n", val);
    if (val != NULL)
        ((Fl_Input *)pFld)-&gt;value(val);
    return (char *)(((Fl_Input_ *)pFld)-&gt;value());
}

extern "C" void fltk_input_take_focus(long pFld)
{
    //printf("fltk_input_selectioncolor: col=%06lx\n", color);
    ((Fl_Input *)pFld)-&gt;take_focus();
}

</t>
<t tx="davidmcnab.041604122248.87">extern "C" long fltk_color(int red, int green, int blue)
{
    long col = (long)fl_color_cube(red * FL_NUM_RED/256,
                               green * FL_NUM_GREEN/256,
                               blue * FL_NUM_BLUE/256);
    //printf("flwmapi.fltk_color: %x %x %x -&gt; %x\n",
    //       red, green, blue, col);
    return col;
}
</t>
<t tx="davidmcnab.041604122248.88"></t>
<t tx="davidmcnab.041604122248.89"></t>
<t tx="davidmcnab.041604122248.90">@first #!/usr/bin/env python
@language python

"""
pywm.py - Launcher utility for PYWM window manager applications.

Presents a menu offering a choice of window managers, and launches
the selected WM (or terminates).

Uses the environment variable PYWMDIR (default ~/.pywm) as the
location of user PYWM scripts to choose from.
"""

import sys, os, os.path, commands
from Tkinter import *

from pdb import set_trace as trace

class wmSelector:
    """
    Constructs and operates the window for WM script selection
    """
    scriptfiles = {}
    scriptnames = []
    
    def __init__(self):
        self.pywmDir = os.getenv("PYWMDIR")
        if not self.pywmDir:
            self.pywmDir = os.path.join(os.path.expanduser("~"), ".pywm")

        self.root = root = Tk()

        frm = self.frm = Frame(root)
        frm.pack(fill=BOTH, expand=1)
        
        self.scrW = root.winfo_screenwidth()
        self.scrH = root.winfo_screenheight()
        
        banner = Label(frm,
                       text="PYWM Selection Menu",
                       font="helvetica 16 bold")
        banner.pack(side=TOP, fill=X, expand=1)
                       
        heading = Label(frm, text="Please select a window manager")
        heading.pack(side=TOP, fill=X, expand=1)

        self.list = Listbox(frm, bg="white")
        self.list.pack(side=TOP, fill=BOTH, expand=1)
        
        buts = self.buts = Frame(frm)
        self.buts.pack(side=TOP, fill=X, expand=1)
        
        self.butOk = Button(buts,
                            text="OK",
                            width=10,
                            default=ACTIVE,
                            command=self.on_butOK)
        self.butOk.pack(side=RIGHT)
        
        self.butQuit = Button(buts,
                              text="Quit",
                              width=10,
                              command=self.on_butQuit)
        self.butQuit.pack(side=LEFT)

        # create user pywm dir if it doesn't yet exist
        if not os.path.isdir(self.pywmDir):
            self.createPywmDir()

        # hopefully, now there is a readable valid pywmDir
        self.readScripts()
        
    def readScripts(self):
        self.list.delete(0, END)
        files = os.listdir(self.pywmDir)
        for f in files:
            #print "f=%s" % f
            f1 = os.path.realpath(os.path.join(self.pywmDir, f))
            name, ext = os.path.splitext(f)
            #print "x?: f1=%s name=%s ext=%s" % (f1, name, ext)
            if os.path.isdir(f1):
                continue
            if ext in [".py", ".pyc", ".pyo"]:
                self.scriptnames.append(name)
                self.scriptfiles[name] = "python %s" % f1
                self.list.insert(END, name)
            elif ext == '':
                self.scriptnames.append(name)
                self.scriptfiles[name] = f1
                self.list.insert(END, name)

    def createPywmDir(self):
        """
        If a .pywm directory doesn't exist in user's home directory, create one
        and populate it with an example file and a README.
        """
        os.mkdir(self.pywmDir)
        import pywm.examples.example1 as example1
        ex1file = example1.__file__
        os.system("ln -s \"%s\" \"%s/%s\"" % (
             ex1file, self.pywmDir, os.path.split(ex1file)[1]))
        os.system("ln -s `which xterm` \"%s/X-Term\"" % self.pywmDir)
        #print "example1 file=", ex1file
        fd = file("%s/README.pywmdir" % self.pywmDir, "w")
        fd.write("""This directory contains the options for your PyWM launcher program.

Any files you place (or symlink) here bearing the extensions
'.py', '.pyc', or '.pyo' will be launched with the python interpreter.

Any files you place or symlink here with no extensions will be launched
with your default system shell.

Any files with extensions other than the above will be ignored.
""")
        fd.close()

        self.root.withdraw()
        self.top = Toplevel(self.root)
        self.top.title("PYWM Launcher Setup")
        frame = Frame(self.top)
        frame.pack(fill=BOTH, expand=1)
        Label(frame,
              wraplength=300,
              text="First time running PyWM launcher.\n\n"
                   +"Creating PyWM launcher directory:\n"
                   +"  "+self.pywmDir+"\n\n"
                   +"Refer to the README file in that directory for more information."
                   ).pack(fill=X, expand=1)
        Button(frame, text="OK", command=self.on_butOK_firstrun).pack(side=BOTTOM)

        
    def on_butOK_firstrun(self):
        self.root.deiconify()
        self.top.destroy()

    def on_butOK(self, event=None):
        sels = self.list.curselection()
        #print "ok: sels=", sels
        if len(sels) == 0:
            return
        #trace()
        selidx = int(sels[0])
        sel = self.scriptfiles[self.scriptnames[selidx]]
        #print "you selected file %s" % sel
        self.root.withdraw()
        print "want to run: %s" % sel

        #os.system(sel)
        logtext = commands.getoutput(sel)
        fd = file(os.path.join(self.pywmDir, "session.log"), "w")
        fd.write(logtext)
        fd.close()

        self.root.deiconify()
        self.root.tkraise()
    
    def on_butQuit(self, event=None):
        self.root.destroy()
        sys.exit(0)
        
    def run(self):
        g = self.root.geometry()
        #print "root geomeetry=%s" % g
        #print self.frm['width'], self.frm['height']
        #print "frm size is %dx%d" % (
        #   int(self.frm['width']),
        #   int(self.frm['height'])
        #   )
        w = 300
        h = 300
        x = (self.scrW - w) / 2
        y = (self.scrH - h) / 2
        #g = "%dx%d+%d+%d" % (w, h, x, y)
        #print "setting window geometry=%s" % g
        #self.root.geometry(g)
        self.root.geometry("+%d+%d" % (x, y))
        self.root.deiconify()
        self.root.tkraise()
        self.root.mainloop()

if __name__ == '__main__':
    wmSelector().run()



</t>
<t tx="davidmcnab.041604122248.91">@language python
"""
fltk.py - a subset of FLTK exposed to Python

"""
@others
</t>
<t tx="davidmcnab.041604122248.92">import fltk_ as flwm_

</t>
<t tx="davidmcnab.041604122248.93">class Fl_Window:
    """
    This class allows you to create popup windows for user
    interaction.
    
    The windows are created/managed by the FLTK graphical toolkit
    (which the FLWM engine uses), and are not managed as application
    windows (meaning - no border, no window handle etc).
    
    The python interface to Fl_Window is a close subset of the
    FLTK Fl_Window class (refer to your FLTK manual - http://fltk.sf.net
    if you don't have it locally).
    """
    def __init__(self, x, y, w, h, label=""):
        """
        Creates a new window manager popup window.
        
        Arguments:
         - x, y, w, h - x-position, y-position, width and height
         - label - probably no point to this since there's no titlebar
        """
        print "Fl_Window: entered"
        on_enter = self.on_enter
        on_click = self.on_click
        print "about to create fl window"
        self.wid = flwm_.Fl_Window_create(x, y, w, h, label,
                                          self, on_enter, on_click)

    def on_enter(self, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept 2 args, x and y,
        which will be the position of the mouse on entry.
        """
        print "Fl_Window.on_enter: mouse at %d,%d" % (x, y)

    def on_click(self, but, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept three args,
        but, x and y, which will be the button number, and
        the position of the mouse on entry.
        """
        print "Fl_Window.on_click: button %d, mouse at %d,%d" % (but, x, y)

    def end(self, arg=None):
        """
        End a window's definition phase. Call this after all widgets
        have been added to the window
        """
        flwm_.Fl_Window_end(self.wid)

    def show(self, arg=None):
        """
        Make the window visible
        """
        flwm_.Fl_Window_show(self.wid)

    def hide(self, arg=None):
        """
        Hide the window
        """
        
        #print "Fl_Window_hide??"
        flwm_.Fl_Window_hide(self.wid)

    def move(self, x, y):
        """
        Move the window to x, y
        """
        flwm_.Fl_Window_move(self.wid, x, y)

    def stayOnTop(self):
        """
        Bring the window to the top where it will hopefully stay.
        """
        flwm_.Fl_Window_stayOnTop(self.wid)

</t>
<t tx="davidmcnab.041604122248.94">class Fl_Button:
    """
    Creates and manages button widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the button
        """
        self.wid = flwm_.Fl_Button_create(x, y, w, h, label)
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Button_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Button_hide(self.wid)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when the button gets pushed. Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Button_callback(self.wid, func)

</t>
<t tx="davidmcnab.041604122248.95">class Fl_Select_Browser:
    """
    Creates and manages listbox widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the browser label
        """
        self.wid = flwm_.Fl_Select_Browser_create(x, y, w, h, label)
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Select_Browser_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Select_Browser_hide(self.wid)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when an item in the listbox gets selected.
           Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Select_Browser_callback(self.wid, func)

</t>
<t tx="davidmcnab.041604122248.96">@language python
"""
Pyrex interface layer to an FLTK subset
"""
@others
</t>
<t tx="davidmcnab.041604122248.97">@language c
//
// fltk-shim.cpp
//
// exposes FLTK C++ methods as C
//

@others
</t>
<t tx="davidmcnab.041604122248.98">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "Python.h"

#include &lt;X11/Xproto.h&gt;
#include &lt;X11/Xlib.h&gt;
#include &lt;FL/filename.H&gt;
#include &lt;FL/Enumerations.H&gt;
#include &lt;FL/Fl_Menu_Button.H&gt;
#include &lt;FL/Fl_Choice.H&gt;
#include &lt;FL/Fl_Browser.H&gt;
#include &lt;FL/Fl_Select_Browser.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;


</t>
<t tx="davidmcnab.041604122248.99"></t>
<t tx="davidmcnab.041604122248.100">@first #!/usr/bin/env python
@language python

"""
example1.y

Demonstrates an absolutely minimal window manager setup.
"""

import pywm

def run():
    windowManager = pywm.WM()
    windowManager.run()
    
if __name__ == '__main__':
    run()
</t>
<t tx="davidmcnab.041604122248.101">@first #!/usr/bin/env python
@language python

"""
example2.py

Same as example1, but uses a subclass.
Nothing too exciting so far.
"""

import pywm

class myWindowManagerClass(pywm.WM):
    pass # will define stuff in later examples

def run():
    # create a window manager object using our class
    windowManager = myWindowManagerClass()

    # and launch the window manager
    windowManager.run()

if __name__ == '__main__':
    run()
</t>
<t tx="davidmcnab.041604122248.102">@first #!/usr/bin/env python
@language python

"""
example4.py

Same as example3, but demonstrates key bindings.
Also, demonstrates creation of dynamic windows
"""

import pywm
import sys

class popupWindow(pywm.Fl_Window):
    """
    With pywm, you can create dynamic windows for user interaction
    via FLTK classes (a subset of these exposed to Python).
    Vastly easier than hacking raw X stuff.
    
    This is a simple window that just pops up a small window with
    a single button.
    """
    def __init__(self, wm):
        print "popupWindow: trying to make fltk window"
        self.wm = wm
        pywm.Fl_Window.__init__(self, 0, 0, 100, 60, "Hi There!")
        flB = pywm.Fl_Button(5,5,90,50,"A Button")
        flB.callback(self.cb)
        self.end()
        self.hide()
        #print "popupWindow window should be hidden"

    def cb(self, *args):
        print "cb"
        self.hide()
        print "cb: done"

class myWindowClass(pywm.window):
    """
    These window classes get instantiated by the PYWM engine.
    You should never instantiate this class yourself.
    
    If you create a subclass of pywm.window, and pass them in
    when constructing your window manager, then your subclass will be
    used every time a window is created.
    """
    def __init__(self, hWin, wm, **kwds):
        #print "myWindowClass.__init__: creating a window"
        pywm.window.__init__(self, hWin, wm, **kwds)
        #print "myWindowClass.__init__: window %s created" % self.name


class myWindowManagerClass(pywm.WM):
    """
    Our custom window manager class
    """
    def __init__(self):
        pywm.WM.__init__(
            self,
            windowclass=myWindowClass,
            # display='localhost:0.0',
            # visual=0 # try different numbers here - ref FLWM doco
            # geometry=WxH+X+Y, # constrain windows to this area
            # maximum=WxH # max size of maximised windows
            fg="#ffcc00", # window decoration foreground 
            bg="#000000", # window decoration background
            bg2="#00FF00", # text colour
            abg="#900000", # colour of active window bar
            cfg="#0000FF", # Cursor foreground color
            cbg="#FFFFFF", # Cursor outline color,
            # cursor=0, # Cursor number for root window
            exit=1, # change 'logout' menu prompt to 'exit'
            )

    def on_startup(self):
        """
        If you define an 'on_startup' method in your class, this
        method will get invoked just before the eindow manager
        engine enters its event loop. Note, however, that it
        gets called *after* the existing windows are discovered
        and the corresponding on_create callbacks fired.
        """
        print "myWindowManager: on_startup"

        # bind Shift-Alt-A to run self.launch with arg 'xterm'
        self.bindKey(self.launch, "xterm",
                     'a', 1, 0, 1, 0)

        # bind Shift-Alt-Meta-A to run vi
        self.bindKey(self.launch, "xterm -e vi",
                     'a', 1, 0, 1, 1)

        # bind Shift-Alt-Meta-Insert to run emacs in terminal
        self.bindKey(self.launch, "xterm -e emacs -nw",
                     'insert', 1, 0, 1, 1)
        print "myWindowManager: key binding done"

        self.flWin = None

        # create key binding so Meta-Alt-f pops up a window
        self.bindKey(self.flShow, None, "f", 0,0, 1, 1)

    def flShow(self, *args):
        if self.flWin == None:
            self.flWin = popupWindow(self)
        x, y = self.getMousePos()
        self.flWin.move(x, y)
        self.flWin.show()
         

def run():
    # create a window manager object using our class
    windowManager = myWindowManagerClass()

    # and launch the window manager
    windowManager.run()

if __name__ == '__main__':
    run()

</t>
<t tx="davidmcnab.041604122248.103">@first #!/usr/bin/env python
@language python

"""
example5.py

Same as example4, but adds left-edge border sensitivity

Also, adds a whole lot more keybindings
"""

import pywm
import sys
from random import randint
import traceback
import pywm.applets

class leftEdge(pywm.Fl_Window):
    """
    This is a pywm window which sits on the left edge of the screen,
    and fires callbacks when the mouse enters or clicks on the left edge.
    """
    def __init__(self, wm):
        self.wm = wm
        print "leftEdge: creating..."
        self.scrW, self.scrH = wm.getScreenSize()
        print "scrW=%d scrH=%d" % (self.scrW, self.scrH)
        pywm.Fl_Window.__init__(self, 0, 0, 3, self.scrH-2, "")
        self.show()
        self.stayOnTop()
        self.move(0, 1)
        self.yMin = int(self.scrH * 0.3)
        self.yMax = int(self.scrH * 0.5)
        print "leftEdge: now active"

    def on_enter(self, x, y):
        print "leftEdge: screen size (%d,%d) - mouse at %d,%d" % (
             self.scrW, self.scrH, x, y)
        if y &gt; self.yMin and y &lt; self.yMax:
            try:
                self.wm.showMenu()
            except:
                print "leftEdge: showMenu failed"
            else:
                print "leftEdge: is menu up?"

    def on_click(self, but, x, y):
        print "leftEdge: but=%d, mouse at %d,%d" % (but, x, y)


class popupWindow(pywm.Fl_Window):
    """
    With pywm, you can create dynamic windows for user interaction
    via FLTK classes (a subset of these exposed to Python).
    Vastly easier than hacking raw X stuff.
    
    This is a simple window that just pops up a small window with
    a single button.
    """
    def __init__(self, wm):
        print "popupWindow: trying to make fltk window"
        self.wm = wm
        pywm.Fl_Window.__init__(self, 0, 0, 100, 60, "Hi There!")
        flB = pywm.Fl_Button(5,5,90,50,"A Button")
        flB.callback(self.cb)
        self.end()
        self.hide()
        #print "popupWindow window should be hidden"

    def cb(self, *args):
        print "cb"
        self.hide()
        print "cb: done"


class myWindowClass(pywm.window):
    """
    These window classes get instantiated by the PYWM engine.
    You should never instantiate this class yourself.
    
    If you create a subclass of pywm.window, and pass them in
    when constructing your window manager, then your subclass will be
    used every time a window is created.
    """
    def __init__(self, hWin, wm, **kwds):
        print "myWindowClass.__init__: creating a window"
        pywm.window.__init__(self, hWin, wm, **kwds)
        print "myWindowClass.__init__: window %s created" % self.name

        # if window is gnome-terminal, move it to bottom left
        try:
            if self.name == 'Terminal':
                self.setborder('thin')
                self.goSouthWest()
                self.xGranularity = 10
                self.yGranularity = 18
                
            elif self.name[0:9] == "ProcMeter":
                self.setborder('thin')
                self.lock()
                self.size(100, 160)
                #self.position(0, 100)
                self.goNorthWest()
                #pywm.setTimer(3, self.moveDown)
            elif self.name in ['xterm', 'pywm']:
                self.setborder('thin')
                self.lock()
                self.size(360, 120)
                self.position(100, 0)
            elif self.name == 'xclock':
                self.setborder('thin')
                self.lock()
                self.size(100, 100)
                self.position(0,0)
                              
        except:
            pass

        #print "window init ok1"
        self.x0, self.y0 = self.position()
        self.w0, self.h0 = self.size()
        self.maxdelta = 20
        self.dead = False

        # uncomment this line if you feel like warping your mind
        #pywm.setTimer(10, self.hallucinate)

    def _moveDown(self):
        if self.dead:
            return
        x, y = self.position()
        y = y + 1
        if y &gt; 600:
            y = 0
        self.position(x, y)
        #pywm.repeatTimer(1, self.moveDown)

    def hallucinate(self):
        """
        Fun routine which creates slight repeating random changes in size and position
        """
        #print "hallucinate 1"
        if self.dead:
            return
        #print "hallucinate 1a"

        x, y = self.position()
        w, h = self.size()

        #print "hallucinate 2"
        x = x + randint(-10, 10)
        if x &lt; 0 or x &lt; self.x0 - self.maxdelta:
            x = self.x0 - self.maxdelta
        elif x &gt; self.x0 + self.maxdelta:
            x = self.x0 + self.maxdelta

        #print "hallucinate 3"
        y = y + randint(-10, 10)
        if y &lt; 0 or y &lt; self.y0 - self.maxdelta:
            y = self.y0 - self.maxdelta
        elif y &gt; self.y0 + self.maxdelta:
            y = self.y0 + self.maxdelta

        w = w + randint(-1, 1)
        if w &lt; self.w0 - self.maxdelta:
            w = self.w0 - self.maxdelta
        elif w &gt; self.w0 + self.maxdelta:
            w = self.w0 + self.maxdelta

        h = h + randint(-1, 1)
        if h &lt; self.h0 - self.maxdelta:
            h = self.h0 - self.maxdelta
        elif h &gt; self.h0 + self.maxdelta:
            h = self.h0 + self.maxdelta

        #print "hallucinate 4"
        self.position(x, y)
        self.size(w, h)
        pywm.setTimer(0.5, self.hallucinate)
        #print "hallucinate 5"
        
def cbTimer():
    print "global cbTimer fired"


class myWindowManagerClass(pywm.WM):
    """
    Our custom window manager class
    """
    def __init__(self):
        pywm.WM.__init__(
            self,
            windowclass=myWindowClass,
            # display='localhost:0.0',
            # visual=0 # try different numbers here - ref FLWM doco
            # geometry=WxH+X+Y, # constrain windows to this area
            # maximum=WxH # max size of maximised windows
            fg="#ffcc00", # window decoration foreground 
            bg="#000000", # window decoration background
            bg2="#00FF00", # text colour
            abg="#900000", # colour of active window bar
            cfg="#0000FF", # Cursor foreground color
            cbg="#FFFFFF", # Cursor outline color,
            # cursor=0, # Cursor number for root window
            exit=1, # change 'logout' menu prompt to 'exit'
            )
        self.gotTerminal = False
        self.gotProcmeter = False
        self.gotClock = False
        self.win_xemacs = None
        self.win_pyweb = None

    def on_startup(self):
        """
        If you define an 'on_startup' method in your class, this
        method will get invoked just before the eindow manager
        engine enters its event loop. Note, however, that it
        gets called *after* the existing windows are discovered
        and the corresponding on_create callbacks fired.
        """
        print "myWindowManager.on_startup"

        self.leftbar = pywm.appletBar(self, 0, 0, 100, 'down')
        #self.leftbar.add(pywm.applets.xapp, 100,
        #                 "xclock -bg \\#000000 -fg \\#ffcc00 -hd \\#ffcc00 -update 1",
        #                 "xclock")
        self.leftbar.add(pywm.applets.xapp, 170, "procmeter3", "ProcMeter3.*")
        self.leftbar.add(pywm.applets.tasklist, 150)
        if 1:
            try:
                self.leftbar.add(pywm.applets.quicklaunch, 180,
                                 ('Terminal', 'gnome-terminal'),
                                 ('Browser', 'galeon'),
                                 ('Email', 'evolution'),
                                 ('X-Emacs', 'xemacs'),
                                 ('X-term', 'xterm'),
                                 ('Moz Editor', 'mozilla -edit'),
                                 ('XMMS', 'xmms'),
                                 ("X-Chat", 'xchat'),
                                 ("gtop", "gtop"),
                                 ("pyweb", self.hackpyweb),
                                 ("CONFIG", "pywm-hack"),
                                 )
            except:
                print "myWindowManager.on_startup: quicklaunch create failed"
                traceback.print_exc()
        if 1:
            self.leftbar.add(pywm.applets.navigator, 40)
            self.leftbar.add(pywm.applets.shellbox, 40)
            #self.leftbar.add(pywm.applets.xapp, 120, "xbiff", "xbiff")

        if 0:
            try:
                print "trying to create xbiff ***********************"
                self.xbiff = pywm.applets.xapp(self, 130, 160, 150, 150,
                                               "xbiff -bg \\#000000 -fg \\#ffcc00", "xbiff")
                print "created xbiff ********************************"
            except:
                print "myWindowManager.on_startup: xbiff create failed"
                traceback.print_exc()
            else:
                print "on_startup: xbiff created"

        # bind Shift-Alt-A to run self.launch with arg 'xterm'
        self.bindKey(self.launch, "xterm",
                     'a', 1, 0, 1, 0)

        # bind Shift-Alt-Meta-A to run vi
        self.bindKey(self.launch, "xterm -e vi",
                     'a', 1, 0, 1, 1)

        # bind Shift-Alt-Meta-Insert to run emacs in terminal
        self.bindKey(self.launch, "xterm -e emacs -nw",
                     'insert', 1, 0, 1, 1)

        # a few assored launcher bindings
        #self.bindKey(self.launch, "sylpheed-claws", 's', 0, 0, 1, 1)
        #self.bindKey(self.launch, "firebird", "f", 0, 0, 1, 1)
        #self.bindKey(self.launch, "knode", "d", 0, 0, 1, 1)

        # add a few bindings to allow moving windows via keyboard
        self.bindKey(self.moveCurrent, 'up', 'k', 0, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'down', 'j', 0, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'left', 'h', 0, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'right', 'l', 0, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'north', 'k', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'south', 'j', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'west', 'h', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'east', 'l', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'centre', 'c', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'northwest', 'u', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'northeast', 'i', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'southwest', 'n', 1, 0, 1, 1)
        self.bindKey(self.moveCurrent, 'southeast', 'm', 1, 0, 1, 1)

        self.bindKey(self.resizeCurrent, 'wider', 'y', 0, 0, 1, 1)
        self.bindKey(self.resizeCurrent, 'taller', 'u', 0, 0, 1, 1)
        self.bindKey(self.resizeCurrent, 'narrower', 'n', 0, 0, 1, 1)
        self.bindKey(self.resizeCurrent, 'shorter', 'm', 0, 0, 1, 1)

        self.bindKey(self.toggleMaxCurrent, None, '.', 0, 0, 1, 1)
        self.bindKey(self.toggleMaxWidthCurrent, None, ',', 0, 0, 1, 1)
        self.bindKey(self.toggleMaxHeightCurrent, None, '/', 0, 0, 1, 1)

        self.bindKey(self.cascadeWindows, 40, "q", 1, 0, 1, 1)

        self.bindKey(self.closeCurrent, None, 'x', 1, 0, 1, 1)

        self.bindKey(self.zoomIn, 1.1, 'down', 1, 0, 1, 1)
        self.bindKey(self.zoomOut, 0.88, 'up', 1, 0, 1, 1)
        self.bindKey(self.zoomInMouse, 1.1, 'down', 1, 1, 1, 1)
        self.bindKey(self.zoomOutMouse, 0.88, 'up', 1, 1, 1, 1)

        self.bindKey(self.panLeft, 30, 'left', 0, 0, 1, 1)
        self.bindKey(self.panRight, 30, 'right', 0, 0, 1, 1)
        self.bindKey(self.panUp, 30, 'up', 0, 0, 1, 1)
        self.bindKey(self.panDown, 30, 'down', 0, 0, 1, 1)

        print "myWindowManager: key binding done"

        self.flWin = None

        # create key binding so Meta-Alt-f pops up a window
        self.bindKey(self.flShow, None, "f", 1,0, 1, 1)

        #if not self.gotProcmeter:
        #    self.launch("procmeter3")

        #if not self.gotTerminal:
        #    pywm.setTimer(1, self.cbTimer)

        pywm.setTimer(1, self.cbShowEdges)

    def on_resize(self, win, x, y, w, h):
        """
        """
        win.x0, win.y0 = win.position()
        #print "myWindowManager: resized %s to (%d,%d %d,%d)" % (
        #         win.name, x, y, w, h)

    def on_create(self, win):
        print "myWindowManager: created window %s" % win.name
        if win.name == 'Terminal':
            self.gotTerminal = True
        elif win.name[0:9] == 'ProcMeter':
            self.gotProcmeter = True
        elif win.name == 'xclock':
            self.gotClock = True
        elif win.name.find("emacs:") &gt;=0:
            print "Got XEmacs"
            self.win_xemacs = win
        elif win.name.startswith("/main/pywindows/myprogs/pyweb/code.leo"):
            print "Got pyweb"
            self.win_pyweb = win

    def cbTimer(self):
        print "self.cbTimer: got callback"
        self.launch("gnome-terminal")
        #pywm.repeatTimer(5, self.cbTimer)

    def cbShowEdges(self):
        # put up the left-edge window
        self.leftEdge = leftEdge(self)
        self.leftEdge.show()
        self.leftEdge.stayOnTop()
        print "try left edge now"

    def flShow(self, *args):
        # put up the left-edge window
        #self.leftEdge = leftEdge(self)

        if self.flWin == None:
            self.flWin = popupWindow(self)
        x, y = self.getMousePos()
        self.flWin.move(x, y)
        self.flWin.show()

    def hackpyweb(self):
        print "hackpyweb: entered"
        if not self.win_xemacs:
            print "launching xemacs"
            self.launch("xemacs")
        if not self.win_pyweb:
            print "launching leo pyweb"
            self.launch("pyweb")
        pywm.setTimer(1, self.position_pyweb)
    
    def position_pyweb(self):
        if not (self.win_xemacs and self.win_pyweb):
            print "waiting for xemacs and/or leo pyweb"
            pywm.setTimer(1, self.position_pyweb)
        else:
            print "positioning leo and xemacs for pyweb"
            self.win_pyweb.position(120, 40)
            self.win_pyweb.size(400, 1000)
            self.win_xemacs.position(520, 40)
            self.win_xemacs.size(1000, 1000)
            
def run():         
    # create a window manager object using our class
    windowManager = myWindowManagerClass()

    # and launch the window manager
    windowManager.run()

if __name__ == '__main__':
    run()
</t>
<t tx="davidmcnab.041604122248.104">@first #!/usr/bin/env python
@language python

"""
example5.py

Same as example4, but adds left-edge border sensitivity

Also, adds a whole lot more keybindings
"""

@others
</t>
<t tx="davidmcnab.041604122248.105">import pywm
import sys
from random import randint
import traceback
import pywm.applets

</t>
<t tx="davidmcnab.041604122248.106">class leftEdge(pywm.Fl_Window):
    """
    This is a pywm window which sits on the left edge of the screen,
    and fires callbacks when the mouse enters or clicks on the left edge.
    """
    @others
</t>
<t tx="davidmcnab.041604122248.107">def __init__(self, wm):
    self.wm = wm
    print "leftEdge: creating..."
    self.scrW, self.scrH = wm.getScreenSize()
    print "scrW=%d scrH=%d" % (self.scrW, self.scrH)
    pywm.Fl_Window.__init__(self, 0, 0, 3, self.scrH-2, "")
    self.show()
    self.stayOnTop()
    self.move(0, 1)
    self.yMin = int(self.scrH * 0.3)
    self.yMax = int(self.scrH * 0.5)
    print "leftEdge: now active"

</t>
<t tx="davidmcnab.041604122248.108">def on_enter(self, x, y):
    print "leftEdge: screen size (%d,%d) - mouse at %d,%d" % (
         self.scrW, self.scrH, x, y)
    if y &gt; self.yMin and y &lt; self.yMax:
        try:
            self.wm.showMenu()
        except:
            print "leftEdge: showMenu failed"
        else:
            print "leftEdge: is menu up?"
</t>
<t tx="davidmcnab.041604122248.109">def on_click(self, but, x, y):
    print "leftEdge: but=%d, mouse at %d,%d" % (but, x, y)

</t>
<t tx="davidmcnab.041604122248.110">class popupWindow(pywm.Fl_Window):
    """
    With pywm, you can create dynamic windows for user interaction
    via FLTK classes (a subset of these exposed to Python).
    Vastly easier than hacking raw X stuff.
    
    This is a simple window that just pops up a small window with
    a single button.
    """
    @others
</t>
<t tx="davidmcnab.041604122248.111">def __init__(self, wm):
    print "popupWindow: trying to make fltk window"
    self.wm = wm
    pywm.Fl_Window.__init__(self, 0, 0, 100, 60, "Hi There!")
    flB = pywm.Fl_Button(5,5,90,50,"A Button")
    flB.callback(self.cb)
    self.end()
    self.hide()
    #print "popupWindow window should be hidden"
</t>
<t tx="davidmcnab.041604122248.112">def cb(self, *args):
    print "cb"
    self.hide()
    print "cb: done"
</t>
<t tx="davidmcnab.041604122248.113">class myWindowClass(pywm.window):
    """
    These window classes get instantiated by the PYWM engine.
    You should never instantiate this class yourself.
    
    If you create a subclass of pywm.window, and pass them in
    when constructing your window manager, then your subclass will be
    used every time a window is created.
    """
    @others
</t>
<t tx="davidmcnab.041604122248.114">def __init__(self, hWin, wm, **kwds):
    print "myWindowClass.__init__: creating a window"
    pywm.window.__init__(self, hWin, wm, **kwds)
    print "myWindowClass.__init__: window %s created" % self.name

    # if window is gnome-terminal, move it to bottom left
    try:
        if self.name == 'Terminal':
            self.setborder('thin')
            self.goSouthWest()
            self.xGranularity = 10
            self.yGranularity = 18
            
        elif self.name[0:9] == "ProcMeter":
            self.setborder('thin')
            self.lock()
            self.size(100, 160)
            #self.position(0, 100)
            self.goNorthWest()
            #pywm.setTimer(3, self.moveDown)
        elif self.name in ['xterm', 'pywm']:
            self.setborder('thin')
            self.lock()
            self.size(360, 120)
            self.position(100, 0)
        elif self.name == 'xclock':
            self.setborder('thin')
            self.lock()
            self.size(100, 100)
            self.position(0,0)
                          
    except:
        pass

    #print "window init ok1"
    self.x0, self.y0 = self.position()
    self.w0, self.h0 = self.size()
    self.maxdelta = 20
    self.dead = False

    # uncomment this line if you feel like warping your mind
    #pywm.setTimer(10, self.hallucinate)

</t>
<t tx="davidmcnab.041604122248.115">def _moveDown(self):
    if self.dead:
        return
    x, y = self.position()
    y = y + 1
    if y &gt; 600:
        y = 0
    self.position(x, y)
    #pywm.repeatTimer(1, self.moveDown)

</t>
<t tx="davidmcnab.041604122248.116">def hallucinate(self):
    """
    Fun routine which creates slight repeating random changes in size and position
    """
    #print "hallucinate 1"
    if self.dead:
        return
    #print "hallucinate 1a"

    x, y = self.position()
    w, h = self.size()

    #print "hallucinate 2"
    x = x + randint(-10, 10)
    if x &lt; 0 or x &lt; self.x0 - self.maxdelta:
        x = self.x0 - self.maxdelta
    elif x &gt; self.x0 + self.maxdelta:
        x = self.x0 + self.maxdelta

    #print "hallucinate 3"
    y = y + randint(-10, 10)
    if y &lt; 0 or y &lt; self.y0 - self.maxdelta:
        y = self.y0 - self.maxdelta
    elif y &gt; self.y0 + self.maxdelta:
        y = self.y0 + self.maxdelta

    w = w + randint(-1, 1)
    if w &lt; self.w0 - self.maxdelta:
        w = self.w0 - self.maxdelta
    elif w &gt; self.w0 + self.maxdelta:
        w = self.w0 + self.maxdelta

    h = h + randint(-1, 1)
    if h &lt; self.h0 - self.maxdelta:
        h = self.h0 - self.maxdelta
    elif h &gt; self.h0 + self.maxdelta:
        h = self.h0 + self.maxdelta

    #print "hallucinate 4"
    self.position(x, y)
    self.size(w, h)
    pywm.setTimer(0.5, self.hallucinate)
    #print "hallucinate 5"
</t>
<t tx="davidmcnab.041604122248.117">def cbTimer():
    print "global cbTimer fired"


</t>
<t tx="davidmcnab.041604122248.118">class myWindowManagerClass(pywm.WM):
    """
    Our custom window manager class
    """
    @others
</t>
<t tx="davidmcnab.041604122248.119">def __init__(self):
    pywm.WM.__init__(
        self,
        windowclass=myWindowClass,
        # display='localhost:0.0',
        # visual=0 # try different numbers here - ref FLWM doco
        # geometry=WxH+X+Y, # constrain windows to this area
        # maximum=WxH # max size of maximised windows
        fg="#ffcc00", # window decoration foreground 
        bg="#000000", # window decoration background
        bg2="#00FF00", # text colour
        abg="#900000", # colour of active window bar
        cfg="#0000FF", # Cursor foreground color
        cbg="#FFFFFF", # Cursor outline color,
        # cursor=0, # Cursor number for root window
        exit=1, # change 'logout' menu prompt to 'exit'
        )
    self.gotTerminal = False
    self.gotProcmeter = False
    self.gotClock = False
    self.win_xemacs = None
    self.win_conspyre = None
</t>
<t tx="davidmcnab.041604122248.120">def on_startup(self):
    """
    If you define an 'on_startup' method in your class, this
    method will get invoked just before the eindow manager
    engine enters its event loop. Note, however, that it
    gets called *after* the existing windows are discovered
    and the corresponding on_create callbacks fired.
    """
    print "myWindowManager.on_startup"

    self.leftbar = pywm.appletBar(self, 0, 0, 100, 'down')
    #self.leftbar.add(pywm.applets.xapp, 100,
    #                 "xclock -bg \\#000000 -fg \\#ffcc00 -hd \\#ffcc00 -update 1",
    #                 "xclock")

    #self.leftbar.add(pywm.applets.xapp, 170, "procmeter3", "ProcMeter3.*")

    self.leftbar.add(pywm.applets.tasklist, 150)
    if 1:
        try:
            self.leftbar.add(pywm.applets.quicklaunch, 240,
                             ('Terminal', 'gnome-terminal'),
                             ('Browser', 'galeon'),
                             ('Email', 'evolution'),
                             ('X-Emacs', 'xemacs'),
                             ('X-term', 'xterm'),
                             ('Pan News', 'pan'),
                             ('Moz Editor', 'mozilla -edit'),
                             ('XMMS', 'xmms'),
                             ("X-Chat", 'xchat'),
                             ("gtop", "gtop"),
                             ("ConsPyre", self.hackconspyre),
                             ("CONFIG", "pywm-hack"),
                             )
        except:
            print "myWindowManager.on_startup: quicklaunch create failed"
            traceback.print_exc()
    if 1:
        self.leftbar.add(pywm.applets.navigator, 40)
        self.leftbar.add(pywm.applets.shellbox, 40)
        #self.leftbar.add(pywm.applets.xapp, 120, "xbiff", "xbiff")

    if 0:
        try:
            print "trying to create xbiff ***********************"
            self.xbiff = pywm.applets.xapp(self, 130, 160, 150, 150,
                                           "xbiff -bg \\#000000 -fg \\#ffcc00", "xbiff")
            print "created xbiff ********************************"
        except:
            print "myWindowManager.on_startup: xbiff create failed"
            traceback.print_exc()
        else:
            print "on_startup: xbiff created"

    # bind Shift-Alt-A to run self.launch with arg 'xterm'
    self.bindKey(self.launch, "xterm",
                 'a', 1, 0, 1, 0)

    # bind Shift-Alt-Meta-A to run vi
    self.bindKey(self.launch, "xterm -e vi",
                 'a', 1, 0, 1, 1)

    # bind Shift-Alt-Meta-Insert to run emacs in terminal
    self.bindKey(self.launch, "xterm -e emacs -nw",
                 'insert', 1, 0, 1, 1)

    # general bindings
    self.bindKey(self.launch, "galeon", 'g', 0, 0, 1, 1)
    self.bindKey(self.launch, "gnome-terminal", "t", 0, 0, 1, 1)
    self.bindKey(self.launch, "mozilla-thunderbird", "m", 0, 0, 1, 1)
    self.bindKey(self.launch, "xemacs", "e", 0, 0, 1, 1)

    self.bindKey(self.goPrevWindow, 0, '[', 0,0,0,1)
    self.bindKey(self.goNextWindow, 0, ']', 0,0,0,1)

    # a few assored launcher bindings
    #self.bindKey(self.launch, "sylpheed-claws", 's', 0, 0, 1, 1)
    #self.bindKey(self.launch, "firebird", "f", 0, 0, 1, 1)
    #self.bindKey(self.launch, "knode", "d", 0, 0, 1, 1)

    # add a few bindings to allow moving windows via keyboard
    self.bindKey(self.moveCurrent, 'up', 'up', 0, 0, 0, 1)
    self.bindKey(self.moveCurrent, 'down', 'down', 0, 0, 0, 1)
    self.bindKey(self.moveCurrent, 'left', 'left', 0, 0, 0, 1)
    self.bindKey(self.moveCurrent, 'right', 'right', 0, 0, 0, 1)
    self.bindKey(self.moveCurrent, 'north', 'up', 0, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'south', 'down', 0, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'west', 'left', 0, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'east', 'right', 0, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'centre', 'home', 0, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'northwest', 'up', 1, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'northeast', 'right', 1, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'southwest', 'left', 1, 1, 0, 1)
    self.bindKey(self.moveCurrent, 'southeast', 'down', 1, 1, 0, 1)

    self.bindKey(self.resizeCurrent, 'wider', 'right', 1, 0, 0, 1)
    self.bindKey(self.resizeCurrent, 'taller', 'down', 1, 0, 0, 1)
    self.bindKey(self.resizeCurrent, 'narrower', 'left', 1, 0, 0, 1)
    self.bindKey(self.resizeCurrent, 'shorter', 'up', 1, 0, 0, 1)

    self.bindKey(self.toggleMaxCurrent, None, '.', 0, 0, 1, 1)
    self.bindKey(self.toggleMaxWidthCurrent, None, ',', 0, 0, 1, 1)
    self.bindKey(self.toggleMaxHeightCurrent, None, '/', 0, 0, 1, 1)

    self.bindKey(self.cascadeWindows, 40, "q", 1, 0, 1, 1)

    self.bindKey(self.closeCurrent, None, 'x', 1, 0, 1, 1)

    self.bindKey(self.zoomIn, 1.1, 'down', 1, 0, 1, 1)
    self.bindKey(self.zoomOut, 0.88, 'up', 1, 0, 1, 1)
    self.bindKey(self.zoomInMouse, 1.1, 'down', 1, 1, 1, 1)
    self.bindKey(self.zoomOutMouse, 0.88, 'up', 1, 1, 1, 1)

    self.bindKey(self.panLeft, 30, 'left', 0, 0, 1, 1)
    self.bindKey(self.panRight, 30, 'right', 0, 0, 1, 1)
    self.bindKey(self.panUp, 30, 'up', 0, 0, 1, 1)
    self.bindKey(self.panDown, 30, 'down', 0, 0, 1, 1)

    print "myWindowManager: key binding done"

    self.flWin = None

    # create key binding so Meta-Alt-f pops up a window
    self.bindKey(self.flShow, None, "f", 1,0, 1, 1)

    #if not self.gotProcmeter:
    #    self.launch("procmeter3")

    #if not self.gotTerminal:
    #    pywm.setTimer(1, self.cbTimer)

    pywm.setTimer(1, self.cbShowEdges)



</t>
<t tx="davidmcnab.041604122248.121">def on_resize(self, win, x, y, w, h):
    """
    """
    win.x0, win.y0 = win.position()
    #print "myWindowManager: resized %s to (%d,%d %d,%d)" % (
    #         win.name, x, y, w, h)

    # create a 'docking' effect - if moving pyweb leo window, move emacs as well
    if win == self.win_conspyre:
        if self.win_xemacs:
            w0, h0 = self.win_xemacs.size()
            self.win_xemacs.position(x+w+4, y)
            self.win_xemacs.size(w0, h)
</t>
<t tx="davidmcnab.041604122248.122">def on_create(self, win):
    print "myWindowManager: created window %s" % win.name
    if win.name == 'Terminal':
        self.gotTerminal = True
    elif win.name[0:9] == 'ProcMeter':
        self.gotProcmeter = True
    elif win.name == 'xclock':
        self.gotClock = True
    elif win.name.find("emacs:") &gt;=0:
        print "Got XEmacs"
        self.win_xemacs = win
    elif win.name.startswith("/main/pywindows/myprogs/conspyre/code.leo"):
        print "Got conspyre"
        self.win_conspyre = win
</t>
<t tx="davidmcnab.041604122248.123">def on_destroy(self, win):
    if win.name.find("emacs:") &gt;=0:
        print "Killing XEmacs"
        self.win_xemacs = None
    elif win.name.startswith("/main/pywindows/myprogs/conspyre/code.leo"):
        print "Killing conspyre"
        self.win_conspyre = None
</t>
<t tx="davidmcnab.041604122248.124">def cbTimer(self):
    print "self.cbTimer: got callback"
    self.launch("gnome-terminal")
    #pywm.repeatTimer(5, self.cbTimer)

</t>
<t tx="davidmcnab.041604122248.125">def cbShowEdges(self):
    # put up the left-edge window
    self.leftEdge = leftEdge(self)
    self.leftEdge.show()
    self.leftEdge.stayOnTop()
    print "try left edge now"

</t>
<t tx="davidmcnab.041604122248.126">def flShow(self, *args):
    # put up the left-edge window
    #self.leftEdge = leftEdge(self)

    if self.flWin == None:
        self.flWin = popupWindow(self)
    x, y = self.getMousePos()
    self.flWin.move(x, y)
    self.flWin.show()
</t>
<t tx="davidmcnab.041604122248.127">def hackconspyre(self):
    print "hackconspyre: entered"
    if not self.win_xemacs:
        print "launching xemacs"
        self.launch("xemacs")
    if not self.win_conspyre:
        print "launching leo conspyre"
        self.launch("leo-conspyre")
    pywm.setTimer(1, self.position_conspyre)

</t>
<t tx="davidmcnab.041604122248.128">def position_conspyre(self):
    if not (self.win_xemacs and self.win_conspyre):
        print "waiting for xemacs and/or leo conspyre"
        pywm.setTimer(1, self.position_conspyre)
    else:
        print "positioning leo and xemacs for conspyre"
        self.win_conspyre.position(120, 40)
        self.win_conspyre.size(400, 1000)
        self.win_xemacs.position(520, 40)
        self.win_xemacs.size(1000, 1000)
</t>
<t tx="davidmcnab.041604122248.129">def run():         
    # create a window manager object using our class
    windowManager = myWindowManagerClass()

    # and launch the window manager
    windowManager.run()
</t>
<t tx="davidmcnab.041604122248.130">if __name__ == '__main__':
    run()
</t>
<t tx="davidmcnab.041604122248.131">@first #!/usr/bin/env python
@language python
&lt;&lt; test declarations &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.132">#!/usr/bin/env python

import random
import pywm

</t>
<t tx="davidmcnab.041604122248.133">class myWindow(pywm.window):
    @others
</t>
<t tx="davidmcnab.041604122248.134">def on_resize(self, x, y, w, h):
    print "myWindow: %d %d %d %d %s" % (x, y, w, h, self.name)

</t>
<t tx="davidmcnab.041604122248.135">class myWM(pywm.WM):
    @others
</t>
<t tx="davidmcnab.041604122248.136">def __init__(self, **kwds):
	pywm.WM.__init__(self, **kwds)
    #self.bindKey("z", self.hello)
    self.vi = None

def hello(self):
    print "hello"

</t>
<t tx="davidmcnab.041604122248.137">def on_create(self, win):

    print "myWM.on_create: created window '%s'" % win.name
    #return

    x, y = win.position()
    #print "myWM:on_create: win.position succeeded"
    w, h = win.size()
    #print "myWM:on_create: win.size succeeded"
    #print "myWM:on_create: x=%d y=%d w=%d h=%d" % (x, y, w, h)
    #return
 
    # move the window
    if win.name == "xterm":
        #print "got xterm,, but bailing for now"
        #return
        self.xterm = win
        #print "myWM.on_create: trying to reposition and resize xterm"
        win.position(0, 0)
        win.size(600, 600)
        #print "myWM.on_create: repos/resize seems ok"
        return
        if self.vi:
            print "trying to close vi window"
            self.vi.close()

    if win.name == "vi":
        #print "myWM.on_create: got vi started"
        self.vi = win
        #return 
        self.launch("xterm")
        #print "myWM.on_create: tried to launch xterm"
</t>
<t tx="davidmcnab.041604122248.138">def on_destroy(self, win):
    print "myWM:on_destroy: destroyed window '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.139">def on_resize(self, win, x, y, w, h):
    #print "on_resize"
    #print "myWM.on_resize: x=%d y=%d w=%d h=%d name=%s" % (x, y, w, h, win.name)
    return

    if win.name == 'Terminal':
        self.xterm.position(x, y-self.xterm.height())
    return 0

</t>
<t tx="davidmcnab.041604122248.140">def on_buttonPress(self, button):
    print "myWM.on_buttonPress callback: button %d" % button
</t>
<t tx="davidmcnab.041604122248.141">def on_keyEvent(self, key):
    print "myWM.on_keyEvent callback: key=%d" % key

</t>
<t tx="davidmcnab.041604122248.142">def on_enter(self, win):
    
    name = win.name

    x, y = self.getMousePosition()
    print "myWM.on_enter: x=%d y=%d" % (x, y)
    if name == 'vi':
        print "mouse at %d,%d" % (x, y)
        win.position(random.randint(0, 400), random.randint(0, 400))

</t>
<t tx="davidmcnab.041604122248.143">#def on_leave(self, hWin):
#    
#    win = self.windows[hWin]
#    name = win.name
#
#    x, y = self.getMousePosition()
#    print "on_leave: mouse at %d,%d" % (x, y)

</t>
<t tx="davidmcnab.041604122248.144">def run():
    #wm = flwm.WM(fg="#ffcc00", bg="#000000", exit=1)
    wm = myWM(windowclass=myWindow,
              fg="#ffcc00",
              abg="#800080",
              bg="#000000",
              exit=1)
    wm.run()

</t>
<t tx="davidmcnab.041604122248.145">if __name__ == '__main__':
    run()
</t>
<t tx="davidmcnab.041604122248.146"></t>
<t tx="davidmcnab.041604122248.147">@language python
"""
pywm.applet

A set of applets
"""

import sys, os, traceback, re

sys.path.append('..')
import pywm
sys.path.pop()

@others


</t>
<t tx="davidmcnab.041604122248.148">class tasklist(pywm.appletBase):
    """
    Creates and operates a tasklist applet.
    """
    def __init__(self, wm, x, y, w, h):
        """
        Creates the tasklist applet
        
        Args:
         - wm - ref to window manager
         - x, y - position of tasklist
         - w, h - dimensions of tasklist
        """
        #print "tasklist.__init__: entered"
        pywm.appletBase.__init__(self, wm, x, y, w, h)

        #print "tasklist.__init__: started"
        if getattr(self, 'win', None) == None:
            lst = self.lst = pywm.Fl_Hold_Browser(5, 5, w-10, h-10, "")
            lst.color("#000000")
            lst.textcolor("#ffcc00")
            lst.selectioncolor("#ffcc00")
            for win in self.wm.windows.values():
                lst.add(win.name)

            self.end()
            self.show()
            lst.callback(self.onCallback)
        else:
            self.taskbarRefresh()
            self.show()
        #print "tasklist.__init__: finished"

        self.addHandlers(startup=self.onStartup,
                         create=self.taskbarRefresh,
                         destroy=self.taskbarRefresh,
                         activate=self.taskbarRefresh,
                         deactivate=self.taskbarRefresh,
                         )

    def onStartup(self):
        """
        """
        #print "tasklist.onStartup: started"
        self.show()

    def taskbarRefresh(self, win=None):
        #print "tasklistRefresh: entered"
        if win:
            print win
        try:
            self.lst.clear()
            for w in self.wm.windowlist:
                if not w.dead:
                    self.lst.add(w.name)
            if win:
                #print "tasklistRefresh: marking window active"
                self.lst.value(self.wm.indexFromWindow(win)+1)
        except:
            pass
        return 0 # pass this to other handlers in the chain
        #print "taskbarRefresh: done"
       
    def onCallback(self, arg=None):
        sel = self.lst.value()
        if sel &gt;= 1:
            try:
                win = self.wm.windowFromIndex(sel-1)
                if win:
                    win.raise_()
                    win.activate()
            except:
                print "window select failed"

</t>
<t tx="davidmcnab.041604122248.149">class navigator(pywm.appletBase):
    """
    Creates and operates a navigator applet
    """
    def __init__(self, wm, x, y, w, h, factor=10):
        """
        Creates a navigator applet, with pan/zoom buttons
        
        Args:
         - wm - ref to window manager
         - x, y - position of navigator
         - w, h - dimensions of navigator
        """
        print "navigator.__init__: entered"
        pywm.appletBase.__init__(self, wm, x, y, w, h)
        
        self.factor = factor

        butw = (w - 10)/5
        buth = (h - 10)/2

        # add buttons to zoom and pan the desktop
        butPL = self.butPL = pywm.Fl_Repeat_Button(5, 5, butw, buth, "@4&gt;")
        butPL.callback(self.onButPL)
        butPL.symbollabel()

        butPR = self.butPR = pywm.Fl_Repeat_Button(5+butw, 5, butw, buth, "@&gt;")
        butPR.callback(self.onButPR)
        butPR.symbollabel()

        butPU = self.butPU = pywm.Fl_Repeat_Button(5+2*butw, 5, butw, buth, "@8&gt;")
        butPU.callback(self.onButPU)
        butPU.symbollabel()

        butPD = self.butPD = pywm.Fl_Repeat_Button(5+3*butw, 5, butw, buth, "@2&gt;")
        butPD.callback(self.onButPD)
        butPD.symbollabel()

        # faster ones
        butPL = self.butPL = pywm.Fl_Repeat_Button(5, 5+buth, butw, buth, "@4&gt;&gt;")
        butPL.callback(self.onButPLf)
        butPL.symbollabel()

        butPR = self.butPR = pywm.Fl_Repeat_Button(5+butw, 5+buth, butw, buth, "@&gt;&gt;")
        butPR.callback(self.onButPRf)
        butPR.symbollabel()

        butPU = self.butPU = pywm.Fl_Repeat_Button(5+2*butw, 5+buth, butw, buth, "@8&gt;&gt;")
        butPU.callback(self.onButPUf)
        butPU.symbollabel()

        butPD = self.butPD = pywm.Fl_Repeat_Button(5+3*butw, 5+buth, butw, buth, "@2&gt;&gt;")
        butPD.callback(self.onButPDf)
        butPD.symbollabel()

        # zoom buttons
        butZO = self.butZO = pywm.Fl_Repeat_Button(5+4*butw, 5, butw, buth, "@8-&gt;")
        butZO.callback(self.onButZO)
        butZO.symbollabel()

        butZI = self.butZI = pywm.Fl_Repeat_Button(5+4*butw, 5+buth, butw, buth, "@2-&gt;")
        butZI.callback(self.onButZI)
        butZI.symbollabel()

        self.end()
        self.show()

    def onButPL(self):
        self.wm.panLeft(self.factor)

    def onButPU(self):
        self.wm.panUp(self.factor)

    def onButPD(self):
        self.wm.panDown(self.factor)

    def onButPR(self):
        self.wm.panRight(self.factor)

    def onButPLf(self):
        self.wm.panLeft(self.factor * 12)

    def onButPUf(self):
        self.wm.panUp(self.factor * 12)

    def onButPDf(self):
        self.wm.panDown(self.factor * 12)

    def onButPRf(self):
        self.wm.panRight(self.factor * 12)

    def onButZI(self):
        self.wm.zoomIn(self.factor)

    def onButZO(self):
        self.wm.zoomOut(self.factor)

    def onStartup(self):
        """
        """
        self.show()


</t>
<t tx="davidmcnab.041604122248.150">class quicklaunch(pywm.appletBase):
    """
    Creates a quick launcher applet
    """
    
    def __init__(self, wm, x, y, w, h, *programs):
        """
        Creates the launcher applet
        
        Args:
         - wm - ref to window manager
         - x, y - position of tasklist
         - w, h - dimensions of tasklist
         - programs - a list of ('name', 'command') tuples to put on launcher
        """
        print "quicklaunch.__init__: entered: (%d,%d,%d,%d)" % (x,y,w,h)
        print "quicklaunch.__init__: programs", programs
        pywm.appletBase.__init__(self, wm, x, y, w, h)

        print "quicklaunch.__init__: created fltk window"

        lst = self.lst = pywm.Fl_Select_Browser(5, 5, w-10, h-10, "")
        self.end()
        self.show()
        lst.color("#000000")
        lst.textcolor("#ffcc00")
        lst.selectioncolor("#ffcc00")
        
        print "quicklaunch.__init__: ok1"

        self.progNames = []
        self.progCmds = []
        for prog in programs:
            self.progNames.append(prog[0])
            self.progCmds.append(prog[1])
            lst.add(prog[0])
        lst.callback(self.onSelect)
        lst.value(0)

        print "quicklaunch.__init__: ok2"

    
    def onSelect(self):
        choice = self.lst.value()
        if choice &gt;= 1:
            cmd = self.progCmds[choice-1]
            if type(cmd) is type(""):
                print "Launching: '%s'" % cmd
                os.system(cmd + " &amp;")
            elif callable(cmd):
                print "Invloking quicklaunch callable"
                cmd()

</t>
<t tx="davidmcnab.041604122248.151">class shellbox(pywm.appletBase):
    """
    Displays a small input field for entering shell commands
    """
    def __init__(self, wm, x, y, w=100, h=40):
        """
        Creates the shellbox applet
        
        Args:
         - wm - ref to window manager
         - x, y - position of shellbox
         - w, h - dimensions of shellbox (default 120x40)
        """
        print "shellbox.__init__: entered"
        pywm.appletBase.__init__(self, wm, x, y, w, h)

        fld = self.fld = pywm.Fl_Input(5, 5, w-10, h-10, "&lt;FLWM&gt;")
        fld.color("#000000")
        fld.textcolor("#ffcc00")
        fld.selectioncolor("#ffcc00")
        self.end()

        fld.callback(self.onEnter)
        self.show()
        print "shellbox.__init__: done"

    def onEnter(self):
        #print "shellbox.onEnter: callback fired"
        try:
            cmd = self.fld.value()
        except:
            print "shellbox.onEnter: callback failed"
            traceback.print_exc()
        else:
            #print "got command '%s'" % cmd
            os.system(cmd + " &amp;")

    def on_enter(self, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept 2 args, x and y,
        which will be the position of the mouse on entry.
        """
        self.activate()
        #self.set_modal()
        #try:
        #    self.wm.currentWindow.deactivate()
        #except:
        #    traceback.print_exc()
        #    pass
        self.fld.take_focus()

</t>
<t tx="davidmcnab.041604122248.152">class xapp(pywm.appletBase):
    """
    Generic applet type for generic X applications (eg xbiff, xclock etc)
    """
    def __init__(self, wm, x, y, w, h, cmd, titlematch):
        """
        Creates an applet space for an X application
        
        Args:
         - wm - ref to window manager
         - x, y - position of shellbox
         - w, h - dimensions of shellbox (default 120x40)
         - cmd - shell command line to launch this app
         - titlematch - a regular expression to match for the title bar
        """
        print "shellbox.__init__: entered"
        
        self.wm = wm
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.cmd = cmd
        self.titlematch = re.compile(titlematch)
        self.exists = 0

        # add an onCreate handler to intercept this window's creation
        self.addHandlers(create=self.onCreate)

        # now launch the app
        self.wm.launch(self.cmd)

    def onCreate(self, win):
        """
        Called when x app gets created, and moves/resizes it to the needed size
        and position, strips off the titlebar, and locks it against desktop 
        zoom/pan
        """
        if not self.exists and self.titlematch.match(win.name):
            print "x applet: got window"
            win.setborder('thin')
            win.size(self.w, self.h)
            win.position(self.x, self.y)
            win.lock()
            self.win = win
            self.exists = 1
            return 1 # don't add to task list etc
        return 0
</t>
<t tx="davidmcnab.041604122248.153">@language python

"""
Main module for the PYWM window manager.

PYWM is a window manager based on the FLWM (http://flwm.sf.net)
window manager, but wrapped into an easy to use python class.

Aim of PYWM is to create a python-drivable window manager that's
actually useful and approachable. (I had a look at PLWM, but
found it too arcane and unapproachable. In contrast, PYWM is
actually easy to use and customise, and respects those who like
mouse interaction (while not discriminating against rodent-haters).

Written 2003 and Copyright (C) by David McNab &lt;david@freenet.org.nz&gt;

Underlying FLWM engine written and copyright by Bill Spizak
(http://www.cinenet.net/~spitzak/)
"""

__all__ = ['examples']

@others

</t>
<t tx="davidmcnab.041604122248.154">import sys
import os
import traceback

import flwm_

</t>
<t tx="davidmcnab.041604122248.155">__all__ = [
           'WM',
           'window',
           'Fl_Window',
           'Fl_Button',
           'Fl_Select_Browser',
           'Fl_Hold_Browser',
           'applet',
           ]
</t>
<t tx="davidmcnab.041604122248.156">class window:
    """
    This class wraps an X window in a form where your python
    window manager code can manipulate it.

    You can subclass this, and pass your subclass into your window manager
    constructor. This will cause all created windows to be built with
    your custom window class.    
    """
    @others
</t>
<t tx="davidmcnab.041604122248.157">
moveIncrement = 40 # default for the various move actions
sizeIncrement = 40 # default for the various size actions
</t>
<t tx="davidmcnab.041604122248.158"></t>
<t tx="davidmcnab.041604122248.159"></t>
<t tx="davidmcnab.041604122248.160">def close(self):
    """
    Closes the window
    """    
    #print "window.close: trying to close window"
    flwm_.closeWindow(self.hWin)
    #print "window.close: returned"

</t>
<t tx="davidmcnab.041604122248.161">def raise_(self):
    """
    Raises this window
    """
    #print "window.raise: trying to raise window"
    flwm_.raiseWindow(self.hWin)
    #print "window.raise: returned"

</t>
<t tx="davidmcnab.041604122248.162">def lower(self):
    """
    Lowers this window
    """
    #print "window.lower: trying to lower window"
    flwm_.lowerWindow(self.hWin)
    #print "window.lower: returned"

</t>
<t tx="davidmcnab.041604122248.163">def iconise(self):
    """
    Iconises this window
    """
    #print "window.iconise: trying to iconise window"
    flwm_.iconiseWindow(self.hWin)
    #print "window.iconise: returned"
</t>
<t tx="davidmcnab.041604122248.164">def getname(self):
    """
    Call this to return the current setting of the window's title bar
    """
    #print "window.getname 1"
    name = flwm_.getLabel(self.hWin)
    #print "window.getname 2"
    return name



</t>
<t tx="davidmcnab.041604122248.165">def position(self, x=None, y=None):
    """
    Gets or sets the window position
    
    Call with no arguments to fetch the position as a tuple
    Call with x,y to set the window position
    """
    #print "window.position: entered"
    #return 0, 0
    if x == None:
        #print "window.size: about to call flwm_.getSize"
        x, y = flwm_.getPos(self.hWin)
        #print "window.size: returned from flwm_.getSize"
        return x, y
    else:
        #print "window.position: trying to reposition"
        if y == None:
            raise Exception("Must call with no args, or x,y")
        #print "window.position: about to call flwm_.setPos"
        flwm_.setPos(self.hWin, x, y)
        #print "window.position: returned from flwm_.setPos"



</t>
<t tx="davidmcnab.041604122248.166">def size(self, w=None, h=None):
    """
    Gets or sets the window size
    
    Call with no arguments to fetch the position as a tuple
    Call with x,y to set the window position
    """
    #print "window.size: bailing"
    #return 0, 0
    if w == None:
        #print "window.size: about to call flwm_.getSize"
        x, y = flwm_.getSize(self.hWin)
        #print "window.size: returned from flwm_.getSize"
        return x, y
    else:
        #print "window.size: setting size"
        if h == None:
            raise Exception("Must call with no args, or w,h")
        #print "window.size: about to call flwm_.setSize"
        flwm_.setSize(self.hWin, w, h)
        #print "window.size: returned from flwm_.setSize"

</t>
<t tx="davidmcnab.041604122248.167">def setborder(self, mode='normal'):
    """
    Sets the window border mode.
    
    Argument - mode:
     - if 'normal', sets normal border with titlebar
     - if 'thin', sets thin border - no titlebar
     - if 'none', sets no border or titlebar
    """
    #print "window.setborder: mode=%s" % mode
    if mode == 'none':
        modenum = 2
    elif mode == 'thin':
        modenum = 1
    else:
        modenum = 0
    flwm_.setBorder(self.hWin, modenum)

</t>
<t tx="davidmcnab.041604122248.168">
def hide(self):
    """
    Hides the window off the screen.
    
    Note - this will trigger an 'on_destroy' callback, so watch for this
    in your callback
    """
    # get window as a pointer
    flwm_.hide(self.hWin)

</t>
<t tx="davidmcnab.041604122248.169">def unhide(self):
    """
    UnHides the window back onto the screen.
    
    Note - this will trigger an 'on_create' callback, so watch for this
    in your callback
    """
    flwm_.unhide(self.hWin)
</t>
<t tx="davidmcnab.041604122248.170">def activate(self):
    """
    Brings this window to the top, and makes it the active window
    """
    flwm_.activateWindow(self.hWin)


</t>
<t tx="davidmcnab.041604122248.171">def deactivate(self):
    """
    Brings this window to the top, and makes it the active window
    """
    flwm_.deactivateWindow(self.hWin)


</t>
<t tx="davidmcnab.041604122248.172">def lock(self):
    """
    Calling lock on a window prevents that window from being
    affected by zooming and panning functions
    """
    self.isLocked = True</t>
<t tx="davidmcnab.041604122248.173">def unlock(self):
    """
    Calling unlock on a window makes that window susceptible
    to moving and resizing via zooming and panning functions.
    
    This is the default state when the window gets created.
    """
    self.isLocked = False
</t>
<t tx="davidmcnab.041604122248.174"></t>
<t tx="davidmcnab.041604122248.175">def __init__(self, hWin, wm):
    """
    You should not instantiate windows yourself.
    This constructor gets called when the WM engine detects that a
    window has been created (or a previously known window has been
    restored into view).
    """
    #print "window.__init__: entered, hWin=0x%lx" % hWin
    self.hWin = hWin        # save the ptr for later use
    self.wm = wm            # save back-link to WM object
    #print "window.__init__:2: entered, hWin=0x%lx" % hWin
    self.name = self.getname()           # get titlebar text

    #print "getting screen size"
    self.screenWidth, self.screenHeight = self.getScreenSize()
    #print "got screen size"
    
    self.isMax = False
    self.isMaxWidth = False
    self.isMaxHeight = False

    self.isLocked = False # set to true to exclude from zooming/panning
    self.dead = False
    self.xGranularity = 1
    self.yGranularity = 1

    #print "window.__init__:3"
    #print "window.__init__:name=%s" % self.name


</t>
<t tx="davidmcnab.041604122248.176">def __repr__(self):
    return "&lt;window hWin:0x%lx '%s'&gt;" % (self.hWin, self.name)

</t>
<t tx="davidmcnab.041604122248.177">def getScreenSize(self):
    """
    Returns x, y size of the screen as a tuple
    """
    return flwm_.getScreenSize()
</t>
<t tx="davidmcnab.041604122248.178">def width(self):
    return self.size()[0]
</t>
<t tx="davidmcnab.041604122248.179">def height(self):
    return self.size()[1]
</t>
<t tx="davidmcnab.041604122248.180"></t>
<t tx="davidmcnab.041604122248.181">def moveRel(self, dx=0, dy=0):
    """
    Move the window relative to its present position
    
    Args: dx, dy - if either of these are None, don't move on that axis.
    """
    x, y = self.position()
    self.position(x+dx, y+dy)
</t>
<t tx="davidmcnab.041604122248.182">def moveUp(self, dy=None):
    """
    Moves window up.
    Arg - dy - is amount to move by, defaults to self.moveIncrement
    """
    if not dy:
        dy = self.moveIncrement
    self.moveRel(0, -dy)
</t>
<t tx="davidmcnab.041604122248.183">def moveDown(self, dy=None):
    """
    Moves window down
    Arg - dy - is amount to move by, defaults to self.moveIncrement
    """
    if not dy:
        dy = self.moveIncrement
    self.moveRel(0, dy)
</t>
<t tx="davidmcnab.041604122248.184">def moveLeft(self, dx=None):
    """
    Moves window left.
    Arg - dx - is amount to move by, defaults to self.moveIncrement
    """
    if not dx:
        dx = self.moveIncrement
    self.moveRel(-dx, 0)
</t>
<t tx="davidmcnab.041604122248.185">def moveRight(self, dx=None):
    """
    Moves window right.
    Arg - dx - is amount to move by, defaults to self.moveIncrement
    """
    if not dx:
        dx = self.moveIncrement
    self.moveRel(dx, 0)
</t>
<t tx="davidmcnab.041604122248.186">def goNorth(self):
    """
    Moves the window to the top (north) position
    """
    #print "pywm.window.goNorth: entered"
    w = self.width()
    scrW, scrH = self.getScreenSize()
    self.position((scrW-w)/2, 0)



</t>
<t tx="davidmcnab.041604122248.187">def goNorthEast(self):
    """
    Moves the window to the top right (northeast) position
    """
    #print "pywm.window.goNorthEast: entered"
    w = self.width()
    scrW, scrH = self.getScreenSize()
    self.position(scrW-w, 0)


</t>
<t tx="davidmcnab.041604122248.188">def goEast(self):
    """
    Moves the window to the right (east) position
    """
    #print "pywm.window.goEast: entered"
    w, h = self.width(), self.height()
    scrW, scrH = self.getScreenSize()
    self.position(scrW-w, (scrH-h)/2)

</t>
<t tx="davidmcnab.041604122248.189">def goSouthEast(self):
    """
    Moves the window to the bottom right (southeast) position
    """
    #print "pywm.window.goSouthEast: entered"
    w, h = self.width(), self.height()
    scrW, scrH = self.getScreenSize()
    self.position(scrW-w, scrH-h)

</t>
<t tx="davidmcnab.041604122248.190">def goSouth(self):
    """
    Moves the window to the top (north) position
    """
    #print "pywm.window.goSouth: entered"
    w, h = self.width(), self.height()
    scrW, scrH = self.getScreenSize()
    self.position((scrW-w)/2, scrH-h)

</t>
<t tx="davidmcnab.041604122248.191">def goSouthWest(self):
    """
    Moves the window to the top (north) position
    """
    #print "pywm.window.goSouthWest: entered"
    h = self.height()
    scrW, scrH = self.getScreenSize()
    self.position(0, scrH-h)

</t>
<t tx="davidmcnab.041604122248.192">def goWest(self):
    """
    Moves the window to the top (north) position
    """
    #print "pywm.window.goWest: entered"
    h = self.height()
    scrW, scrH = self.getScreenSize()
    self.position(0, (scrH-h)/2)

                

</t>
<t tx="davidmcnab.041604122248.193">def goNorthWest(self):
    """
    Moves the window to the top (north) position
    """
    #print "pywm.window.goNorthWest: entered"
    self.position(0, 0)

</t>
<t tx="davidmcnab.041604122248.194">def goCentre(self):
    """
    Centre the window on the screen
    """
    #print "pywm.window.goCentre: entered"
    w, h = self.width(), self.height()
    scrW, scrH = self.getScreenSize()
    self.position((scrW-w)/2, (scrH-h)/2)


</t>
<t tx="davidmcnab.041604122248.195">def go(self, direction):
    """
     Arguments:
     - direction - the direction to move. One of:
        - n or north - move to top centre of screen
        - ne or northeast - move to top right of screen
        - e or east - move to centre right of screen
        - se or southeast - move to bottom right of screen
        - s or south - move to bottom centre of screen
        - sw or southwest - move to bottom left of screen
        - w or west - move to centre left of screen
        - nw or northwest - move to top oeft of screen
        - c or centre/center - move to centre of screen
        - up - move up a bit
        - down - move down a bit
        - left - move left a bit
        - right - move right a bit
    """
    direction = direction.lower()
    if direction in ['n', 'north']:
        self.goNorth()
    elif direction in ['ne', 'northeast']:
        self.goNorthEast()
    elif direction in ['e', 'east']:
        self.goEast()
    elif direction in ['se', 'southeast']:
        self.goSouthEast()
    elif direction in ['s', 'south']:
        self.goSouth()
    elif direction in ['sw', 'southwest']:
        self.goSouthWest()
    elif direction in ['w', 'west']:
        self.goWest()
    elif direction in ['nw', 'northwest']:
        self.goNorthWest()
    elif direction in ['c', 'center', 'centre']:
        self.goCentre()
    elif direction in ['u', 'up']:
        self.moveUp()
    elif direction in ['d', 'down']:
        self.moveDown()
    elif direction in ['l', 'left']:
        self.moveLeft()
    elif direction in ['r', 'right']:
        self.moveRight()
    else:
        print "WM.moveCurrent: unknown direction '%s'" % direction

</t>
<t tx="davidmcnab.041604122248.196"></t>
<t tx="davidmcnab.041604122248.197">def toggleMax(self):
    """
    Toggles between existing and maximum size
    """
    #print "pywm.window.toggleMax"
    if self.isMax:
        self.size(self.oldWidth, self.oldHeight)
        self.position(self.oldX, self.oldY)
        self.isMax = False
    else:
        self.oldWidth, self.oldHeight = self.size()
        self.oldX, self.oldY = self.position()
        self.position(0,0)
        self.size(self.screenWidth, self.screenHeight)
        self.isMax = True



</t>
<t tx="davidmcnab.041604122248.198">def toggleMaxWidth(self):
    """
    Toggles the height between current and maximum
    """
    w, h = self.size()
    if self.isMaxWidth:
        self.size(self.oldWidthW, h)
        self.position(self.oldX, self.oldY)
        self.isMaxWidth = False
    else:
        self.oldWidthW, self.oldHeightW = w, h
        self.oldX, self.oldY = self.position()
        self.position(0, self.oldY)
        self.size(self.screenWidth, h)
        self.isMaxWidth = True
</t>
<t tx="davidmcnab.041604122248.199">def toggleMaxHeight(self):
    """
    Toggles the height between current and maximum
    """
    w, h = self.size()
    if self.isMaxHeight:
        self.size(w, self.oldHeightH)
        self.position(self.oldX, self.oldY)
        self.isMaxHeight = False
        
    else:
        self.oldWidthH, self.oldHeightH = w, h
        self.oldX, self.oldY = self.position()
        self.position(self.oldX, 0)
        self.size(w, self.screenHeight)
        self.isMaxHeight = True


</t>
<t tx="davidmcnab.041604122248.200">def resizeRel(self, dw=0, dh=0):
    """
    Resizes window relative to its present size.
    
    Arguments:
     - dw - amount to grow by horizontally - default 0
     - dh - amount to grow by vertically - default 0
    """
    w, h = self.size()
    self.size(w+dw, h+dh)
</t>
<t tx="davidmcnab.041604122248.201">def resize(self, how):
    """
    Resizes the window according to how.
    
    Argument:
     - how - the resize mode:
         - 'taller' - grow vertically
         - 'shorter' - shrink vertically
         - 'wider - grow horizontally
         - 'narrower' - shrink horizontally
         - 'larger' - grow vertically and horizontally
         - 'smaller' - shrink vertically and horizontally
    """

    how = how.lower()
    
    if how in ['taller']:
        self.growBottom()
    elif how in ['shorter']:
        self.shrinkBottom()
    elif how in ['wider']:
        self.growRight()
    elif how in ['narrower']:
        self.shrinkRight()
    elif how in 'larger':
        self.grow()
    elif how in 'smaller':
        self.shrink()

</t>
<t tx="davidmcnab.041604122248.202"></t>
<t tx="davidmcnab.041604122248.203">def grow(self, dw=None, dh=None):
    """
    Grow from the center by dw, dh
    
    Arguments:
     - dw - amount to grow by horizontally, default self.sizeIncrement
     - dh - amount to grow by vertically, default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    if dh == None:
        dh = self.sizeIncrement
    x, y = self.position()
    self.resizeRel(dw, dh)
    self.moveRel(x-dw/2, y-dh/2)
</t>
<t tx="davidmcnab.041604122248.204">def growLeft(self, dw=None):
    """
    Grow to the left by 'dw' pizels. Default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    self.resizeRel(dw, 0)
    self.moveRel(dw, 0)
</t>
<t tx="davidmcnab.041604122248.205">def growRight(self, dw=None):
    """
    Grow to the right by 'dw' pizels. Default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    self.resizeRel(dw, 0)
</t>
<t tx="davidmcnab.041604122248.206">def growTop(self, dh=None):
    """
    Grow from the top by 'dh' pizels. Default self.sizeIncrement
    """
    if dh == None:
        dh = self.sizeIncrement
    self.resizeRel(0, dh)
    self.moveRel(0, dh)
</t>
<t tx="davidmcnab.041604122248.207">def growBottom(self, dh=None):
    """
    Grow from the bottom by 'dh' pizels. Default self.sizeIncrement
    """
    if dh == None:
        dh = self.sizeIncrement
    self.resizeRel(0, dh)
</t>
<t tx="davidmcnab.041604122248.208"></t>
<t tx="davidmcnab.041604122248.209">def shrink(self, dw=None, dh=None):
    """
    Shrink from the center by dw, dh
    
    Arguments:
     - dw - amount to shrink by horizontally, default self.sizeIncrement
     - dh - amount to shrink by vertically, default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    if dh == None:
        dh = self.sizeIncrement
    x, y = self.position()
    self.resizeRel(-dw, -dh)
    self.moveRel(x+dw/2, y+dh/2)

</t>
<t tx="davidmcnab.041604122248.210">def shrinkLeft(self, dw=None):
    """
    Shrink from the left by 'dw' pizels. Default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    self.resizeRel(-dw, 0)
    self.moveRel(-dw, 0)
</t>
<t tx="davidmcnab.041604122248.211">def shrinkRight(self, dw=None):
    """
    Shrink from the right by 'dw' pizels. Default self.sizeIncrement
    """
    if dw == None:
        dw = self.sizeIncrement
    self.resizeRel(-dw, 0)
</t>
<t tx="davidmcnab.041604122248.212">def shrinkTop(self, dh=None):
    """
    Shrink from the top by 'dh' pizels. Default self.sizeIncrement
    """
    if dh == None:
        dh = self.sizeIncrement
    self.resizeRel(0, -dh)
    self.moveRel(0, -dh)
</t>
<t tx="davidmcnab.041604122248.213">def shrinkBottom(self, dh=None):
    """
    Shrink from the bottom by 'dh' pizels. Default self.sizeIncrement
    """
    if dh == None:
        dh = self.sizeIncrement
    self.resizeRel(0, -dh)
</t>
<t tx="davidmcnab.041604122248.214"></t>
<t tx="davidmcnab.041604122248.215">def on_resize(self, x, y, w, h):
    print "WM.on_resize: please override this method"
</t>
<t tx="davidmcnab.041604122248.216">class WM:
    """
    pywm.WM is the main PYWM class that you should subclass when building
    your own custom window manager.

    Encapsulates the Pythonised 'FLWM' window manager for X, into
    a python class.
    
    Subclass this and override methods according to your tastes

    Python components written by David McNab &lt;david@freenet.org.au&gt;
    """

    @others
</t>
<t tx="davidmcnab.041604122248.217">_optionKeywords = {'display': '-d',
                   'visual': '-v',
                   'geometry': '-g',
                   'maximum':'-m',
                   'exit': '-x',
                   'bg': '-bg',
                   'fg': '-fg',
                   'bg2': '-bg2',
                   'cursor': '-c',
                   'cfg': '-cfg',
                   'cbg': '-cbg'
                   }

_options = {}

_keyBindings = {}
_keyBindingsArg = {}

windows = {}

</t>
<t tx="davidmcnab.041604122248.218">def __init__(self, **kwds):
    """
    Constructor.

    Creates an FLWM object.

    Available keywords are:

      - display (host:#.#) X display &amp; screen to use
      - visual  (#) visual to use
      - geometry (WxH+X+Y) limits windows to this area
      - maximum (WxH) size of maximized windows
      - exit - menu says Exit instead of logout
      - bg - (color) Frame color
      - abg - (color) Frame color for active windows
      - fg - (color) Label color
      - bg2 - (color) Text field color
      - cursor - (#) Cursor number for root
      - cfg - (color) Cursor color
      - cbg - (color) Cursor outline color
      - windowclass - class to use when windows get created.
        should be a subclass of pywm.window
    """
    optionKeywords = {'display': '-d',
                      'visual': '-v',
                      'geometry': '-g',
                      'maximum':'-m',
                      'exit': '-x',
                      'bg': '-bg',
                      'abg': '-abg',
                      'fg': '-fg',
                      'bg2': '-bg2',
                      'cursor': '-c',
                      'cfg': '-cfg',
                      'cbg': '-cbg'
                      }

    # Create an empty chain of handlers for various events
    self.hdlrsStartup = []
    self.hdlrsCreate = []
    self.hdlrsDestroy = []
    self.hdlrsActivate = []
    self.hdlrsDeactivate = []
    self.hdlrsKeyEvent = []
    self.hdlrsButtonPress = []
    self.hdlrsResize = []
    self.handlernames = {'startup':self.hdlrsStartup,
                         'create':self.hdlrsCreate,
                         'destroy':self.hdlrsDestroy,
                         'activate':self.hdlrsActivate,
                         'deactivate':self.hdlrsDeactivate,
                         'keyevent':self.hdlrsKeyEvent,
                         'buttonpress':self.hdlrsButtonPress,
                         'resize':self.hdlrsResize,
                         }
    
    # allow caller to substitute a different window class
    if kwds.has_key('windowclass'):
        #print "WM.__init__: kwds has a windowclass"
        windowclass = kwds['windowclass']
        #print "WM.__init__: 1"
        if not issubclass(windowclass, window):
            #print "WM.__init__: 2"
            #print "bad window class"
            raise Exception(
               "windowclass arg must be a subclass of pywm.window")
        #print "WM.__init__: 3"
        self.windowclass = windowclass
        #print "WM.__init__: 4"
        del kwds['windowclass']
        #print "WM.__init__: 5"
    else:
        #print "WM.__init__: using default window class"
        self.windowclass = window

    #self.windowclass = window

    self.options = []
    for arg in optionKeywords:
        if kwds.has_key(arg):
            self.options.append(optionKeywords[arg])
            if arg != 'exit':
                self.options.append(kwds[arg])

    badargs = []
    for arg in kwds:
        if not optionKeywords.has_key(arg):
            badargs.append("'"+arg+"'")
    if len(badargs) &gt; 0:
        raise Exception("Illegal arguments: %s" % ", ".join(badargs))

    self.windows = {}
    self.winindexes = {}
    self.windowlist = []
    self._keyBindings = {}

    self.screenWidth, self.screenHeight = self.getScreenSize()
</t>
<t tx="davidmcnab.041604122248.219">def addHandlers(self, **kwds):
    """
    Add a set of handlers for various events.

    These are given as 'eventname=func' keywords.
    
    Available eventname keywords are:
     - startup - when WM is started:
         - handler receives no arguments
     - create - when a window is created (or unhidden):
         - handler is called with a single window arg
     - destroy - when a window is destroyed (or hidden)
         - handler is called with a single window arg
     - activate - when a window gets activated
         - handler is called with a single window arg
     - deactivate - when a window is deactivated
         - handler is called with a single window arg
     - keyevent - when a keystroke is received:
         - handler is called with keystroke
     - buttonpress - when a mouse button gets clicked:
         - handler is called with button number
     - resize - when a window gets resized:
         - handler is called with window as arg
    """
    for k in kwds.keys():
        if k in self.handlernames:
            if not callable(kwds[k]):
                print "ERROR - %s handler is not callable" % k
                continue
            self.handlernames[k].append(kwds[k])
</t>
<t tx="davidmcnab.041604122248.220"></t>
<t tx="davidmcnab.041604122248.221"></t>
<t tx="davidmcnab.041604122248.222">def on_startup(self):
    """
    Callback which is invoked when WM starts up.
    
    Note that this callback fires *after* all the
    existing windows have been re-framed (and the on_create
    callbacks fired), and *before* the main WM event
    loop starts up.
    
    Override this if you want to do your own processing
    during startup.
    """
    print "WM.on_startup: entered"
</t>
<t tx="davidmcnab.041604122248.223">def on_create(self, win):
    """
    Called when a new window is created (or an existing one un-hidden)
    """
    print "WM.on_create: created window '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.224">def on_destroy(self, win):
    """
    Called when an existing window is being destroyed (or hidden)
    
    If overriding in a subclass, call this parent method just before you exit
    """
    print "WM.on_destroy: destroying '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.225">def on_activate(self, win):
    """
    Called when an existing window is activated
    """
    print "WM.on_activate: activated '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.226">def on_deactivate(self, win):
    """
    Called when an existing window is deactivated
    """
    print "WM.on_deactivate: deactivated '%s'" % win.name
</t>
<t tx="davidmcnab.041604122248.227">def on_keyEvent(self, key):
    """
    Called when a Ctrl-Alt key sequence is received.
    """
    print "wm.on_keyEvent callback: key=%x" % key
    #print self._keyBindings
    if self._keyBindings.has_key(key):
        print "wm.on_keyEvent: known key, launching func"
        func = self._keyBindings[key]
        arg = self._keyBindingsArg[key]
        func(arg)
        #print "wm.on_keyEvent: back from func"
        return 1
    else:
        #print "wm.on_keyEvent: unknown key"
        #print self._keyBindings.keys()
        return 0



</t>
<t tx="davidmcnab.041604122248.228">def on_buttonPress(self, button):
    """
    Called when a button click is received.
    Buttons 1, 2, 3, 4, 5 are left-click, right-click, middle-click,
    wheelscroll up and wheelscroll down, respectively.

    If you override this, you should accept a single argument,
    'button_num', and return 1 if you've handled it locally,
    or 0 if you want the WM to handle it instead.

    NOT YET WORKING
    """
    print "wm.on_buttonPress callback: button %d" % button
    if button == 1:
        print self.getMousePos()
    elif button == 2:
        flwm_.test()
    elif button == 3:
        return 0
    elif button == 4:
        self.goNextWindow()
    elif button == 5:
        self.goPrevWindow()
    else:
        # disable menu except for right-click
        return 1
    return 1
</t>
<t tx="davidmcnab.041604122248.229">def on_resize(self, win, x, y, w, h):
    """
    Called when the size of the window changes.
        
    If overriding, you need to accept the arguments:
      - hWin, x, y, w, h
    where hWin is the python handle for the window
    and x, y, w, h are the new position and size for the window
    """
    label = win.name
    #print "WM.on_destroy: entered"
    print "flwm.WM.on_resize: x=%d y=%d w=%d h=%d name=%s" % (x, y, w, h, label)
    #print "label = '%s'" % label

</t>
<t tx="davidmcnab.041604122248.230">def on_enter(self, win):
    """
    Called when the mouse pointer enters a window
    
    If overriding, just accept a single argument, hWin
    
    NOT YET WORKING
    """
    print "wm.on_enterWindow: entered window %s" % win.name

</t>
<t tx="davidmcnab.041604122248.231">#def on_leave(self, win):
#    """
#    Called when the mouse pointer leaves a window
#    
#    If overriding, just accept a single argument, hWin
#    """
#    print "wm.on_leaveWindow: left window %s" % self.windows[win].name

</t>
<t tx="davidmcnab.041604122248.232"></t>
<t tx="davidmcnab.041604122248.233">def run(self):
    """
    Launch the window manager, and receive events via
    callbacks.
        
    If overriding this in a subclass, don't forget to call this
    parent method.
    """

    flwm_.run(self.options, self)
</t>
<t tx="davidmcnab.041604122248.234">def _addWin(self, hWin):
    """
    Makes a window known to this wm object
    
    Used by the lower level window create event handler.
    Don't call this yourself.
    """
    #print "WM._addWin 1: hWin=0x%lx" % hWin
    #print dir(self)
    #print type(self.windowclass)
    #print "WM._addWin 2"
    #print self.windowclass.__class__

    win = self.windowclass(hWin, self)
    #win = window(hWin)

    #print "WM._addWin 3"
    self.windows[hWin] = win
    self.windowlist.append(win)
    self.currentWindow = win
    return win


</t>
<t tx="davidmcnab.041604122248.235">def _delWin(self, hWin):
    """
    Deletes a window's mapping from our dict.
    
    Called by underlying handler of window delete events.
    
    Don't call this yourself
    """
    #print "WM._delWin: entered"
    if self.windows.has_key(hWin):
        win = self.windows[hWin]
        print "wm._delWin: destroyed '%s'" % win.name
        win.dead = True
        #del self.windows[win]
        try:
            i = self.indexFromWindow(win)
            if i &gt;= 0:
                del self.windowlist[i]
        except:
            print "oops!"
    else:
        print "WM._delWin destroying unknown window??!?"
    print "WM._delWin: finished"
</t>
<t tx="davidmcnab.041604122248.236">def window(self, hWin):
    """
    Maps a window handle to a window object.
    
    You should never need to call this yourself
    """
    return self.windows[hWin]
</t>
<t tx="davidmcnab.041604122248.237">def launch(self, cmd):
    """
    Launch a new window in a separate process
    
    Arguments:
     - cmd - a command to run in the shell to create the window.
       Syntax of this is anything acceptable to os.system().
    
    If you want that command to run inside a terminal window, then
    modify your command to invoke your favourite X terminal prog
    """
    #print "WM.launch - wnating to run '%s'" % cmd
    #print "WM.launch: bailing"
    #return
    return os.system(cmd + " &amp;")
</t>
<t tx="davidmcnab.041604122248.238">def getMousePos(self, arg=None):
    """
    Returns the current x, y coordinates of the mouse as a tuple
    """
    return flwm_.getMousePos()

</t>
<t tx="davidmcnab.041604122248.239">def getScreenSize(self, arg=None):
    """
    Returns x, y size of the screen as a tuple
    """
    return flwm_.getScreenSize()
</t>
<t tx="davidmcnab.041604122248.240">def bindKey(self, func, arg, key, shift, control, alt, meta):
    """
    Allows you to bind a Ctrl-Alt key combo to a function

    Arguments:
     - func - function to call when key gets pressed
     - arg - an argument to pass to the function. Can be a number,
       string, list, tuple, dict or anything you like.
     - key - key to bind - either:
         - a single character
         - one of 'f1'..'f12'
         - one of 'kp0'..'kp9', or 'kpenter'
         - one of 'enter', 'tab', 'backspace', 'intert', 'delete', 'home',
           'end', 'pageup', 'pagedown', 'up', 'down', 'left', 'right'
     - shift - whether shift key is added - 0 or 1
     - control - whether control key is added - 0 or 1
     - alt - whether alt key is added - 0 or 1
     - meta - whether meta key is added - 0 or 1
    
    When the key combination gets pressed, the function you give
    will get called with the argument you give.

    If you find it hard to remember the 'shift'/'control'/'alt'/'meta' order,
    just think 'history' - the Shift key was the first to be added (in
    typewriters), then Ctrl (with ASCII), then Alt (with the IBM PC), then
    Meta (contributed by Microsoft with Windows).
    """
    #print "WM.bindKey: entered"
    keycode = flwm_.keyCode(key, shift, control, alt, meta)
    if keycode == 0:
        print "WM.bindKey: invalid key name '%s'" % key
        return
    print "WM.bindKey: numeric key code for %s(%s,%s,%s,%s) is 0x%lx" % (
            key, shift, control, alt, meta, keycode)
    self._keyBindings[keycode] = func
    self._keyBindingsArg[keycode] = arg
    #print "WM.bindKey: added binding"
    flwm_.bindKey(keycode)
    #print "WM.bindKey: returned from flwm_bind_key"
    #print self._keyBindings.keys()


</t>
<t tx="davidmcnab.041604122248.241">def goNextWindow(self, arg=None):
    """
    Switches to next window
    """
    flwm_.goNextWindow()
</t>
<t tx="davidmcnab.041604122248.242">def goPrevWindow(self, arg=None):
    """
    Switches to previous window
    """
    flwm_.goPrevWindow()
</t>
<t tx="davidmcnab.041604122248.243">def goNextDesk(self, arg=None):
    """
    Switches to next desk
    """
    flwm_.goNextDesk()
</t>
<t tx="davidmcnab.041604122248.244">def goPrevDesk(self, arg=None):
    """
    Switches to previous desk
    """
    flwm_.goPrevDesk()
</t>
<t tx="davidmcnab.041604122248.245">def showMenu(self, arg=None):
    """
    Pops up the main window manager menu
    """
    print "WM.showMenu: trying to launch menu"
    flwm_.showMenu()
</t>
<t tx="davidmcnab.041604122248.246">def moveCurrent(self, direction):
    """
    Moves the current window in the specified direction.
    
    Arguments:
     - direction - the direction to move. One of:
        - n or north - move to top centre of screen
        - ne or northeast - move to top right of screen
        - e or east - move to centre right of screen
        - se or southeast - move to bottom right of screen
        - s or south - move to bottom centre of screen
        - sw or southwest - move to bottom left of screen
        - w or west - move to centre left of screen
        - nw or northwest - move to top oeft of screen
        - c or centre/center - move to centre of screen
        - up - move up a bit
        - down - move down a bit
        - left - move left a bit
        - right - move right a bit
    """

    if self.currentWindow:
        self.currentWindow.go(direction)
</t>
<t tx="davidmcnab.041604122248.247">def resizeCurrent(self, how):
    """
    Moves the current window in the specified direction.
    
    Arguments:
     - how - the resize mode:
         - 'taller' - grow vertically
         - 'shorter' - shrink vertically
         - 'wider - grow horizontally
         - 'narrower' - shrink horizontally
         - 'larger' - grow vertically and horizontally
         - 'smaller' - shrink vertically and horizontally
    """

    if self.currentWindow:
        self.currentWindow.resize(how)
</t>
<t tx="davidmcnab.041604122248.248">def closeCurrent(self, arg=None):
    """
    Closes current window
    """
    if self.currentWindow:
        self.currentWindow.close()
</t>
<t tx="davidmcnab.041604122248.249">def toggleMaxCurrent(self, arg=None):
    """
    Toggles maximise on the current window
    """
    print "WM.toggleMaxCurrent"
    if self.currentWindow:
        self.currentWindow.toggleMax()

</t>
<t tx="davidmcnab.041604122248.250">def toggleMaxWidthCurrent(self, arg=None):
    """
    Toggles maximise on the current window
    """
    print "WM.toggleMaxCurrent"
    if self.currentWindow:
        self.currentWindow.toggleMaxWidth()

</t>
<t tx="davidmcnab.041604122248.251">def toggleMaxHeightCurrent(self, arg=None):
    """
    Toggles maximise on the current window
    """
    print "WM.toggleMaxCurrent"
    if self.currentWindow:
        self.currentWindow.toggleMaxHeight()

</t>
<t tx="davidmcnab.041604122248.252">def cascadeWindows(self, spacing=30):
    """
    Arranges all the windows cascaded from top left.
    """
    offset = 0
    try:
        for win in self.windows.values():
            if win.isLocked:
                continue
            win.position(offset, offset)
            win.raise_()
            win.activate()
            offset += spacing
        for win in self.windows.values():
            if win.isLocked:
                win.raise_()
    except:
        print "WM.cascadeWindows: got an exception"
</t>
<t tx="davidmcnab.041604122248.253">def zoom(self, factor=1, xView=None, yView=None):
    """
    Zooms in or out by a given factor.
    
    Arguments:
     - factor = float - &gt;1 to zoom in, &lt;1 to zoom out
     - xView, yView - x,y origin to use for the zooming, defaults to centre of screen
    """
    #print "WM.zoom: entered"
    if xView == None:
        xView = self.screenWidth / 2
    if yView == None:
        yView = self.screenHeight / 2
    #print "WM.zoom: xView,yView = (%d, %d), factor=%s" % (xView, yView, factor)
    #print self.windows
    try:
        for win in self.windows.values():
            if win.dead or win.isLocked:
                continue
            #print "window '%s'" % win.name
            x0, y0 = win.position()
            w, h = win.size()
            #print "WM.zoom: 2"
            txt = "(%d,%d)(%d x %d)" % (x0, y0, w, h)
            #print "WM.zoom:", txt
            x1, y1 = x0+w, y0+h
            #print "WM.zoom: 4"
            x0 = int(factor * float(x0 - xView) + xView)
            x1 = int(factor * float(x1 - xView) + xView)
            y0 = int(factor * float(y0 - yView) + yView)
            y1 = int(factor * float(y1 - yView) + yView)
            #print "x0=%d, y0=%d, x1=%d, y1=%d" % (x0,y0,x1,y1)
            #print txt, ("=&gt; (%d, %d)(%d x %d)" % (x0, y0, x1-x0, y1-y0))
            w, h = x1 - x0, y1 - y0
            if win.xGranularity &gt; 1:
                gran = win.xGranularity
                if w % gran &gt;= gran / 2:
                    w += gran
            if win.yGranularity &gt; 1:
                gran = win.yGranularity
                if h % gran &gt;= gran / 2:
                    h += gran
            win.size(w, h)
            win.position(x0, y0)
    except:
        print "WM.pan: got an exception"
    try:
        for win in self.windows.values():
            if win.isLocked and not win.dead:
                win.raise_()
    except:
        print "WM.zoom: got an exception"
    #print "WM.zoom: finished"


</t>
<t tx="davidmcnab.041604122248.254">def zoomIn(self, factor=1.1, fromMouse=False):
    """
    Zooms in to the current view.
    
    Arguments:
     - factor - amount to zoom by, default 1.1
     - fromMouse - whether to use themouse position as the viewpoint - if
       False (default), uses centre of screen as view point
    """
    #print "WM.zoomIn: entered"
    if fromMouse:
        self.zoom(factor, *self.getMousePos())
    else:
        self.zoom(factor)
</t>
<t tx="davidmcnab.041604122248.255">def zoomInMouse(self, factor=1.1):
    """
    Zooms in to the current view, relative to mouse position
    
    Arguments:
     - factor - amount to zoom by, default 1.1
    """
    print "WM.zoomInMouse: entered"
    self.zoom(factor, *self.getMousePos())


</t>
<t tx="davidmcnab.041604122248.256">def zoomOut(self, factor=0.88, fromMouse=False):
    """
    Zooms out from the current view.
    
    Arguments:
     - factor - amount to zoom by, default 0.88
     - fromMouse - whether to use themouse position as the viewpoint - if
       False (default), uses centre of screen as view point
    """
    #print "WM.zoomOut: entered"
    if fromMouse:
        self.zoom(factor, *self.getMousePos())
    else:
        self.zoom(factor)

</t>
<t tx="davidmcnab.041604122248.257">def zoomOutMouse(self, factor=0.88):
    """
    Zooms out from the current view, relative to mouse position
    
    Arguments:
     - factor - amount to zoom by, default 0.88
    """
    #print "WM.zoomIn: entered"
    self.zoom(factor, *self.getMousePos())

</t>
<t tx="davidmcnab.041604122248.258">def pan(self, dx=None, dy=None):
    """
    Pans all the windows on the screen
    
    Arguments:
     - dx, dy - x,y offset for panning.
       default is to pan the windows such that the mouse position is used
       as the screen's new central point
    """
    #print "WM.pan: entered"
    xMouse, yMouse = self.getMousePos()
    if dx == None:
        dx = self.screenWidth / 2 - xMouse
    if dy == None:
        dy = self.screenHeight / 2 - yMouse

	try:
        for win in self.windows.values():
            if win.dead or win.isLocked:
                continue
            x, y = win.position()
            win.position(x+dx, y+dy)
    except:
        print "WM.pan: got an exception"
    try:
        for win in self.windows.values():
            if win.isLocked and not win.dead:
                win.raise_()
    except:
        print "WM.pan: got an exception"
    #print "WM.pan: finished"



</t>
<t tx="davidmcnab.041604122248.259">def panLeft(self, amount=30):
    """
    Pans all the windows on the screen to the left
    
    Arguments:
     - amount - number of pixels to pan, default 30
    """
    #print "WM.panLeft: entered"
    self.pan(amount, 0)
    #print "WM.panLeft: finished"
</t>
<t tx="davidmcnab.041604122248.260">def panRight(self, amount=30):
    """
    Pans all the windows on the screen to the right
    
    Arguments:
     - amount - number of pixels to pan, default 30
    """
    #print "WM.panRight: entered"
    self.pan(-amount, 0)
    #print "WM.panRight: finished"



</t>
<t tx="davidmcnab.041604122248.261">def panUp(self, amount=30):
    """
    Pans all the windows on the screen upwards
    
    Arguments:
     - amount - number of pixels to pan, default 30
    """
    #print "WM.panUp: entered"
    self.pan(0, amount)
    #print "WM.panUp: finished"



</t>
<t tx="davidmcnab.041604122248.262">def panDown(self, amount=30):
    """
    Pans all the windows on the screen downwards
    
    Arguments:
     - amount - number of pixels to pan, default 30
    """
    #print "WM.panDown: entered"
    self.pan(0, -amount)
    #print "WM.panDown: finished"

</t>
<t tx="davidmcnab.041604122248.263">def windowFromIndex(self, idx):
    """
    Returns a ref to the window with index idx in the creation order
    """
    return self.windowlist[idx]
</t>
<t tx="davidmcnab.041604122248.264">def indexFromWindow(self, win):
    """
    Returns the index of win in the window creation order,
    or -1 if there (oops) is no such window.
    """
    i = 0
    while i &lt; len(self.windowlist):
        if win.hWin == self.windowlist[i].hWin:
            return i
        i += 1
    return -1</t>
<t tx="davidmcnab.041604122248.265">def setTimer(secs, func):
    """
    Sets a timer to call function 'func' after 'secs' seconds
    """
    #print "flwm.setTimer: setting timer"
    flwm_.setTimer(secs, func)
    #print "flwm.setTimer: done"

</t>
<t tx="davidmcnab.041604122248.266">def repeatTimer(secs, func):
    """
    Call this within a timer callback, to schedule another timer event
    """
    #print "flwm.repeatTimer: setting timer"
    flwm_.repeatTimer(secs, func)
    #print "flwm.repeatTimer: done"

</t>
<t tx="davidmcnab.041604122248.267">class Fl_Window:
    """
    This class allows you to create popup windows for user
    interaction.
    
    The windows are created/managed by the FLTK graphical toolkit
    (which the FLWM engine uses), and are not managed as application
    windows (meaning - no border, no window handle etc).
    
    The python interface to Fl_Window is a close subset of the
    FLTK Fl_Window class (refer to your FLTK manual - http://fltk.sf.net
    if you don't have it locally).
    """
    def __init__(self, x, y, w, h, label=""):
        """
        Creates a new window manager popup window.
        
        Arguments:
         - x, y, w, h - x-position, y-position, width and height
         - label - probably no point to this since there's no titlebar
        """
        print "Fl_Window: entered"
        on_enter = self.on_enter
        on_click = self.on_click
        print "about to create fl window"
        self.wid = flwm_.Fl_Window_create(x, y, w, h, label,
                                          self, on_enter, on_click)

    def on_enter(self, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept 2 args, x and y,
        which will be the position of the mouse on entry.
        """
        print "Fl_Window.on_enter: mouse at %d,%d" % (x, y)

    def on_click(self, but, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept three args,
        but, x and y, which will be the button number, and
        the position of the mouse on entry.
        """
        print "Fl_Window.on_click: button %d, mouse at %d,%d" % (but, x, y)

    def end(self, arg=None):
        """
        End a window's definition phase. Call this after all widgets
        have been added to the window
        """
        flwm_.Fl_Window_end(self.wid)

    def show(self, arg=None):
        """
        Make the window visible
        """
        flwm_.Fl_Window_show(self.wid)

    def activate(self):
        """
        Tries to activate this window and make it receive events
        """
        flwm_.Fl_Window_activate(self.wid)

    def set_modal(self):
        """
        Tries to activate this window and make it receive events
        """
        flwm_.Fl_Window_set_modal(self.wid)

    def hide(self, arg=None):
        """
        Hide the window
        """
        
        #print "Fl_Window_hide??"
        flwm_.Fl_Window_hide(self.wid)

    def move(self, x, y):
        """
        Move the window to x, y
        """
        flwm_.Fl_Window_move(self.wid, x, y)

    def stayOnTop(self):
        """
        Bring the window to the top where it will hopefully stay.
        """
        flwm_.Fl_Window_stayOnTop(self.wid)


</t>
<t tx="davidmcnab.041604122248.268">class Fl_Button:
    """
    Creates and manages button widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the button
        """
        self.wid = flwm_.Fl_Button_create(x, y, w, h, label)
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Button_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Button_hide(self.wid)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when the button gets pushed. Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Button_callback(self.wid, func)

    def symbollabel(self):
        """
        Sets the label to diaplay as an FLTK symbol
        """
        flwm_.Fl_Button_symbollabel(self.wid)
</t>
<t tx="davidmcnab.041604122248.269">class Fl_Repeat_Button:
    """
    Creates and manages button widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a repeat button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the button
        """
        self.wid = flwm_.Fl_Repeat_Button_create(x, y, w, h, label)
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Repeat_Button_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Repeat_Button_hide(self.wid)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed
        or while it's held
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when the button gets pushed. Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Repeat_Button_callback(self.wid, func)

    def symbollabel(self):
        """
        Sets the label to diaplay as an FLTK symbol
        """
        flwm_.Fl_Repeat_Button_symbollabel(self.wid)

</t>
<t tx="davidmcnab.041604122248.270">class Fl_Select_Browser:
    """
    Creates and manages listbox widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the browser label
        """
        self.wid = flwm_.Fl_Select_Browser_create(x, y, w, h, label)
        self.items = []
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Select_Browser_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Select_Browser_hide(self.wid)

    def add(self, item):
        """
        Adds a string to the end of the list
        """
        flwm_.Fl_Select_Browser_add(self.wid, item)
        self.items.append(item)

    def remove(self, item):
        """
        Removes an item (index) from the end of the list
        """
        flwm_.Fl_Select_Browser_remove(self.wid, itemindex)
        del self.items[itemindex]

    def clear(self):
        """
        Removes all items from list
        """
        flwm_.Fl_Select_Browser_clear(self.wid)
        self.items = []

    def find(self, itemstr):
        i = 0
        while i &lt; len(self.items):
            if self.items[i] == itemstr:
                return i + 1
            i += 1
        return -1
            
    def itemtext(self, itemidx):
        """
        Returns the text of the given item index
        """
        return self.items[itemidx - 1]

    def color(self, colornum):
        """
        Sets the background colour in the select browser widget
        """
        flwm_.Fl_Select_Browser_color(self.wid, color(colornum))

    def textcolor(self, colornum):
        """
        Sets the colour of text in the select browser widget
        """
        flwm_.Fl_Select_Browser_textcolor(self.wid, color(colornum))

    def selectioncolor(self, colornum):
        """
        Sets the colour of selections in the select browser widget
        """
        fcolor = color(colornum)

        #print "Fl_Select_Browser.selectioncolor: %s -&gt; %s" % (colornum, fcolor)
        
        flwm_.Fl_Select_Browser_selectioncolor(self.wid, color(colornum))

    def value(self, val=None):
        """
        Gets or sets the value selected. Value is an index into the
        list of displayed values
        """
        #print "Fl_Select_Browser: entered"
        if val == None:
            #print "fetching value"
            return flwm_.Fl_Select_Browser_value(self.wid)
        else:
            #print "setting value to %s" % val
            return flwm_.Fl_Select_Browser_value(self.wid, val)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when an item in the listbox gets selected.
           Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Select_Browser_callback(self.wid, func)



</t>
<t tx="davidmcnab.041604122248.271">class Fl_Hold_Browser:
    """
    Creates and manages listbox widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the browser label
        """
        self.wid = flwm_.Fl_Hold_Browser_create(x, y, w, h, label)
        self.items = []
        
    def show(self):
        """probably not much point to this
        """
        flwm_.Fl_Hold_Browser_show(self.wid)
        
    def hide(self):
        """
        probably not much point to this either
        """
        flwm_.Fl_Hold_Browser_hide(self.wid)

    def add(self, item):
        """
        Adds a string to the end of the list
        """
        flwm_.Fl_Hold_Browser_add(self.wid, item)
        self.items.append(item)

    def remove(self, item):
        """
        Removes an item (index) from the end of the list
        """
        flwm_.Fl_Hold_Browser_remove(self.wid, item)
        del self.items[itemindex]

    def clear(self):
        """
        Removes all items from list
        """
        print "Fl_Hold_Browser.clear: entered"
        flwm_.Fl_Hold_Browser_clear(self.wid)
        self.items = []

    def find(self, itemstr):
        i = 0
        while i &lt; len(self.items):
            if self.items[i] == itemstr:
                return i + 1
            i += 1
        return -1

    def itemtext(self, itemidx):
        """
        Returns the text of the given item index
        """
        return self.items[itemidx - 1]

    def color(self, colornum):
        """
        Sets the background colour in the Hold browser widget
        """
        flwm_.Fl_Hold_Browser_color(self.wid, color(colornum))

    def textcolor(self, colornum):
        """
        Sets the colour of text in the Hold browser widget
        """
        flwm_.Fl_Hold_Browser_textcolor(self.wid, color(colornum))

    def selectioncolor(self, colornum):
        """
        Sets the colour of selections in the Hold browser widget
        """
        fcolor = color(colornum)

        #print "Fl_Hold_Browser.selectioncolor: %s -&gt; %s" % (colornum, fcolor)
        
        flwm_.Fl_Hold_Browser_selectioncolor(self.wid, color(colornum))

    def value(self, val=None):
        """
        Gets or sets the value selected. Value is an index into the
        list of displayed values
        """
        #print "Fl_Hold_Browser: entered"
        if val == None:
            #print "fetching value"
            return flwm_.Fl_Hold_Browser_value(self.wid)
        else:
            #print "setting value to %s" % val
            return flwm_.Fl_Hold_Browser_value(self.wid, val)

    def callback(self, func):
        """
        Sets the callback to be triggered when the button gets pushed.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when an item in the listbox gets selected.
           Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Hold_Browser_callback(self.wid, func)


</t>
<t tx="davidmcnab.041604122248.272">class Fl_Input:
    """
    Creates and manages listbox widgets for use in Fl_Window popup
    windows.
    """
    def __init__(self, x, y, w, h, label):
        """
        Creates a button widget.
        
        Arguments:
         - x, y, w, h - x and y-position within window, width and height
         - label - text to put on the browser label
        """
        self.wid = flwm_.Fl_Input_create(x, y, w, h, label)

    def color(self, colornum):
        """
        Sets the background colour in the input widget
        """
        flwm_.Fl_Input_color(self.wid, color(colornum))

    def textcolor(self, colornum):
        """
        Sets the colour of text in the input widget
        """
        flwm_.Fl_Input_textcolor(self.wid, color(colornum))

    def selectioncolor(self, colornum):
        """
        Sets the colour of selections in the input widget
        """
        fcolor = color(colornum)

        #print "Fl_Input.selectioncolor: %s -&gt; %s" % (colornum, fcolor)
        
        flwm_.Fl_Input_selectioncolor(self.wid, color(colornum))

    def callback(self, func):
        """
        Sets the callback to be triggered when user presses ENTER.
        
        Argument:
         - func - a callable object, eg function, bound method, to be
           invoked when the user presses ENTER.
           Note that at this stage,
           the callable you provide will be called with no arguments.
        """
        flwm_.Fl_Input_callback(self.wid, func)

    def value(self, txt=None):
        """
        Gets or sets the displayed text
        
        Arguments:
         - txt - if provided, sets the field to display this.
           If not provided, does not change the field
        
        Returns:
         - Always returns the text in the field
        """
        #print "pywm.Fl_Input.value: entered"
        return flwm_.Fl_Input_value(self.wid, txt)

    def take_focus(self):
        """
        Causes the input field to take focus
        """
        flwm_.Fl_Input_take_focus(self.wid)
</t>
<t tx="davidmcnab.041604122248.273">class appletBase(Fl_Window):
    """
    Base class for applet windows
    
    The applet should register its callbacks as handlers
    by calling self.addHandlers()
    """
    
    def __init__(self, wm, x, y, w, h):
        """
        Creates an applet window.
        
        Arguments:
          - wm - ref to the window manager
          - x, y - location of applet on screen
          - w, h - size of applet window
        """
        print "pywm.applet.__init__: entered: x=%d y=%d w=%d h=%d" % (
            x, y, w, h)
        self.wm = wm
        print "pywm.applet.__init__: got wm"
        Fl_Window.__init__(self, x, y, w, h, "&lt;applet&gt;")
        self.hide()

    def addHandlers(self, **handlers):
        """
        Adds a set of handlers for various events
        
        handlers are declared as keywords.
        See doc for WM.addHandlers for details
        """
        self.wm.addHandlers(**handlers)


</t>
<t tx="davidmcnab.041604122248.274">class appletBar:
    """
    A virtual container for applets.
    
    Alloes applets to be added sequentially, and manages
    the sizing and placement of these applets
    """
    
    def __init__(self, wm, x, y, thickness, direction):
        """
        Creates an applet bar, to which applets can be added
        
        Arguments:
         - wm - ref to window manager
         - x, y - origin of applet bar on screen
         - thickness - thickness of applet bar in pixels
         - direction - 'up', 'down', 'left', 'right' - direction in which
           applets get added
        """
        self.wm = wm
        self.x = x
        self.y = y
        self.xNext = x
        self.yNext = y
        self.thickness = thickness
        self.direction = direction
        self.applets = []

    def add(self, appletclass, length, *args, **kw):
        """
        Adds an applet to the virtual applet bar
        
        Arguments:
         - appletclass - one of the classes in pywm.applets
         - thickness - if applet bar is vertical, this is height. Otherwise,
           this is width.
         - any other applet-dependent args, also keywords
        """
        print "appletBar.add: args=", args
        try:
            if self.direction == 'down':
                x = self.x
                y = self.yNext
                w = self.thickness
                h = length
                self.yNext = self.yNext + length
            elif self.direction == 'up':
                x = self.x
                y = self.yNext - length
                w = self.thickness
                h = length
                self.yNext = y
            elif self.direction == 'right':
                x = self.xNext
                y = self.y
                w = length
                h = self.thickness
                self.xNext = self.xNext + length
            elif self.direction == 'left':
                x = self.xNext - self.length
                y = self.y
                w = length
                h = self.thickness
                self.xNext = self.xNext - length
            appletInst = appletclass(self.wm, x, y, w, h, *args, **kw)
            if appletInst:
                self.applets.append(appletInst)
        except:
            print "pywm.appletBar.add: error adding applet"
            traceback.print_exc()

</t>
<t tx="davidmcnab.041604122248.275">colornames = {'red':'#ff0000',
               'green':'#00ff00',
               'blue':'#0000ff',
               'yellow':'#ffff00',
               'purple':'#ff00ff',
               'white':'#ffffff',
               'black':'000000',
               }

def color(spec):
    if colornames.has_key(spec):
        spec = colornames[spec]
    
    if spec[0] != '#' or len(spec) != 7:
        #print "illegal color spec: '%s'" % spec
        return 0
    red = int(spec[1:3], 16)
    green = int(spec[3:5], 16)
    blue = int(spec[5:7], 16)

    col = flwm_.color(red, green, blue)
    #print "pywm.color: %s =&gt; %x" % (spec, col)
    return col

</t>
<t tx="davidmcnab.041604122248.276">"""
flwm_ is a low-level Pyrex-generated module which talks to
the FLWM engine, setting config items, receiving callbacks
and taking actions.

You should never have reason to access anything in this
module directly - instead, use the default pywm.WM and
pywm.window methods.
"""
@others
</t>
<t tx="davidmcnab.041604122248.277">@others
</t>
<t tx="davidmcnab.041604122248.278">@others
</t>
<t tx="davidmcnab.041604122248.279">cdef extern from "string.h":

    cdef void *memset(void *s, int c, int n)
    cdef void *memcpy(void *dest, void *src, int n)

</t>
<t tx="davidmcnab.041604122248.280">cdef extern from "stdio.h":
    int printf(char *format,...)

</t>
<t tx="davidmcnab.041604122248.281">cdef extern from "stdlib.h":
    void *malloc(int size)
    void *realloc(void *ptr, int size)
    void free(void *ptr)

</t>
<t tx="davidmcnab.041604122248.282">cdef extern from "math.h":
    double fabs(double x)

</t>
<t tx="davidmcnab.041604122248.283">cdef extern from "X11/X.h":
    cdef enum XEventConstants:
        KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify,
        EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify,
        Expose, GraphicsExpose, NoExpose, VisibilityNotify,
        CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest,
        ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify,
        ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify,
        SelectionClear, SelectionRequest, SelectionNotify, ColormapNotify,
        ClientMessage, MappingNotify, LASTEvent

    cdef void Xfree(char *pre)

    ctypedef unsigned long Window
    ctypedef unsigned long Display

    cdef int XQueryPointer( Display *display,
                            Window w,
                            Window *root_return,
                            Window *child_return,
                            int *root_x_return,
                            int *root_y_return,
                            int *win_x_return,
                            int *win_y_return,
                            unsigned int *mask_return
                            )

cdef extern from "X11/keysym.h":
    cdef enum Xkeyconstants:
        XK_a
        XK_b
        XK_c
        XK_d
        XK_e
        XK_f
        XK_g
        XK_h
        XK_i
        XK_j
        XK_k
        XK_l
        XK_m
        XK_n
        XK_o
        XK_p
        XK_q
        XK_r
        XK_s
        XK_t
        XK_u
        XK_v
        XK_w
        XK_x
        XK_y
        XK_z
        XK_0
        XK_1
        XK_2
        XK_3
        XK_4
        XK_5
        XK_6
        XK_7
        XK_8
        XK_9
</t>
<t tx="davidmcnab.041604122248.284">@others
</t>
<t tx="davidmcnab.041604122248.285"># Python-specific imports

cdef extern from "Python.h":
    object PyString_FromStringAndSize(char *, int)
    object PyString_FromString(char *)
    char* PyString_AsString(object string)
    object PyLong_FromLong(long v)
    unsigned long PyLong_AsLong(object pylong)
    object PyInt_FromLong(long v)
    unsigned long PyInt_AsLong(object pylong)
    double PyFloat_AsDouble(object pyFloat)
</t>
<t tx="davidmcnab.041604122248.286">cdef extern int flwm_main(int argc, char **argv, object wmobj)
cdef extern void flwm_closeWindow(long hWin)
cdef extern void flwm_activateWindow(long hWin)
cdef extern void flwm_deactivateWindow(long hWin)
cdef extern void flwm_raiseWindow(long hWin)
cdef extern char *flwm_getLabel(long hWin)
cdef extern int flwm_getPos(long hWin, int *x, int *y)
cdef extern void flwm_getSize(long hWin, int *w, int *h)
cdef extern void flwm_setBorder(long hWin, int mode)
cdef extern void flwm_setPos(long hWin, long x, long y)
cdef extern void flwm_setSize(long hWin, long w, long h)
cdef extern void flwm_getMousePos(int *x, int *y)
cdef extern void flwm_getScreenSize(int *x, int *y)

cdef extern long flwm_keyCode(char *keystr,
                              int shift, int ctrl, int alt, int meta)
cdef extern void flwm_bindKey(long key)

cdef extern void flwm_goNextWindow()
cdef extern void flwm_goPrevWindow()
cdef extern void flwm_goNextDesktop()
cdef extern void flwm_goPrevDesktop()

cdef extern void flwm_showMenu()

cdef extern void flwm_test()

cdef extern void flwm_setTimer(double secs, object func)
cdef extern void flwm_repeatTimer(double secs, object func)
</t>
<t tx="davidmcnab.041604122248.287"></t>
<t tx="davidmcnab.041604122248.288">class Fl_Window:
    """
    This class allows you to create popup windows for user
    interaction.
    
    The windows are created/managed by the FLTK graphical toolkit
    (which the FLWM engine uses), and are not managed as application
    windows (meaning - no border, no window handle etc).
    
    The python interface to Fl_Window is a close subset of the
    FLTK Fl_Window class (refer to your FLTK manual - http://fltk.sf.net
    if you don't have it locally).
    """
    def __init__(self, x, y, w, h, label=""):
        """
        Creates a new window manager popup window.
        
        Arguments:
         - x, y, w, h - x-position, y-position, width and height
         - label - probably no point to this since there's no titlebar
        """
        print "Fl_Window: entered"
        on_enter = self.on_enter
        on_click = self.on_click
        print "about to create fl window"
        self.wid = flwm_.Fl_Window_create(x, y, w, h, label,
                                          self, on_enter, on_click)

    def on_enter(self, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept 2 args, x and y,
        which will be the position of the mouse on entry.
        """
        print "Fl_Window.on_enter: mouse at %d,%d" % (x, y)

    def on_click(self, but, x, y):
        """
        Called when the mouse enters this window.
        If you override this, you must accept three args,
        but, x and y, which will be the button number, and
        the position of the mouse on entry.
        """
        print "Fl_Window.on_click: button %d, mouse at %d,%d" % (but, x, y)

    def end(self, arg=None):
        """
        End a window's definition phase. Call this after all widgets
        have been added to the window
        """
        flwm_.Fl_Window_end(self.wid)

    def show(self, arg=None):
        """
        Make the window visible
        """
        flwm_.Fl_Window_show(self.wid)

    def hide(self, arg=None):
        """
        Hide the window
        """
        
        #print "Fl_Window_hide??"
        flwm_.Fl_Window_hide(self.wid)

    def move(self, x, y):
        """
        Move the window to x, y
        """
        flwm_.Fl_Window_move(self.wid, x, y)

    def stayOnTop(self):
        """
        Bring the window to the top where it will hopefully stay.
        """
        flwm_.Fl_Window_stayOnTop(self.wid)


</t>
<t tx="davidmcnab.041604122248.289"># Import the C shims for FLTK funcs

cdef extern long fltk_window_create(int x, int y, int w, int h, char *label,
                                    object self, object onenter, object onclick)
cdef extern void fltk_window_destroy(long pWin)
cdef extern void fltk_window_end(long pWin)
cdef extern void fltk_window_show(long pWin)
cdef extern void fltk_window_hide(long pWin)
cdef extern void fltk_window_activate(long pWin)
cdef extern void fltk_window_set_modal(long pWin)
cdef extern void fltk_window_move(long pWin, long x, long y)
cdef extern void fltk_window_stayOnTop(long pWin)

cdef extern long fltk_button_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_button_destroy(long pWin)
cdef extern void fltk_button_show(long pWin)
cdef extern void fltk_button_hide(long pWin)
cdef extern void fltk_button_callback(long pWin, object func)
cdef extern void fltk_button_symbollabel(long pWid)

cdef extern long fltk_repeat_button_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_repeat_button_destroy(long pWin)
cdef extern void fltk_repeat_button_show(long pWin)
cdef extern void fltk_repeat_button_hide(long pWin)
cdef extern void fltk_repeat_button_callback(long pWin, object func)
cdef extern void fltk_repeat_button_symbollabel(long pWid)

cdef extern long fltk_select_browser_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_select_browser_destroy(long pWin)
cdef extern void fltk_select_browser_show(long pWin)
cdef extern void fltk_select_browser_hide(long pWin)
cdef extern void fltk_select_browser_callback(long pWin, object func)
cdef extern void fltk_select_browser_add(long pWin, char *item)
cdef extern void fltk_select_browser_remove(long pWin, int item)
cdef extern void fltk_select_browser_clear(long pWin)
cdef extern void fltk_select_browser_color(long pWin, int color)
cdef extern void fltk_select_browser_textcolor(long pWin, int color)
cdef extern void fltk_select_browser_selectioncolor(long pWin, int color)
cdef extern int fltk_select_browser_value(long pWin, int val)

cdef extern long fltk_hold_browser_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_hold_browser_destroy(long pWin)
cdef extern void fltk_hold_browser_show(long pWin)
cdef extern void fltk_hold_browser_hide(long pWin)
cdef extern void fltk_hold_browser_callback(long pWin, object func)
cdef extern void fltk_hold_browser_add(long pWin, char *item)
cdef extern void fltk_hold_browser_remove(long pWin, int item)
cdef extern void fltk_hold_browser_clear(long pWin)
cdef extern void fltk_hold_browser_color(long pWin, int color)
cdef extern void fltk_hold_browser_textcolor(long pWin, int color)
cdef extern void fltk_hold_browser_selectioncolor(long pWin, int color)
cdef extern int fltk_hold_browser_value(long pWin, int val)

cdef extern long fltk_color(int red, int green, int blue)

cdef extern long fltk_input_create(int x, int y, int w, int h, char *label)
cdef extern void fltk_input_callback(long pWin, object func)
cdef extern char *fltk_input_value(long pWin, char *val)
cdef extern void fltk_input_color(long pWin, int color)
cdef extern void fltk_input_textcolor(long pWin, int color)
cdef extern void fltk_input_selectioncolor(long pWin, int color)
cdef extern void fltk_input_take_focus(long pWid)

</t>
<t tx="davidmcnab.041604122248.290"># funcs for working with Fl_Window

def Fl_Window_create(x, y, w, h, label, self, onenter, onclick):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid

    print "Fl_Window_create: entered"

    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
    cLabel = PyString_AsString(label)

    cWid = fltk_window_create(cX, cY, cW, cH, cLabel, self, onenter, onclick)
    #printf("Fl_Window_create: cWid=0x%lx\n", cWid)
    wid = PyLong_FromLong(cWid)
    #print "Fl_Window_create: self.cWid=0x%lx" % wid
    return wid

def Fl_Window_end(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_end: cWid=0x%lx\n" % cWid
    fltk_window_end(cWid)

def Fl_Window_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_show: cWid=0x%lx\n" % cWid
    fltk_window_show(cWid)

def Fl_Window_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_hide(cWid)

def Fl_Window_activate(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_activate(cWid)

def Fl_Window_set_modal(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_set_modal(cWid)

def Fl_Window_move(wid, x, y):
    cdef long cWid
    cdef long cX, cY
    #print "Fl_Window_move"
    cWid = PyLong_AsLong(wid)
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    #print "Fl_Window_hide cWid=0x%lx\n" % cWid
    fltk_window_move(cWid, cX, cY)

def Fl_Window_stayOnTop(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    #print "Fl_Window_stayOnTop cWid=0x%lx\n" % cWid
    fltk_window_stayOnTop(cWid)
</t>
<t tx="davidmcnab.041604122248.291">def Fl_Button_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_button_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Button_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_button_show(cWid)

def Fl_Button_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_button_hide(cWid)

def Fl_Button_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Button: callback=0x%lx" % &lt;long&gt;func
    fltk_button_callback(cWid, func)

def Fl_Button_symbollabel(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_button_symbollabel(cWid)
</t>
<t tx="davidmcnab.041604122248.292">def Fl_Repeat_Button_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_repeat_button_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Repeat_Button_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_repeat_button_show(cWid)

def Fl_Repeat_Button_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_repeat_button_hide(cWid)

def Fl_Repeat_Button_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Button: callback=0x%lx" % &lt;long&gt;func
    fltk_repeat_button_callback(cWid, func)

def Fl_Repeat_Button_symbollabel(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_repeat_button_symbollabel(cWid)
</t>
<t tx="davidmcnab.041604122248.293">def Fl_Select_Browser_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_select_browser_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Select_Browser_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_select_browser_show(cWid)

def Fl_Select_Browser_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_select_browser_hide(cWid)

def Fl_Select_Browser_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Select_Browser: callback=0x%lx" % &lt;long&gt;func
    fltk_select_browser_callback(cWid, func)

def Fl_Select_Browser_add(wid, item):
    cdef long cWid
    cdef char *cItem

    cWid = PyLong_AsLong(wid)
    cItem = PyString_AsString(item)
    fltk_select_browser_add(cWid, cItem)

def Fl_Select_Browser_remove(wid, item):
    cdef long cWid
    cdef int cItem

    cWid = PyLong_AsLong(wid)
    cItem = PyInt_AsLong(item)
    fltk_select_browser_remove(cWid, cItem)

def Fl_Select_Browser_clear(wid):
    cdef long cWid

    cWid = PyLong_AsLong(wid)
    fltk_select_browser_clear(cWid)

def Fl_Select_Browser_color(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_select_browser_color(cWid, cColor)

def Fl_Select_Browser_textcolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_select_browser_textcolor(cWid, cColor)

def Fl_Select_Browser_selectioncolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_select_browser_selectioncolor(cWid, cColor)

def Fl_Select_Browser_value(wid, val=-2):
    cdef long cWid
    cdef int cVal

    cWid = PyLong_AsLong(wid)
    cVal = PyInt_AsLong(val)
    cVal = fltk_select_browser_value(cWid, cVal)
    val = PyInt_FromLong(cVal)
    return val
</t>
<t tx="davidmcnab.041604122248.294">def Fl_Hold_Browser_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_hold_browser_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid
   
def Fl_Hold_Browser_show(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_hold_browser_show(cWid)

def Fl_Hold_Browser_hide(wid):
    cdef long cWid
    cWid = PyLong_AsLong(wid)
    fltk_hold_browser_hide(cWid)

def Fl_Hold_Browser_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Hold_Browser: callback=0x%lx" % &lt;long&gt;func
    fltk_hold_browser_callback(cWid, func)

def Fl_Hold_Browser_add(wid, item):
    cdef long cWid
    cdef char *cItem

    cWid = PyLong_AsLong(wid)
    cItem = PyString_AsString(item)
    fltk_hold_browser_add(cWid, cItem)

def Fl_Hold_Browser_remove(wid, item):
    cdef long cWid
    cdef int cItem

    cWid = PyLong_AsLong(wid)
    cItem = PyInt_AsLong(item)
    fltk_hold_browser_remove(cWid, cItem)

def Fl_Hold_Browser_clear(wid):
    cdef long cWid

    print "Fl_Hold_Browser_clear: entered"
    cWid = PyLong_AsLong(wid)
    fltk_hold_browser_clear(cWid)

def Fl_Hold_Browser_color(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_hold_browser_color(cWid, cColor)

def Fl_Hold_Browser_textcolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_hold_browser_textcolor(cWid, cColor)

def Fl_Hold_Browser_selectioncolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_hold_browser_selectioncolor(cWid, cColor)

def Fl_Hold_Browser_value(wid, val=-2):
    cdef long cWid
    cdef int cVal

    cWid = PyLong_AsLong(wid)
    cVal = PyInt_AsLong(val)
    cVal = fltk_hold_browser_value(cWid, cVal)
    val = PyInt_FromLong(cVal)
    return val

</t>
<t tx="davidmcnab.041604122248.295">def Fl_Input_create(x, y, w, h, label):
    cdef int cX, cY, cW, cH
    cdef char *cLabel
    cdef long cWid
        
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)
       
    cLabel = PyString_AsString(label)
    cWid = fltk_input_create(cX, cY, cW, cH, cLabel)
    wid = PyLong_FromLong(cWid)
    return wid

def Fl_Input_callback(wid, func):
    cdef long cWid
    cdef long cFunc
    cWid = PyLong_AsLong(wid)
    #cFunc = &lt;long&gt;func
    #print "Fl_Hold_Browser: callback=0x%lx" % &lt;long&gt;func
    fltk_input_callback(cWid, func)

def Fl_Input_value(wid, val):
    cdef long cWid
    cdef char *cVal

    #print "flwm_.Fl_Input_value: entered"
    cWid = PyLong_AsLong(wid)
    if val == None:
        #print "input: just getting value"
        cVal = &lt;char *&gt;0
    else:
        cVal = PyString_AsString(val)
    cVal = fltk_input_value(cWid, cVal)
    val = PyString_FromString(cVal)
    return val

def Fl_Input_color(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_input_color(cWid, cColor)

def Fl_Input_textcolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_input_textcolor(cWid, cColor)

def Fl_Input_selectioncolor(wid, pColor):
    cdef long cWid
    cdef int cColor

    cWid = PyLong_AsLong(wid)
    cColor = PyInt_AsLong(pColor)
    fltk_input_selectioncolor(cWid, cColor)

def Fl_Input_take_focus(wid):
    cdef long cWid

    cWid = PyLong_AsLong(wid)
    fltk_input_take_focus(cWid)
</t>
<t tx="davidmcnab.041604122248.296">def color(red, green, blue):
    cdef int cRed
    cdef int cGreen
    cdef int cBlue
    cdef long cColor

    cRed = PyInt_AsLong(red)
    cGreen = PyInt_AsLong(green)
    cBlue = PyInt_AsLong(blue)
    
    cColor = fltk_color(cRed, cGreen, cBlue)
    pColor = PyInt_FromLong(cColor)
    #print "flwm_.color: %x %x %x -&gt; %x" % (red, green, blue, pColor)
    return pColor


</t>
<t tx="davidmcnab.041604122248.297">import sys
import os
import traceback
</t>
<t tx="davidmcnab.041604122248.298"></t>
<t tx="davidmcnab.041604122248.299">callbackNexting = 0
</t>
<t tx="davidmcnab.041604122248.300">cdef public py_on_startup(object wm):
    
    for f in wm.hdlrsStartup:
        try:
            if f():
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_startup: chained handler ok"
        except:
            print "flwm_.py_on_create: a chained handler failed"
            traceback.print_exc()
            pass

    #printf("on_startup: entered\n")
    wm.on_startup()
    #printf("on_startup: done\n")

</t>
<t tx="davidmcnab.041604122248.301">cdef public int py_on_create(object wm, unsigned long win):

    cdef int res
    
    hWin = PyLong_FromLong(win)
    #print "py_on_create: win=%lx" % hWin
    pWin = wm._addWin(hWin)

    for f in wm.hdlrsCreate:
        try:
            if f(pWin):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_create: chained handler ok"
        except:
            print "flwm_.py_on_create: a chained handler failed"
            traceback.print_exc()
            pass

    wm.on_create(pWin)
    
    #print "py_on_create: pRes=%d" % pRes
    #res = PyLong_AsLong(pRes)
    #printf("py_on_create: res=%d\n", res)
    #return res


</t>
<t tx="davidmcnab.041604122248.302">cdef public py_on_destroy(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("py_on_destroy: entered - got instance\n", win)

    wm.on_destroy(pWin)
    wm._delWin(hWin)

    for f in wm.hdlrsDestroy:
        try:
            if f(pWin):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_destroy: chained handler ok"
        except:
            print "flwm_.py_on_destroy: a chained handler failed"
            traceback.print_exc()
            pass

    #printf("py_on_destroy: exit\n")


</t>
<t tx="davidmcnab.041604122248.303">cdef long lastActiveWindow

cdef public py_on_activate(object wm, unsigned long win):
    global lastActiveWindow
    if win != lastActiveWindow:
        lastActiveWindow = win
        hWin = PyLong_FromLong(win)
        pWin = wm.window(hWin)
        #printf("on_activate: entered - got instance\n", win)
        wm.currentWindow = pWin

        for f in wm.hdlrsActivate:
            try:
                if f(pWin):
                    print "flwm_.py: handler break"
                    break
                print "flwm_.py_on_activate: chained handler ok"
            except:
                print "flwm_.py_on_activate: a chained handler failed"
                traceback.print_exc()
                pass

        wm.on_activate(pWin)</t>
<t tx="davidmcnab.041604122248.304">cdef public py_on_deactivate(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("on_deactivate: entered - got instance\n", win)

    for f in wm.hdlrsDeactivate:
        try:
            if f(pWin):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_deactivate: chained handler ok"
        except:
            print "flwm_.py_on_deactivate: a chained handler failed"
            traceback.print_exc()
            pass

    wm.on_deactivate(pWin)
</t>
<t tx="davidmcnab.041604122248.305">#cdef public int py_onSize(unsigned long hWin, int x, int y, int w, int h, int warp):
#    print "py_onSize: x=%d y=%d w=%d h=%d warp=%d" % (
#        x, y, w, h, warp)

</t>
<t tx="davidmcnab.041604122248.306">cdef public int py_on_resize(object wm, unsigned long win,
                             int x, int y, int w, int h, int warp):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    #printf("on_resize: entered - got instance\n")

    for f in wm.hdlrsResize:
        try:
            if f(pWin):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_resize: chained handler ok"
        except:
            print "flwm_.py_on_resize: a chained handler failed"
            traceback.print_exc()
            pass

    wm.on_resize(pWin, x, y, w, h)
</t>
<t tx="davidmcnab.041604122248.307">cdef public int py_on_buttonPress(object wm, long button):
    cdef int cRes
    pButton = PyLong_FromLong(button)
    
    for f in wm.hdlrsButtonPress:
        try:
            if f(pButton):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_buttonPress: chained handler ok"
        except:
            print "flwm_.py_on_buttonPress: a chained handler failed"
            traceback.print_exc()
            pass

    cRes = &lt;int&gt;PyLong_AsLong(wm.on_buttonPress(pButton))
    return cRes


</t>
<t tx="davidmcnab.041604122248.308">cdef public int py_on_keyEvent(object wm, int key):
    cdef long cRes
    pKey = PyLong_FromLong(key)
    #print "py_on_keyEvent: got keystroke"

    for f in wm.hdlrsKeyEvent:
        try:
            if f(pKey):
                print "flwm_.py: handler break"
                break
            print "flwm_.py_on_keyEvent: chained handler ok"
        except:
            print "flwm_.py_on_keyEvent: a chained handler failed"
            traceback.print_exc()
            pass

    res = wm.on_keyEvent(pKey)
    cRes = PyLong_AsLong(res)
    return cRes


</t>
<t tx="davidmcnab.041604122248.309">cdef public py_on_enter(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    wm.on_enter(pWin)
</t>
<t tx="davidmcnab.041604122248.310">cdef public py_on_leave(object wm, unsigned long win):
    hWin = PyLong_FromLong(win)
    pWin = wm.window(hWin)
    printf("on_leave: entered\n")
    wm.on_leave(pWin)
</t>
<t tx="davidmcnab.041604122248.311">#
# Define funcs in the API layer, allowing pyrex code to
# make calls into flwm

@others
</t>
<t tx="davidmcnab.041604122248.312">def run(args, wmobj):
    """
    Runs the window manager.
    
    Argument is a ref to the window manager object (which will
    receive callbacks).
    """
    cdef int i
    cdef int _argc
    cdef char **_argv

    _argc = len(args) + 1
    _argv = &lt;char **&gt;malloc(sizeof(char *) * _argc)
    _argv[0] = PyString_AsString(sys.argv[0])

    i = 1
    for arg in args:
        _argv[i] = PyString_AsString(arg)
        i = i + 1
    flwm_main(_argc, _argv, wmobj)
</t>
<t tx="davidmcnab.041604122248.313">def getMousePos():
    """
    Get the current position of the mouse and return it as
    an (x, y) tuple
    """
    cdef int x
    cdef int y
    flwm_getMousePos(&amp;x, &amp;y)
    return x, y
</t>
<t tx="davidmcnab.041604122248.314">def getScreenSize():
    """
    Get the size of the screen and returns it as
    an (x, y) tuple
    """
    cdef int x
    cdef int y
    flwm_getScreenSize(&amp;x, &amp;y)
    return x, y
</t>
<t tx="davidmcnab.041604122248.315">def keyCode(keystr, shift, control, alt, meta):
    """
    Determines the keycode number for a given key sequence
    
    Arguments:
     - as for WM.bindKey, without the first 'func' arg
    """
    cdef char *cKeystr
    cdef int cShift
    cdef int cControl
    cdef int cAlt
    cdef int cMeta
    cdef int cRes

    cKeystr = PyString_AsString(keystr)
    cShift = &lt;int&gt;PyLong_AsLong(shift)
    cControl = &lt;int&gt;PyLong_AsLong(control)
    cAlt = &lt;int&gt;PyLong_AsLong(alt)
    cMeta = &lt;int&gt;PyLong_AsLong(meta)
    cRes = flwm_keyCode(cKeystr, cShift, cControl, cAlt, cMeta)
    res = PyLong_FromLong(&lt;long&gt;cRes)
    return res
</t>
<t tx="davidmcnab.041604122248.316">def bindKey(keynum):
    """
    Tells the FLWM engine to watch out for a certain key.combination
    
    When such key combination is pressed, the window manager object's
    on_keyEvent callback will fire
    """
    cdef long cKeyNum

    #print "flwm_.bindKey: entered"
    cKeyNum = PyLong_AsLong(keynum)
    #print "flwm_.bindKey: calling flwm_bind_key key=%x" % keynum
    flwm_bindKey(cKeyNum)
    #print "flwm_.bindKey: returned from flwm_bind_key"

</t>
<t tx="davidmcnab.041604122248.317">def getLabel(hWin):
    """
    Returns the label of the given window.
    Argument is window 'handle'
    """
    cdef long win

    #print "flwm_.getLabel: hwin=0x%lx" % hWin
    win = PyLong_AsLong(hWin)    

    label = flwm_getLabel(win)

    # when I was relying on automatic conversions, the window manager
    # would start up, the on_create callbacks would fire, and this
    # call was succeeding.
    
    # but strangely, when new windows were created *after* launching
    # the window manager, calls to this method would fail, and the
    # print statement below would never get reached.

    #print "flwm_.getLabel done"
    return label
</t>
<t tx="davidmcnab.041604122248.318">def getSize(hWin):
    """
    Return the size of the given window (arg window handle)
    as an x, y tuple
    """
    cdef long cWin
    cdef int x
    cdef int y

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.getSize: calling flwm_getSize"
    flwm_getSize(cWin, &amp;x, &amp;y)
    #print "flwm_.getSize: returned from flwm_getSize"

    return x, y
</t>
<t tx="davidmcnab.041604122248.319">def setSize(hWin, w, h):
    """
    Resize the given window to x y
    """
    # declare explicitly C variables
    cdef long cWin
    cdef long cW
    cdef long cH

    # perform manual conversions
    cWin = PyLong_AsLong(hWin)
    cW = PyLong_AsLong(w)
    cH = PyLong_AsLong(h)

    #print "flwm_.setSize: calling flwm_setSize"
    flwm_setSize(cWin, cW, cH)
    #print "flwm_.setSize: returned from flwm_setSize"
</t>
<t tx="davidmcnab.041604122248.320">def getPos(hWin):
    """
    Return the position of the given window (handle) as
    an x, y tuple
    """
    cdef long cWin
    cdef int x
    cdef int y

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.getPos: calling flwm_getPos"
    flwm_getPos(cWin, &amp;x, &amp;y)
    #print "flwm_.getPos: returned from flwm_getPos"

    return x, y



</t>
<t tx="davidmcnab.041604122248.321">def setPos(hWin, x, y):
    """
    Set the position of the given window (handle) to x, y
    """
    cdef long cWin
    cdef long cX
    cdef long cY

    cWin = PyLong_AsLong(hWin)
    cX = PyLong_AsLong(x)
    cY = PyLong_AsLong(y)

    #print "flwm_.setPos: calling flwm_setPos"
    flwm_setPos(cWin, cX, cY)
    #print "flwm_.setPos: returned from flwm_setPos"

</t>
<t tx="davidmcnab.041604122248.322">def setBorder(hWin, mode):
    """
    Set the position of the given window (handle) to x, y
    """
    cdef long cWin
    cdef long cMode

    cWin = PyLong_AsLong(hWin)
    cMode = PyLong_AsLong(mode)

    #print "flwm_.setBorder: calling flwm_setBorder"
    flwm_setBorder(cWin, cMode)
    #print "flwm_.setBorder: returned from flwm_setBorder"


</t>
<t tx="davidmcnab.041604122248.323">def closeWindow(hWin):
    """
    Close the current window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.closeWindow: calling flwm_closeWindow"
    flwm_closeWindow(cWin)
    #print "flwm_.closeWindow: returned from flwm_closeWindow"
</t>
<t tx="davidmcnab.041604122248.324">def raiseWindow(hWin):
    """
    Raise the given window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.raiseWindow: calling flwm_raiseWindow"
    flwm_raiseWindow(cWin)
    #print "flwm_.raiseWindow: returned from flwm_raiseWindow"
</t>
<t tx="davidmcnab.041604122248.325">def lowerWindow(hWin):
    """
    Lower the given window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.lowerWindow: calling flwm_lowerWindow"
    flwm_lowerWindow(cWin)
    #print "flwm_.lowerWindow: returned from flwm_lowerWindow"
</t>
<t tx="davidmcnab.041604122248.326">def iconiseWindow(hWin):
    """
    Iconise the given window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.iconiseWindow: calling flwm_iconiseWindow"
    flwm_iconiseWindow(cWin)
    #print "flwm_.iconiseWindow: returned from flwm_iconiseWindow"
</t>
<t tx="davidmcnab.041604122248.327">def activateWindow(hWin):
    """
    Activate the given window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.activateWindow: calling flwm_activateWindow"
    flwm_activateWindow(cWin)
    #print "flwm_.activateWindow: returned from flwm_activateWindow"
</t>
<t tx="davidmcnab.041604122248.328">def deactivateWindow(hWin):
    """
    Activate the given window (handle)
    """
    cdef long cWin

    cWin = PyLong_AsLong(hWin)

    #print "flwm_.activateWindow: calling flwm_activateWindow"
    flwm_deactivateWindow(cWin)
    #print "flwm_.activateWindow: returned from flwm_activateWindow"
</t>
<t tx="davidmcnab.041604122248.329">def goNextWindow():
    """
    Raise and activate the next window in the chain
    """
    print "flwm_.goNextWindow: calling flwm_goNextWindow"
    flwm_goNextWindow()
    print "flwm_.goNextWindow: returned from flwm_goNextWindow"

</t>
<t tx="davidmcnab.041604122248.330">def goPrevWindow():
    """
    Raise and activate the previous window in the chain
    """
    print "flwm_.goPrevWindow: calling flwm_goPrevWindow"
    flwm_goPrevWindow()
    print "flwm_.goPrevWindow: returned from flwm_goPrevWindow"
</t>
<t tx="davidmcnab.041604122248.331">def goNextDesk():
    """
    Go to the next desktop
    """
    #print "flwm_.goNextDesk: calling flwm_goNextDesk"
    flwm_goNextDesk()
    #print "flwm_.goNextDesk: returned from flwm_goNextDesk"
</t>
<t tx="davidmcnab.041604122248.332">def goPrevDesk():
    """
    Go to the previous desktop
    """
    #print "flwm_.goPrevDesk: calling flwm_goPrevDesk"
    flwm_goPrevDesk()
    #print "flwm_.goPrevDesk: returned from flwm_goPrevDesk"
</t>
<t tx="davidmcnab.041604122248.333">def showMenu():
    """
    Pop up the FLWM main menu
    """
    print "flwm_.showMenu"
    flwm_showMenu()
</t>
<t tx="davidmcnab.041604122248.334">def test(arg=None):
    print "flwm_.test: running flwm_test()"
    flwm_test()
    print "flwm_.test: done"
</t>
<t tx="davidmcnab.041604122248.335">def setTimer(secs, func):
    cdef double cSecs

    cSecs = PyFloat_AsDouble(secs)

    #print "flwm_.setTimer: calling flwm_setTimer"
    flwm_setTimer(cSecs, func)
    #print "flwm_.setTimer: returned from flwm_setTimer"
</t>
<t tx="davidmcnab.041604122248.336">def repeatTimer(secs, func):
    cdef double cSecs

    cSecs = PyFloat_AsDouble(secs)

    #print "flwm_.setTimer: calling flwm_repeatTimer"
    flwm_repeatTimer(cSecs, func)
    #print "flwm_.setTimer: returned from flwm_repeatTimer"

</t>
<t tx="davidmcnab.041604122248.337"></t>
<t tx="davidmcnab.041604122248.338">@language c

//
// definitions of callbacks sent from the FLWM engine to
// the pywm.WM handlers.
//

#include "Python.h"

//extern "C" void initflwm(void);
extern PyObject *pyClient;

//extern "C" int  py_onSize(void *, int ,int ,int ,int ,int );

extern "C" int py_on_startup(PyObject *wm);
extern "C" int py_on_keyEvent(PyObject *wm, long key);
extern "C" int py_on_buttonPress(PyObject *wm, long button);
extern "C" int py_on_create(PyObject *wm, long win);
extern "C" int py_on_destroy(PyObject *wm, long win);

extern "C" int py_on_resize(PyObject *wm, long win,
                         int x, int y, int w, int h, int warp);

extern "C" int py_on_activate(PyObject *wm, long win);
extern "C" int py_on_deactivate(PyObject *wm, long win);

</t>
<t tx="davidmcnab.041604122248.339">@language c

//
// flwmapi.cpp
//
// Due to Pyrex being (presently) unable to handle C++ code, it
// has been necessary to write a 'shim' layer of vanilla C
// functions which call C++ functions within the FLWM engine.
//
// These functions get exposed to the pywm.flwm_ module as vanilla
// C entry points, which the various pywm.flwm_ functions can use
// to take actions.

@others
</t>
<t tx="davidmcnab.041604122248.340">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;X11/Xproto.h&gt;
#include &lt;X11/Xlib.h&gt;
#include &lt;FL/filename.H&gt;
#include &lt;FL/Enumerations.H&gt;
#include &lt;FL/Fl_Menu_Button.H&gt;
#include &lt;FL/Fl_Choice.H&gt;
#include &lt;FL/Fl_Browser.H&gt;
#include &lt;FL/Fl_Select_Browser.H&gt;
#include &lt;FL/Fl_Hold_Browser.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;
#include &lt;FL/Fl_Repeat_Button.H&gt;
#include &lt;FL/Fl_Input.H&gt;

#include "Frame.h"
#include "config.h"

#include "Python.h"


</t>
<t tx="davidmcnab.041604122248.341">extern void NextWindow();
extern void PreviousWindow();
extern void NextDesk();
extern void PreviousDesk();
extern void ShowMenu();

void Hotkeys_bindKey(long key);

extern int parse_fl_color(const char* arg);

extern const char* cfg, *cbg, *abg, *bg, *fg;

</t>
<t tx="davidmcnab.041604122248.342">extern "C" void flwm_goNextWindow()
{
   NextWindow();
}

</t>
<t tx="davidmcnab.041604122248.343">extern "C" void flwm_goPrevWindow()
{
   PreviousWindow();
}

</t>
<t tx="davidmcnab.041604122248.344">extern "C" void flwm_goNextDesk()
{
   NextDesk();
}
</t>
<t tx="davidmcnab.041604122248.345">extern "C" void flwm_goPrevDesk()
{
   PreviousDesk();
}
</t>
<t tx="davidmcnab.041604122248.346">extern "C" void flwm_showMenu()
{
  printf("flwm_showMenu: trying...\n");
   ShowMenu();
}
</t>
<t tx="davidmcnab.041604122248.347">extern "C" void flwm_raiseWindow(Frame *f)
{
  if (f)
    f-&gt;raise();
}
</t>
<t tx="davidmcnab.041604122248.348">extern "C" void flwm_lowerWindow(Frame *f)
{
  if (f)
    f-&gt;lower();
}
</t>
<t tx="davidmcnab.041604122248.349">extern "C" void flwm_iconiseWindow(Frame *f)
{
  if (f)
    f-&gt;iconize();
}
</t>
<t tx="davidmcnab.041604122248.350">extern "C" void flwm_activateWindow(Frame *f)
{
  if (f)
    f-&gt;activate();
}
</t>
<t tx="davidmcnab.041604122248.351">extern "C" void flwm_deactivateWindow(Frame *f)
{
  if (f)
    f-&gt;deactivate();
}
</t>
<t tx="davidmcnab.041604122248.352">extern "C" char *flwm_getLabel(Frame *frm)
{
  //printf("flwm_getLabel: frm=0x%lx\n", frm);
  char *name = (char *)frm-&gt;label();
  //printf("flwm_getLabel: name=%s\n", name);
  return name;
}

</t>
<t tx="davidmcnab.041604122248.353">extern "C" void flwm_getMousePos(int *x, int *y)
{
  int x1, y1;
  Fl::get_mouse(x1, y1);
  *x = x1;
  *y = y1;
}

</t>
<t tx="davidmcnab.041604122248.354">extern "C" void flwm_getScreenSize(int *x, int *y)
{
  *x = Fl::w();
  *y = Fl::h();
}

</t>
<t tx="davidmcnab.041604122248.355">Fl_Window *testwin = NULL;
Fl_Browser *testbrows = NULL;

static void cb_mybut(Fl_Widget *, void *)
{
    testwin-&gt;hide();
}


extern "C" void flwm_test()
{
    int x = 0, y = 0;
    
    Fl::get_mouse(x, y);
    
    printf("flwm_test: entered\n");

    if (testwin == NULL)
    {
        testwin = new Fl_Window(x, y, 100, 200,
                               "A Window");

        testwin-&gt;color(
           parse_fl_color(fg),
           parse_fl_color(bg)
           );
        
        testbrows = new Fl_Select_Browser(
             5, 5, 90, 190, "Choose");

        testbrows-&gt;color(parse_fl_color(bg)
                     //,
                     //parse_fl_color(fg)
                     );
        printf("fg=%s\n", fg);
        printf("bg=%s\n", bg);
        printf("cbg=%s\n", cbg);
        printf("cfg=%s\n", cfg);
        printf("abg=%s\n", abg);

        testbrows-&gt;add((char *)"Click me", (char *)"First");
        testbrows-&gt;callback(cb_mybut);
        testwin-&gt;end();
    }
    else
        testbrows-&gt;deselect();

    testwin-&gt;position(x, y);
    testwin-&gt;show();
}


</t>
<t tx="davidmcnab.041604122248.356">
static void cbTimer(void *pyfunc)
{
    //printf("cbTimer: about to fire python callback\n");
    PyObject_CallObject((PyObject *)pyfunc, NULL);
    //printf("cbTimer: returned from python callback\n");
    Py_DECREF((PyObject *)pyfunc);
}


extern "C" void flwm_setTimer(double secs, PyObject *func)
{
    //printf("flwm_setTimer: func=0x%lx\n", func);
    Py_INCREF(func);
    Fl::add_timeout(secs, cbTimer, (void *)func);
}
 
extern "C" void flwm_repeatTimer(double secs, PyObject *func)
{
    //printf("flwm_repeatTimer: func=0x%lx\n", func);
    Py_INCREF(func);
    Fl::repeat_timeout(secs, cbTimer, (void *)func);
}
</t>
<t tx="davidmcnab.041604122248.357">extern "C" void flwm_setBorder(Frame *frm, long mode)
{
  //printf("flwm_setBorder: mode=%d\n", mode);
  frm-&gt;setBorder(mode);
  //printf("flwm_setBorder: done\n");
}
</t>
<t tx="davidmcnab.041604122248.358"></t>
<t tx="davidmcnab.041604122248.359">@language c
// config.h
// You can edit these symbols to change the behavior &amp; appearance of flwm.
// Turning off features will make flwm smaller too!

////////////////////////////////////////////////////////////////
// BEHAVIOR:

// Turn this on for click-to-type (rather than point-to-type).
// On: clicking on the window gives it focus
// Off: pointing at the window gives it the focus.
#define CLICK_TO_TYPE 1

// Most window managers consider this and click-to-type equivalent.
// On: clicking anywhere on window raises it
// Off: you have to click on the border to raise window

#define CLICK_RAISES CLICK_TO_TYPE
//#define CLICK_RAISES 1

    // For point-to-type, sticky focus means you don't lose the focus
// until you move the cursor to another window that wants focus.
// If this is off you lose focus as soon as the cursor goes outside
// the window (such as to the desktop):
#define STICKY_FOCUS 1

// For point-to-type, after this many seconds the window is raised,
// nothing is done if this is not defined:
//#define AUTO_RAISE 1.0

// set this to zero to remove the multiple-desktop code.  This will
// make flwm about 20K smaller
#define DESKTOPS 1

// set this to zero for "new desktop" to just create one without asking
// for a name.  This saves 12K or so of fltk input field code:
#define ASK_FOR_NEW_DESKTOP_NAME 0

// wm2 has no close box, for good reasons.  Unfortunately too many programs
// assume there is one and have no other way to close a window.  For a more
// "pure" implementation set this to zero:
#define CLOSE_BOX 1

// set this to zero to remove the minimize/window-shade button:
#define MINIMIZE_BOX 1

// If this is false the minimize button only changes the width of the
// window, so it acts like a Mac window shade.  This was the original
// behavior, the new version makes it smaller vertically so it is just
// big enough to show the window title:
#define MINIMIZE_HEIGHT 1

// Read links from ~/.wmx to make menu items to run programs:
#define WMX_MENU_ITEMS 1

// Menu item to run a new xterm (if no wmx items found):
#define XTERM_MENU_ITEM 1

// Hotkeys (see Hotkeys.C for exactly what they do):
#define STANDARD_HOTKEYS 1 // alt+esc, alt+tab, alt+shift+tab
#define KWM_HOTKEYS 1	// ctrl+tab and ctrl+Fn for desktop switching
#define CDE_HOTKEYS defined(__sgi) // alt+fn do actions like raise/lower/close
#define WMX_HOTKEYS 1	// alt+up/down/enter/delete
#define WMX_DESK_HOTKEYS 0 // alt+left/right (conflict with Netscape)
#define DESKTOP_HOTKEYS 0 // alt+fn goes to desktop n

////////////////////////////////////////////////////////////////
// APPEARANCE:

// Color for active window title bar (also for selected menu items):
// If not defined, no active window title highlighting is done.
#if CLICK_TO_TYPE
#define ACTIVE_COLOR 0xE0E0E0
#endif
//#define ACTIVE_COLOR 0x000080

// thickness of the border edge on each side (includes XBORDER):
#define LEFT 3
#define RIGHT 4
#define TOP 3
#define BOTTOM 4

// font for titles (if not set, helvetica bold is used):
// If this name is specific enough the font size is ignored.
//#define TITLE_FONT "-*-helvetica-bold-r-normal--*"
#define TITLE_FONT_SIZE 12

// thickness of title bar (LEFT is added to it):
#define TITLE_WIDTH (TITLE_FONT_SIZE+3)

// size &amp; position of buttons (must fit in title bar):
#define BUTTON_W TITLE_WIDTH
#define BUTTON_H BUTTON_W
#define BUTTON_LEFT LEFT
#define BUTTON_TOP TOP
#define BUTTON_BOTTOM BOTTOM

// how many pixels from edge for resize handle:
#define RESIZE_EDGE 5
// set this to zero to disable resizing by grabbing left edge:
#define RESIZE_LEFT 1

// must drag window this far off screen to snap the border off the screen:
#define EDGE_SNAP 50
// must drag window this far off screen to actually move it off screen:
#define SCREEN_SNAP 100

// button decorations:
#define CLOSE_X 1	// windoze-style X in close button
#define CLOSE_HITTITE_LIGHTNING 0 // The ancient Hittite symbol for lightning
#define ICONIZE_BOX 1	// small box in iconize button
#define MINIMIZE_ARROW 1 // minimize button draws a &lt;- rather than |

// default colors for cursor:
#ifdef __sgi
#define CURSOR_FG_COLOR 0xff0000
#else
#define CURSOR_FG_COLOR 0x000000
#endif
#define CURSOR_BG_COLOR 0xffcc00


// "Clock in the title bar" code contributed by Kevin Quick
// &lt;kquick@iphase.com&gt;:

// Add a clock to the active window's title bar using specified
// strftime fmt Note: in keeping with the minimalistic, fast, and
// small philosophy of the flwm, the clock will only be updated
// once/minute so any display of seconds is frivolous.
#define SHOW_CLOCK "%I:%M %p %Z"

// We also support the concept of a clock alarm.  The alarm is
// triggered by delivering SIGALRM to flwm and cleared by delivering
// SIGCONT to flwm.  When the alarm is active, the foreground and
// background colors of the clock display are determined by the
// following settings.  (The following are unused if SHOW_CLOCK is not
// defined).
#define ALARM_FG_COLOR 0x00ffff
#define ALARM_BG_COLOR 0xff0000

////////////////////////////////////////////////////////////////
// MENU APPEARANCE:

#define MAX_MENU_WIDTH 300

// size of the little pictures in the menu:
#define MENU_ICON_W 18
#define MENU_ICON_H 15

// font to use in menus (if not set helvetica is used):
//#define MENU_FONT "-*-helvetica-medium-r-normal--*"
#define MENU_FONT_SIZE 14

////////////////////////////////////////////////////////////////
// You probably don't want to change any of these:

#ifdef TITLE_FONT
#define TITLE_FONT_SLOT FL_FREE_FONT
#else
#define TITLE_FONT_SLOT FL_BOLD
#endif

#ifdef MENU_FONT
#define MENU_FONT_SLOT Fl_Font(FL_FREE_FONT+1)
#else
#define MENU_FONT_SLOT FL_HELVETICA
#endif

#define CURSOR_BG_SLOT Fl_Color(30)
#define CURSOR_FG_SLOT Fl_Color(31)

</t>
<t tx="davidmcnab.041604122248.360">@language c

// Define "TEST" and it will compile to make a single fake window so
// you can test the window controls.
//#define TEST 1

&lt;&lt; main #includes &gt;&gt;
&lt;&lt; main declarations &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.361">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;X11/Xproto.h&gt;
#include &lt;FL/filename.H&gt;

#include "config.h"
#include "Frame.h"

#include "Python.h"
#include "pycallbacks.h"

</t>
<t tx="davidmcnab.041604122248.362">#ifdef SHOW_CLOCK
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#endif

////////////////////////////////////////////////////////////////

static const char* program_name;
static int initializing;

PyObject *pyClient = NULL;

extern "C" char *getWindowName(Window w);

</t>
<t tx="davidmcnab.041604122248.363">
static int xerror_handler(Display* d, XErrorEvent* e) {
  if (initializing &amp;&amp; (e-&gt;request_code == X_ChangeWindowAttributes) &amp;&amp;
      e-&gt;error_code == BadAccess)
    Fl::fatal("Another window manager is running.  You must exit it before running %s.", program_name);
#ifndef DEBUG
  if (e-&gt;error_code == BadWindow) return 0;
  if (e-&gt;error_code == BadColor) return 0;
#endif
  char buf1[128], buf2[128];
  sprintf(buf1, "XRequest.%d", e-&gt;request_code);
  XGetErrorDatabaseText(d,"",buf1,buf1,buf2,128);
  XGetErrorText(d, e-&gt;error_code, buf1, 128);
  Fl::warning("%s: %s: %s 0x%lx", program_name, buf2, buf1, e-&gt;resourceid);
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.364">@ The Fl_Root class looks like a window to fltk but is actually the
screen's root window. This is done by using set_xid to "show" it
rather than have fltk create the window.
@c

class Fl_Root : public Fl_Window {
  int handle(int);
public:
  void *wmobj;
  Fl_Root(void *p_wmobj) : Fl_Window(0,0,Fl::w(),Fl::h()) { wmobj = p_wmobj;}
  void show() {
    if (!shown()) Fl_X::set_xid(this, RootWindow(fl_display, fl_screen));
  }
};
Fl_Window *Root;

extern void ShowMenu();
extern int Handle_Hotkey();
extern void Grab_Hotkeys();

int Fl_Root::handle(int e) {
  if (e == FL_PUSH)
  {
    int button = Fl::event_button();
    if (py_on_buttonPress(pyClient, (long)button))
        return 1;
    ShowMenu();
    return 1;
  }
  //printf("Fl_Root::handle: got other than\n");
  return 0;
}

</t>
<t tx="davidmcnab.041604122248.365">
#if CLICK_RAISES || CLICK_TO_TYPE
extern void click_raise(Frame*);
#endif

// fltk calls this for any events it does not understand:
static int flwm_event_handler(int e)
{
  if (!e)
  { // XEvent that fltk did not understand.
    Window window = fl_xevent-&gt;xany.window;
    // unfortunately most of the redirect events put the interesting
    // window id in a different place:
    switch (fl_xevent-&gt;type) {
    case CirculateNotify:
    case CirculateRequest:
    case ConfigureNotify:
    case ConfigureRequest:
    case CreateNotify:
    case DestroyNotify:
    case GravityNotify:
    case MapNotify:
    case MapRequest:
    case ReparentNotify:
    case UnmapNotify:
      window = fl_xevent-&gt;xmaprequest.window;
    }
    for (Frame* c = Frame::first; c; c = c-&gt;next)
      if (c-&gt;window() == window || fl_xid(c) == window)
#if CLICK_RAISES || CLICK_TO_TYPE
	if (fl_xevent-&gt;type == ButtonPress) {click_raise(c); return 1;}
	else
#endif
	  return c-&gt;handle(fl_xevent);
    switch (fl_xevent-&gt;type)
    {
    case ButtonPress:
      printf("got a button press in main\n");
      return 0;
    case ConfigureRequest:
      {
      const XConfigureRequestEvent *e = &amp;(fl_xevent-&gt;xconfigurerequest);
      XConfigureWindow(fl_display, e-&gt;window,
		       e-&gt;value_mask&amp;~(CWSibling|CWStackMode),
		       (XWindowChanges*)&amp;(e-&gt;x));
      return 1;
      }
    case MapRequest:
      {
      const XMapRequestEvent* e = &amp;(fl_xevent-&gt;xmaprequest);
      (void)new Frame(e-&gt;window);
      return 1;
      }
    case KeyRelease:
      {
      if (!Fl::grab()) return 0;
      // see if they released the alt key:
      unsigned long keysym =
            XKeycodeToKeysym(fl_display, fl_xevent-&gt;xkey.keycode, 0);
      if (keysym == FL_Alt_L || keysym == FL_Alt_R)
      {
            Fl::e_keysym = FL_Enter;
            return Fl::grab()-&gt;handle(FL_KEYBOARD);
      }
      return 0;
      }
    }
  }
  else if (e == FL_SHORTCUT)
  {
#if FL_MAJOR_VERSION == 1 &amp;&amp; FL_MINOR_VERSION == 0 &amp;&amp; FL_PATCH_VERSION &lt; 3
    // make the tab keys work in the menus in older fltk's:
    // (they do not cycle around however, so a new fltk is a good idea)
    if (Fl::grab())
    {
      // make fltk's menus resond to tab + shift+tab:
      if (Fl::event_key() == FL_Tab)
      {
        if (Fl::event_state() &amp; FL_SHIFT)
            goto J1;
        Fl::e_keysym = FL_Down;
      }
      else if (Fl::event_key() == 0xFE20)
      {
        	J1: Fl::e_keysym = FL_Up;
      }
      else
        return 0;
      return Fl::grab()-&gt;handle(FL_KEYBOARD);
    }
#endif
    return Handle_Hotkey();
  }
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.366">
#if DESKTOPS
extern void init_desktops();
extern Atom _win_workspace;
extern Atom _win_workspace_count;
extern Atom _win_workspace_names;
#endif

extern Atom _win_state;
extern Atom _win_hints;

#ifdef SHOW_CLOCK
int clock_period = 1;
int clock_oldmin = 61;
int clock_alarm_on = 0;
char clock_buf[80];

struct sigaction flwm_clock_alarm_start = {0,}, flwm_clock_alarm_stop = {0,};

void flwm_update_clock(void*) {
    time_t newtime;
    struct tm *tm_p;

    // get current time
    time(&amp;newtime);
    tm_p = localtime(&amp;newtime);

    // Update a window frame if necessary
    if (Frame::activeFrame() &amp;&amp; tm_p-&gt;tm_min != clock_oldmin) {
	if (clock_oldmin != 61)
	    clock_period = 60;  // now that we're in sync, only update 1/minute
	clock_oldmin = tm_p-&gt;tm_min;
	strftime(clock_buf, 80, SHOW_CLOCK, tm_p);
	Frame::activeFrame()-&gt;redraw_clock();
    }
    // Now reschedule the timeout
    Fl::remove_timeout(flwm_update_clock);
    Fl::add_timeout(clock_period, flwm_update_clock);
}
</t>
<t tx="davidmcnab.041604122248.367">
void flwm_clock_alarm_on(int) {
    clock_alarm_on = 1;
    Frame::activeFrame()-&gt;redraw_clock();
}
</t>
<t tx="davidmcnab.041604122248.368">
void flwm_clock_alarm_off(int) {
    clock_alarm_on = 0;
    Frame::activeFrame()-&gt;redraw_clock();
}
</t>
<t tx="davidmcnab.041604122248.369">#endif

const char* cfg, *cbg, *abg, *bg, *fg;

static int cursor = FL_CURSOR_ARROW;

static void color_setup(Fl_Color slot, const char* arg, ulong value) {
  if (arg) {
    XColor x;
    if (XParseColor(fl_display, fl_colormap, arg, &amp;x))
      value = ((x.red&gt;&gt;8)&lt;&lt;24)
            | ((x.green&gt;&gt;8)&lt;&lt;16)
            | ((x.blue));
  }
  Fl::set_color(slot, value);
}
</t>
<t tx="davidmcnab.041604122248.370">int parse_fl_color(const char* arg)
{
  int value = 0;
  XColor x;
  if (arg)
  {
    if (XParseColor(fl_display, fl_colormap, arg, &amp;x))
        value = fl_color_cube(
            (x.red &gt;&gt; 8) * FL_NUM_RED/256,
            (x.green &gt;&gt; 8) * FL_NUM_GREEN/256,
            (x.blue &gt;&gt; 8) * FL_NUM_BLUE/256
            );
  }
  printf("parse_fl_color: %s -&gt; 0x%x\n", arg, value);
  
  return value;
}


</t>
<t tx="davidmcnab.041604122248.371">
static void initialize() {

  Display* d = fl_display;

#ifdef TEST
  Window w = XCreateSimpleWindow(d, root,
				 100, 100, 200, 300, 10,
				 BlackPixel(fl_display, 0),
//				 WhitePixel(fl_display, 0));
				 0x1234);
  Frame* frame = new Frame(w);
  XSelectInput(d, w,
	       ExposureMask | StructureNotifyMask |
	       KeyPressMask | KeyReleaseMask | FocusChangeMask |
	       KeymapStateMask |
	       ButtonPressMask | ButtonReleaseMask |
	       EnterWindowMask | LeaveWindowMask /*|PointerMotionMask*/
	       );
#else

  Fl::add_handler(flwm_event_handler);

  // setting attributes on root window makes me the window manager:
  initializing = 1;
  XSelectInput(d, fl_xid(Root),
	       SubstructureRedirectMask | SubstructureNotifyMask |
	       ColormapChangeMask | PropertyChangeMask |
	       ButtonPressMask | ButtonReleaseMask | 
	       EnterWindowMask | LeaveWindowMask |
	       KeyPressMask | KeyReleaseMask | KeymapStateMask |
           PointerMotionMask);
  color_setup(CURSOR_FG_SLOT, cfg, CURSOR_FG_COLOR&lt;&lt;8);
  color_setup(CURSOR_BG_SLOT, cbg, CURSOR_BG_COLOR&lt;&lt;8);
  Root-&gt;cursor((Fl_Cursor)cursor, CURSOR_FG_SLOT, CURSOR_BG_SLOT);

#ifdef TITLE_FONT
  Fl::set_font(TITLE_FONT_SLOT, TITLE_FONT);
#endif
#ifdef MENU_FONT
  Fl::set_font(MENU_FONT_SLOT, MENU_FONT);
#endif
#ifdef ACTIVE_COLOR
  //Fl::set_color(FL_SELECTION_COLOR, ACTIVE_COLOR&lt;&lt;8);
  color_setup(FL_SELECTION_COLOR, abg, ACTIVE_COLOR&lt;&lt;8);
#endif

  // Gnome crap:
  // First create a window that can be watched to see if wm dies:
  Atom a = XInternAtom(d, "_WIN_SUPPORTING_WM_CHECK", False);
  Window win = XCreateSimpleWindow(d, fl_xid(Root), -200, -200, 5, 5, 0, 0, 0);
  CARD32 val = win;
  XChangeProperty(d, fl_xid(Root), a, XA_CARDINAL, 32, PropModeReplace, (uchar*)&amp;val, 1);
  XChangeProperty(d, win, a, XA_CARDINAL, 32, PropModeReplace, (uchar*)&amp;val, 1);
  // Next send a list of Gnome stuff we understand:
  a = XInternAtom(d, "_WIN_PROTOCOLS", 0);
  Atom list[10]; unsigned int i = 0;
//list[i++] = XInternAtom(d, "_WIN_LAYER", 0);
  list[i++] = _win_state = XInternAtom(d, "_WIN_STATE", 0);
  list[i++] = _win_hints = XInternAtom(d, "_WIN_HINTS", 0);
//list[i++] = XInternAtom(d, "_WIN_APP_STATE", 0);
//list[i++] = XInternAtom(d, "_WIN_EXPANDED_SIZE", 0);
//list[i++] = XInternAtom(d, "_WIN_ICONS", 0);
#if DESKTOPS
  list[i++] = _win_workspace = XInternAtom(d, "_WIN_WORKSPACE", 0);
  list[i++] = _win_workspace_count = XInternAtom(d, "_WIN_WORKSPACE_COUNT", 0);
  list[i++] = _win_workspace_names = XInternAtom(d, "_WIN_WORKSPACE_NAMES", 0);
#endif
//list[i++] = XInternAtom(d, "_WIN_FRAME_LIST", 0);
  XChangeProperty(d, fl_xid(Root), a, XA_ATOM, 32, PropModeReplace, (uchar*)list, i);

  Grab_Hotkeys();

#ifdef SHOW_CLOCK
  Fl::add_timeout(clock_period, flwm_update_clock);
  flwm_clock_alarm_start.sa_handler = &amp;flwm_clock_alarm_on;
  flwm_clock_alarm_stop.sa_handler = &amp;flwm_clock_alarm_off;
  sigaction(SIGALRM, &amp;flwm_clock_alarm_start, NULL);
  sigaction(SIGCONT, &amp;flwm_clock_alarm_stop, NULL);
#endif

  XSync(d, 0);
  initializing = 0;

#if DESKTOPS
  init_desktops();
#endif

  // find all the windows and create a Frame for each:
  unsigned int n;
  Window w1, w2, *wins;
  XWindowAttributes attr;
  XQueryTree(d, fl_xid(Root), &amp;w1, &amp;w2, &amp;wins, &amp;n);
  for (i = 0; i &lt; n; ++i) {
    XGetWindowAttributes(d, wins[i], &amp;attr);
    if (attr.override_redirect || !attr.map_state) continue;
    (void)new Frame(wins[i],&amp;attr);
  }
  XFree((void *)wins);

#endif
}
</t>
<t tx="davidmcnab.041604122248.372">
////////////////////////////////////////////////////////////////

extern int exit_flag;
extern int max_w_switch;
extern int max_h_switch;

// consume a switch from argv.  Returns number of words eaten, 0 on error:
int arg(int argc, char **argv, int &amp;i) {
  const char *s = argv[i];
  if (s[0] != '-') return 0;
  s++;

  // do single-word switches:
  if (!strcmp(s,"x")) {
    exit_flag = 1;
    i++;
    return 1;
  }

  // do switches with a value:
  const char *v = argv[i+1];
  if (i &gt;= argc-1 || !v)
    return 0;	// all the rest need an argument, so if missing it is an error

  if (!strcmp(s, "cfg")) {
    cfg = v;
  }

  else if (!strcmp(s, "fg"))
  {
    fg = v;
    return 0;
  }
  else if (!strcmp(s, "bg"))
  {
    bg = v;
    return 0;
  }

  else if (!strcmp(s, "cbg"))
  {
    cbg = v;
  }
  else if (!strcmp(s, "abg"))
  {
    abg = v;
  }
  else if (*s == 'c')
  {
    cursor = atoi(v);
  }
  else if (*s == 'v')
  {
    int visid = atoi(v);
    fl_open_display();
    XVisualInfo templt; int num;
    templt.visualid = visid;
    fl_visual = XGetVisualInfo(fl_display, VisualIDMask, &amp;templt, &amp;num);
    if (!fl_visual) Fl::fatal("No visual with id %d",visid);
    fl_colormap = XCreateColormap(fl_display, 
                                  RootWindow(fl_display,fl_screen),
                                  fl_visual-&gt;visual, AllocNone);
  }
  else if (*s == 'm')
  {
    max_w_switch = atoi(v);
    while (*v &amp;&amp; *v++ != 'x');
    max_h_switch = atoi(v);
  }
  else
    return 0; // unrecognized
  // return the fact that we consumed 2 switches:
  i += 2;
  return 2;
}

</t>
<t tx="davidmcnab.041604122248.373">extern "C" char *getWindowName(Window w)
{
	char * name;
	char * machine;
	Atom actual_type;
	int format;
	unsigned long n;
	unsigned long extra;
	
	if (XGetWindowProperty(
                          fl_display,
                          w,
                          XA_WM_NAME,
                          0L,
                          100L,
                          False,
                          AnyPropertyType,
                          &amp;actual_type,
                          &amp;format,
                          &amp;n,
                          &amp;extra,
                          (unsigned char **) &amp;name) == Success &amp;&amp; name &amp;&amp; *name != '\0' &amp;&amp; n != 0)
        return name;
    else
        return NULL;
}

</t>
<t tx="davidmcnab.041604122248.374">@language c

// Desktop.H


class Desktop {
  const char* name_;
  int number_;
  static Desktop* current_;
public:
  static Desktop* first;
  Desktop* next;
  const char* name() const {return name_;}
  void name(const char*);
  int number() const {return number_;}
  static Desktop* current() {return current_;}
  static Desktop* number(int, int create = 0);
  static void current(Desktop*);
  static int available_number();
  static int max_number();
  Desktop(const char*, int);
  ~Desktop();
  int junk; // for temporary storage by menu builder
};

</t>
<t tx="davidmcnab.041604122248.375">@language c

// Desktop.C

&lt;&lt; Desktop #includes &gt;&gt;
&lt;&lt; Desktop declarations &gt;&gt;
@others

#endif
</t>
<t tx="davidmcnab.041604122248.376">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "config.h"

#if DESKTOPS

#include "Frame.h"
#include "Desktop.h"

#include "pycallbacks.h"
</t>
<t tx="davidmcnab.041604122248.377">
Desktop* Desktop::current_ = 0;
Desktop* Desktop::first = 0;
</t>
<t tx="davidmcnab.041604122248.378">@ return the highest desktop number:
@c

int Desktop::max_number() {
  int n = 0;
  for (Desktop* d = first; d; d = d-&gt;next)
    if (d-&gt;number_ &gt; n) n = d-&gt;number_;
  return n;
}
</t>
<t tx="davidmcnab.041604122248.379">@ return an empty slot number:
@c

int Desktop::available_number() {
  int n = 1;
  for (Desktop* d = first; d;) {
    if (d-&gt;number_ == n) {n++; d = first;}
    else d = d-&gt;next;
  }
  return n;
}
</t>
<t tx="davidmcnab.041604122248.380">@ these are set by main.C:
@c

Atom _win_workspace;
Atom _win_workspace_count;
Atom _win_workspace_names;
#ifndef __sgi
static Atom kwm_current_desktop;
#endif
extern Fl_Window* Root;

static int dont_send;
static void send_desktops() {
  if (dont_send) return;
  int n = Desktop::max_number();
  setProperty(fl_xid(Root), _win_workspace_count, XA_CARDINAL, n);
  char buffer[1025];
  char* p = buffer;
  for (int i = 1; i &lt;= n; i++) {
    Desktop* d = Desktop::number(i);
    const char* name = d ? d-&gt;name() : "&lt;deleted&gt;";
    while (p &lt; buffer+1024 &amp;&amp; *name) *p++ = *name++;
    *p++ = 0;
    if (p &gt;= buffer+1024) break;
  }
  XChangeProperty(fl_display, fl_xid(Root), _win_workspace_names, XA_STRING,
		  8, PropModeReplace, (unsigned char *)buffer, p-buffer-1);
}
</t>
<t tx="davidmcnab.041604122248.381">
Desktop::Desktop(const char* n, int num) {
  next = first;
  first = this;
  name_ = strdup(n);
  number_ = num;
  send_desktops();
}
</t>
<t tx="davidmcnab.041604122248.382">
Desktop::~Desktop() {
  // remove from list:
  for (Desktop** p = &amp;first; *p; p = &amp;((*p)-&gt;next))
    if (*p == this) {*p = next; break;}
  send_desktops();
  if (current_ == this || !first-&gt;next) current(first);
  // put any clients onto another desktop:
  for (Frame* c = Frame::first; c; c = c-&gt;next)
    if (c-&gt;desktop() == this) c-&gt;desktop(first);
  free((void*)name_);
}
</t>
<t tx="davidmcnab.041604122248.383">
void Desktop::name(const char* l) {
  free((void*)name_);
  name_ = strdup(l);
}
</t>
<t tx="davidmcnab.041604122248.384">
void Desktop::current(Desktop* n) {
  if (n == current_) return;
  current_ = n;
  for (Frame* c = Frame::first; c; c = c-&gt;next) {
    if (c-&gt;desktop() == n) {
      if (c-&gt;state() == OTHER_DESKTOP) c-&gt;state(NORMAL);
    } else if (c-&gt;desktop()) {
      if (c-&gt;state() == NORMAL) c-&gt;state(OTHER_DESKTOP);
    }
  }
  if (n &amp;&amp; !dont_send) {
#ifndef __sgi
    setProperty(fl_xid(Root), kwm_current_desktop, kwm_current_desktop, n-&gt;number());
#endif
    setProperty(fl_xid(Root), _win_workspace, XA_CARDINAL, n-&gt;number()-1);
  }
}
</t>
<t tx="davidmcnab.041604122248.385">@ return desktop with given number, create it if necessary:
@c

Desktop* Desktop::number(int n, int create) {
  if (!n) return 0;
  Desktop* d;
  for (d = first; d; d = d-&gt;next) if (d-&gt;number() == n) return d;
  if (create) {
    char buf[20]; sprintf(buf, "Desktop %d", n);
    d = new Desktop(buf,n);
  }
  return d;
}
</t>
<t tx="davidmcnab.041604122248.386">@ called at startup, read the list of desktops from the root
window properties, or on failure make some default desktops.
@c

void init_desktops() {
  dont_send = 1;
  int length;
  char* buffer =
    (char*)getProperty(fl_xid(Root), _win_workspace_names, XA_STRING, &amp;length);
  if (buffer) {
    char* c = buffer;
    for (int i = 1; c &lt; buffer+length; i++) {
      char* d = c; while (*d) d++;
      if (*c != '&lt;') new Desktop(c,i);
      c = d+1;
    }
    XFree(buffer);
  }
  int current_num = 0;
  int p = getIntProperty(fl_xid(Root), _win_workspace, XA_CARDINAL, -1);
  if (p &gt;= 0 &amp;&amp; p &lt; 25) current_num = p+1;
#ifndef __sgi
  // SGI's Xlib barfs when you try to do this XInternAtom!
  // Maybe somebody there does not like KDE?
  kwm_current_desktop = XInternAtom(fl_display, "KWM_CURRENT_DESKTOP", 0);
  if (!current_num) {
    p = getIntProperty(fl_xid(Root), kwm_current_desktop, kwm_current_desktop);
    if (p &gt; 0 &amp;&amp; p &lt; 25) current_num = p;
  }
#endif
  if (!current_num) current_num = 1;
  Desktop::current(Desktop::number(current_num, 1));
  dont_send = 0;
}
</t>
<t tx="davidmcnab.041604122248.387">@language c
// Frame.H


// Each X window being managed by fltk has one of these

#ifndef Frame_H
#define Frame_H

#include &lt;FL/Fl.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;
#include &lt;FL/x.H&gt;

// The state is an enumeration of reasons why the window may be invisible.
// Only if it is NORMAL is the window visible.
enum {
  UNMAPPED	= 0,	// unmap command from app (X calls this WithdrawnState)
  NORMAL	= 1,	// window is visible
//SHADED	= 2,	// acts like NORMAL
  ICONIC	= 3,	// hidden/iconized
  OTHER_DESKTOP	= 4	// normal but on another desktop
};

// values for flags:
// The flags are constant and are turned on by information learned
// from the Gnome, KDE, and/or Motif window manager hints.  Flwm will
// ignore attempts to change these hints after the window is mapped.
enum {
  NO_FOCUS		= 0x0001, // does not take focus
  CLICK_TO_FOCUS	= 0x0002, // must click on window to give it focus
  NO_BORDER		= 0x0004, // raw window with no border
  THIN_BORDER		= 0x0008, // just resize border
  NO_RESIZE		= 0x0010, // don't resize even if sizehints say its ok
  NO_CLOSE		= 0x0040, // don't put a close box on it
  TAKE_FOCUS_PROTOCOL	= 0x0080, // send junk when giving window focus
  DELETE_WINDOW_PROTOCOL= 0x0100, // close box sends a message
  KEEP_ASPECT		= 0x0200, // aspect ratio from sizeHints
  MODAL			= 0x0400, // grabs focus from transient_for window
  ICONIZE		= 0x0800, // transient_for_ actually means group :-(
  QUIT_PROTOCOL		= 0x1000, // Irix 4DWM "quit" menu item
  SAVE_PROTOCOL		= 0x2000  // "WM_SAVE_YOURSELF" stuff
};

// values for state_flags:
// These change over time
enum {
  IGNORE_UNMAP		= 0x01,	// we did something that echos an UnmapNotify
  SAVE_PROTOCOL_WAIT	= 0x02
};

class FrameButton : public Fl_Button {
  void draw();
public:
  FrameButton(int X, int Y, int W, int H, const char* L=0)
    : Fl_Button(X,Y,W,H,L) {}
};

class Desktop;

class Frame : public Fl_Window {

  Window window_;

  short state_;		// X server state: iconic, withdrawn, normal
  short state_flags_;	// above state flags
  void set_state_flag(short i) {state_flags_ |= i;}
  void clear_state_flag(short i) {state_flags_&amp;=~i;}

  int flags_;		// above constant flags
  void set_flag(int i) {flags_ |= i;}
  void clear_flag(int i) {flags_&amp;=~i;}

  int restore_x, restore_w; // saved size when min/max width is set
  int restore_y, restore_h; // saved size when max height is set
  int min_w, max_w, inc_w; // size range and increment
  int min_h, max_h, inc_h; // size range and increment
  int app_border_width;	// value of border_width application tried to set

  int left, top, dwidth, dheight; // current thickness of border
  int label_y, label_h; // location of label
  int label_w;		// measured width of printed label

  Window transient_for_xid; // value from X
  Frame* transient_for_; // the frame for that xid, if found

  Frame* revert_to;	// probably the xterm this was run from

  Colormap colormap;	// this window's colormap
  int colormapWinCount; // list of other windows to install colormaps for
  Window *colormapWindows;
  Colormap *window_Colormaps; // their colormaps

  Desktop* desktop_;

  FrameButton close_button;
  FrameButton iconize_button;
  FrameButton max_h_button;
  FrameButton max_w_button;
  FrameButton min_w_button;

  int force_x_onscreen(int X, int W);
  int force_y_onscreen(int Y, int H);

  void sendMessage(Atom, Atom) const;
  void sendConfigureNotify() const;
  void setStateProperty() const;

  void* getProperty(Atom, Atom = AnyPropertyType, int* length = 0) const;
  int  getIntProperty(Atom, Atom = AnyPropertyType, int deflt = 0) const;
  void setProperty(Atom, Atom, int) const;
  void getLabel(int del = 0);
  void getColormaps();
  int  getGnomeState(int&amp;);
  void getProtocols();
  int  getMotifHints();
  void updateBorder();
  void fix_transient_for(); // called when transient_for_xid changes

  void installColormap() const;

  int handle(int);	// handle fltk events
  void set_cursor(int);
  int mouse_location();

  void draw();

  static Frame* active_;
  static void button_cb_static(Fl_Widget*, void*);
  void button_cb(Fl_Button*);

  int activate_if_transient();
  void _desktop(Desktop*);

  int border() const {return !(flags_&amp;NO_BORDER);}
  int flags() const {return flags_;}
  int flag(int i) const {return flags_&amp;i;}
  void throw_focus(int destructor = 0);
  void warp_pointer();

public:

  // moved by me into public


  void set_size(int,int,int,int, int warp=0, int noresize=0);
  void resize(int,int,int,int);
  void show_hide_buttons();
  int maximize_width();
  int maximize_height();
  int  getSizes();

  int handle(const XEvent*);

  static Frame* first;
  Frame* next;		// stacking order, top to bottom

  Frame(Window, XWindowAttributes* = 0);
  ~Frame();

  Window window() const {return window_;}
  Frame* transient_for() const {return transient_for_;}
  int is_transient_for(const Frame*) const;

  Desktop* desktop() const {return desktop_;}
  void desktop(Desktop*);

  void setBorder(int mode);

  void raise(); // also does map
  void lower();
  void iconize();
  void close();
  void kill();
  int activate(int warp = 0); // returns true if it actually sets active state
  void deactivate();
  short state() const {return state_;}
  void state(short); // don't call this unless you know what you are doing!

  int active() const {return active_==this;}
  static Frame* activeFrame() {return active_;}

  static void save_protocol(); // called when window manager exits

  // The following should be conditionally defined based on the
  // SHOW_CLOCK definition in config.h but that definition is not
  // available at the time we are evaluating this; it does no harm
  // to be present even if not SHOW_CLOCK.
  void redraw_clock();

};

// handy wrappers for those ugly X routines:
void* getProperty(Window, Atom, Atom = AnyPropertyType, int* length = 0);
int getIntProperty(Window, Atom, Atom = AnyPropertyType, int deflt = 0);
void setProperty(Window, Atom, Atom, int);

#endif
</t>
<t tx="davidmcnab.041604122248.388">@language c

// Frame.C

&lt;&lt; Frame #includes &gt;&gt;
&lt;&lt; Frame declarations &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.389">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#include &lt;FL/fl_draw.H&gt;

#include "config.h"
#include "Frame.h"
#include "Desktop.h"
#include "Rotated.h"

#include "Python.h"
#include "pycallbacks.h"

</t>
<t tx="davidmcnab.041604122248.390">
static Atom wm_state = 0;
static Atom wm_change_state;
static Atom wm_protocols;
static Atom wm_delete_window;
static Atom wm_take_focus;
static Atom wm_save_yourself;
static Atom wm_colormap_windows;
static Atom _motif_wm_hints;
static Atom kwm_win_decoration;
#if DESKTOPS
static Atom kwm_win_desktop;
static Atom kwm_win_sticky;
#endif
//static Atom wm_client_leader;
static Atom _wm_quit_app;

// these are set by initialize in main.C:
Atom _win_hints;
Atom _win_state;
#if DESKTOPS
extern Atom _win_workspace;
#endif

#ifdef SHOW_CLOCK
extern char clock_buf[];
extern int clock_alarm_on;
#endif

static const int XEventMask =
ExposureMask|StructureNotifyMask
|KeyPressMask|KeyReleaseMask|KeymapStateMask|FocusChangeMask
|ButtonPressMask|ButtonReleaseMask
|EnterWindowMask|LeaveWindowMask
|PointerMotionMask|SubstructureRedirectMask|SubstructureNotifyMask;

extern Fl_Window* Root;

Frame* Frame::active_;
Frame* Frame::first;

static int pywmNesting = 0;

extern "C" char *getWindowName(Window w);
</t>
<t tx="davidmcnab.041604122248.391">
static inline int max(int a, int b) {return a &gt; b ? a : b;}
</t>
<t tx="davidmcnab.041604122248.392">static inline int min(int a, int b) {return a &lt; b ? a : b;}
</t>
<t tx="davidmcnab.041604122248.393">@ modify the passed X &amp; W to a legal horizontal window position
@c

int Frame::force_x_onscreen(int X, int W) {
  // force all except the black border on-screen:
  X = min(X, Root-&gt;x()+Root-&gt;w()+1-W);
  X = max(X, Root-&gt;x()-1);
  // force the contents on-screen:
  X = min(X, Root-&gt;x()+Root-&gt;w()-W+dwidth-left);
  if (W-dwidth &gt; Root-&gt;w() || h()-dheight &gt; Root-&gt;h())
    // windows bigger than the screen need title bar so they can move
    X = max(X, Root-&gt;x()-LEFT);
  else
    X = max(X, Root-&gt;x()-left);
  return X;
}
</t>
<t tx="davidmcnab.041604122248.394">@ modify the passed Y &amp; H to a legal vertical window position:
@c

int Frame::force_y_onscreen(int Y, int H) {
  // force border (except black edge) to be on-screen:
  Y = min(Y, Root-&gt;y()+Root-&gt;h()+1-H);
  Y = max(Y, Root-&gt;y()-1);
  // force contents to be on-screen:
  Y = min(Y, Root-&gt;y()+Root-&gt;h()-H+dheight-top);
  Y = max(Y, Root-&gt;y()-top);
  return Y;
}
</t>
<t tx="davidmcnab.041604122248.395">
////////////////////////////////////////////////////////////////

void Frame::getLabel(int del) {
  char* old = (char*)label();
  char* nu = del ? 0 : (char*)getProperty(XA_WM_NAME);
  if (nu) {
    // since many window managers print a default label when none is
    // given, many programs send spaces to make a blank label.  Detect
    // this and make it really be blank:
    char* c = nu; while (*c == ' ') c++;
    if (!*c) {XFree(nu); nu = 0;}
  }
  if (old) {
    if (nu &amp;&amp; !strcmp(old,nu)) {XFree(nu); return;}
    XFree(old);
  } else {
    if (!nu) return;
  }
  Fl_Widget::label(nu);
  if (nu) {
    fl_font(TITLE_FONT_SLOT, TITLE_FONT_SIZE);
    label_w = int(fl_width(nu))+6;
  } else
    label_w = 0;
  if (shown() &amp;&amp; label_h &gt; 3 &amp;&amp; left &gt; 3)
    XClearArea(fl_display, fl_xid(this), 1, label_y+3, left-1, label_h-3, 1);
}
</t>
<t tx="davidmcnab.041604122248.396">
////////////////////////////////////////////////////////////////

int Frame::getGnomeState(int &amp;) {
// values for _WIN_STATE property are from Gnome WM compliance docs:
#define WIN_STATE_STICKY          (1&lt;&lt;0) /*everyone knows sticky*/
#define WIN_STATE_MINIMIZED       (1&lt;&lt;1) /*Reserved - definition is unclear*/
#define WIN_STATE_MAXIMIZED_VERT  (1&lt;&lt;2) /*window in maximized V state*/
#define WIN_STATE_MAXIMIZED_HORIZ (1&lt;&lt;3) /*window in maximized H state*/
#define WIN_STATE_HIDDEN          (1&lt;&lt;4) /*not on taskbar but window visible*/
#define WIN_STATE_SHADED          (1&lt;&lt;5) /*shaded (MacOS / Afterstep style)*/
#define WIN_STATE_HID_WORKSPACE   (1&lt;&lt;6) /*not on current desktop*/
#define WIN_STATE_HID_TRANSIENT   (1&lt;&lt;7) /*owner of transient is hidden*/
#define WIN_STATE_FIXED_POSITION  (1&lt;&lt;8) /*window is fixed in position even*/
#define WIN_STATE_ARRANGE_IGNORE  (1&lt;&lt;9) /*ignore for auto arranging*/
  // nyi
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.397">@ Read the sizeHints, and try to remove the vast number of mistakes
that some applications seem to do writing them.
Returns true if autoplace should be done.
@c

int Frame::getSizes() {

  XSizeHints sizeHints;
  long junk;
  if (!XGetWMNormalHints(fl_display, window_, &amp;sizeHints, &amp;junk))
    sizeHints.flags = 0;

  // get the increment, use 1 if none or illegal values:
  if (sizeHints.flags &amp; PResizeInc) {
    inc_w = sizeHints.width_inc; if (inc_w &lt; 1) inc_w = 1;
    inc_h = sizeHints.height_inc; if (inc_h &lt; 1) inc_h = 1;
  } else {
    inc_w = inc_h = 1;
  }

  // get the current size of the window:
  int W = w()-dwidth;
  int H = h()-dheight;
  // I try a lot of places to get a good minimum size value.  Lots of
  // programs set illegal or junk values, so getting this correct is
  // difficult:
  min_w = W;
  min_h = H;

  // guess a value for minimum size in case it is not set anywhere:
  min_w = min(min_w, 4*BUTTON_H);
  min_w = ((min_w+inc_w-1)/inc_w) * inc_w;
  min_h = min(min_h, 4*BUTTON_H);
  min_h = ((min_h+inc_h-1)/inc_h) * inc_h;
  // some programs put the minimum size here:
  if (sizeHints.flags &amp; PBaseSize) {
    junk = sizeHints.base_width; if (junk &gt; 0) min_w = junk;
    junk = sizeHints.base_height; if (junk &gt; 0) min_h = junk;
  }
  // finally, try the actual place the minimum size should be:
  if (sizeHints.flags &amp; PMinSize) {
    junk = sizeHints.min_width; if (junk &gt; 0) min_w = junk;
    junk = sizeHints.min_height; if (junk &gt; 0) min_h = junk;
  }

  max_w = max_h = 0; // default maximum size is "infinity"
  if (sizeHints.flags &amp; PMaxSize) {
    // Though not defined by ICCCM standard, I interpret any maximum
    // size that is less than the minimum to mean "infinity".  This
    // allows the maximum to be set in one direction only:
    junk = sizeHints.max_width;
    if (junk &gt;= min_w &amp;&amp; junk &lt;= W) max_w = junk;
    junk = sizeHints.max_height;
    if (junk &gt;= min_h &amp;&amp; junk &lt;= H) max_h = junk;
  }

  // set the maximize buttons according to current size:
  max_w_button.value(W == maximize_width());
  max_h_button.value(H == maximize_height());

  // Currently only 1x1 aspect works:
  if (sizeHints.flags &amp; PAspect
      &amp;&amp; sizeHints.min_aspect.x == sizeHints.min_aspect.y)
    set_flag(KEEP_ASPECT);

  // another fix for gimp, which sets PPosition to 0,0:
  if (x() &lt;= 0 &amp;&amp; y() &lt;= 0) sizeHints.flags &amp;= ~PPosition;

  return !(sizeHints.flags &amp; (USPosition|PPosition));
}
</t>
<t tx="davidmcnab.041604122248.398">
int max_w_switch;
// return width of contents when maximize button pressed:
int Frame::maximize_width() {
  int W = max_w_switch; if (!W) W = Root-&gt;w();
  return ((W-TITLE_WIDTH-min_w)/inc_w) * inc_w + min_w;
}
</t>
<t tx="davidmcnab.041604122248.399">
int max_h_switch;
int Frame::maximize_height() {
  int H = max_h_switch; if (!H) H = Root-&gt;h();
  return ((H-min_h)/inc_h) * inc_h + min_h;
}
</t>
<t tx="davidmcnab.041604122248.400">
////////////////////////////////////////////////////////////////

void Frame::getProtocols() {
  int n; Atom* p = (Atom*)getProperty(wm_protocols, XA_ATOM, &amp;n);
  if (p) {
    clear_flag(DELETE_WINDOW_PROTOCOL|TAKE_FOCUS_PROTOCOL|QUIT_PROTOCOL);
    for (int i = 0; i &lt; n; ++i) {
      if (p[i] == wm_delete_window) {
	set_flag(DELETE_WINDOW_PROTOCOL);
      } else if (p[i] == wm_take_focus) {
	set_flag(TAKE_FOCUS_PROTOCOL);
      } else if (p[i] == wm_save_yourself) {
	set_flag(SAVE_PROTOCOL);
      } else if (p[i] == _wm_quit_app) {
	set_flag(QUIT_PROTOCOL);
      }
    }
  }
  XFree((char*)p);
}
</t>
<t tx="davidmcnab.041604122248.401">
////////////////////////////////////////////////////////////////

int Frame::getMotifHints() {
  long* prop = (long*)getProperty(_motif_wm_hints, _motif_wm_hints);
  if (!prop) return 0;

  // see /usr/include/X11/Xm/MwmUtil.h for meaning of these bits...
  // prop[0] = flags (what props are specified)
  // prop[1] = functions (all, resize, move, minimize, maximize, close, quit)
  // prop[2] = decorations (all, border, resize, title, menu, minimize,
  //                        maximize)
  // prop[3] = input_mode (modeless, primary application modal, system modal,
  //                       full application modal)
  // prop[4] = status (tear-off window)

  // Fill in the default value for missing fields:
  if (!(prop[0]&amp;1)) prop[1] = 1;
  if (!(prop[0]&amp;2)) prop[2] = 1;

  // The low bit means "turn the marked items off", invert this.
  // Transient windows already have size &amp; iconize buttons turned off:
  if (prop[1]&amp;1) prop[1] = ~prop[1] &amp; (transient_for_xid ? ~0x58 : -1);
  if (prop[2]&amp;1) prop[2] = ~prop[2] &amp; (transient_for_xid ? ~0x60 : -1);

  int old_flags = flags();

  // see if they are trying to turn off border:
  if (!(prop[2])) set_flag(NO_BORDER); else clear_flag(NO_BORDER);

  // see if they are trying to turn off title &amp; close box:
  if (!(prop[2]&amp;0x18)) set_flag(THIN_BORDER); else clear_flag(THIN_BORDER);

  // some Motif programs use this to disable resize :-(
  // and some programs change this after the window is shown (*&amp;%$#%)
  if (!(prop[1]&amp;2) || !(prop[2]&amp;4))
    set_flag(NO_RESIZE); else clear_flag(NO_RESIZE);

  // and some use this to disable the Close function.  The commented
  // out test is it trying to turn off the mwm menu button: it appears
  // programs that do that still expect Alt+F4 to close them, so I
  // leave the close on then:
  if (!(prop[1]&amp;0x20) /*|| !(prop[2]&amp;0x10)*/)
    set_flag(NO_CLOSE); else clear_flag(NO_CLOSE);

  // see if they set "input hint" to non-zero:
  // prop[3] should be nonzero but the only example of this I have
  // found is Netscape 3.0 and it sets it to zero...
  if (!shown() &amp;&amp; (prop[0]&amp;4) /*&amp;&amp; prop[3]*/) set_flag(MODAL);

  // see if it is forcing the iconize button back on.  This makes
  // transient_for act like group instead...
  if ((prop[1]&amp;0x8) || (prop[2]&amp;0x20)) set_flag(ICONIZE);

  // Silly 'ol Amazon paint ignores WM_DELETE_WINDOW and expects to
  // get the SGI-specific "_WM_QUIT_APP".  It indicates this by trying
  // to turn off the close box. SIGH!!!
  if (flag(QUIT_PROTOCOL) &amp;&amp; !(prop[1]&amp;0x20))
    clear_flag(DELETE_WINDOW_PROTOCOL);

  XFree((char*)prop);
  return (flags() ^ old_flags);
}
</t>
<t tx="davidmcnab.041604122248.402">
////////////////////////////////////////////////////////////////

void Frame::getColormaps(void) {
  if (colormapWinCount) {
    XFree((char *)colormapWindows);
    delete[] window_Colormaps;
  }
  int n;
  Window* cw = (Window*)getProperty(wm_colormap_windows, XA_WINDOW, &amp;n);
  if (cw) {
    colormapWinCount = n;
    colormapWindows = cw;
    window_Colormaps = new Colormap[n];
    for (int i = 0; i &lt; n; ++i) {
      if (cw[i] == window_) {
	window_Colormaps[i] = colormap;
      } else {
	XWindowAttributes attr;
	XSelectInput(fl_display, cw[i], ColormapChangeMask);
	XGetWindowAttributes(fl_display, cw[i], &amp;attr);
	window_Colormaps[i] = attr.colormap;
      }
    }
  } else {
    colormapWinCount = 0;
  }
}
</t>
<t tx="davidmcnab.041604122248.403">
void Frame::installColormap() const {
  for (int i = colormapWinCount; i--;)
    if (colormapWindows[i] != window_ &amp;&amp; window_Colormaps[i])
      XInstallColormap(fl_display, window_Colormaps[i]);
  if (colormap)
    XInstallColormap(fl_display, colormap);
}
</t>
<t tx="davidmcnab.041604122248.404">@ figure out transient_for(), based on the windows that exist, the
transient_for and group attributes, etc:
@c

void Frame::fix_transient_for() {
  Frame* p = 0;
  if (transient_for_xid &amp;&amp; !flag(ICONIZE)) {
    for (Frame* f = first; f; f = f-&gt;next) {
      if (f != this &amp;&amp; f-&gt;window_ == transient_for_xid) {p = f; break;}
    }
    // loops are illegal:
    for (Frame* q = p; q; q = q-&gt;transient_for_) if (q == this) {p = 0; break;}
  }
  transient_for_ = p;
}
</t>
<t tx="davidmcnab.041604122248.405">
int Frame::is_transient_for(const Frame* f) const {
  if (f)
    for (Frame* p = transient_for(); p; p = p-&gt;transient_for())
      if (p == f) return 1;
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.406">@ When a program maps or raises a window, this is called. It guesses
if this window is in fact a modal window for the currently active
window and if so transfers the active state to this:
This also activates new main windows automatically
@c

int Frame::activate_if_transient() {
  if (!Fl::pushed())
    if (!transient_for() || is_transient_for(active_)) return activate(1);
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.407">
#if CLICK_RAISES || CLICK_TO_TYPE
// After the XGrabButton, the main loop will get the mouse clicks, and
// it will call here when it gets them:
void click_raise(Frame* f) {
  f-&gt;activate();
#if CLICK_RAISES
  if (fl_xevent-&gt;xbutton.button &lt;= 1) f-&gt;raise();
#endif
  XAllowEvents(fl_display, ReplayPointer, CurrentTime);
}
</t>
<t tx="davidmcnab.041604122248.408">#endif

// get rid of the focus by giving it to somebody, if possible:
void Frame::throw_focus(int destructor) {
  if (!active()) return;
  if (!destructor) deactivate();
  active_ = 0;
  if (revert_to &amp;&amp; revert_to-&gt;activate()) return;
  for (Frame* f = first; f; f = f-&gt;next)
    if (f != this &amp;&amp; f-&gt;activate()) return;
}
</t>
<t tx="davidmcnab.041604122248.409">@ change the state of the window (this is a private function and
it ignores the transient-for or desktop information):
@c

void Frame::state(short newstate) {
  short oldstate = state();
  if (newstate == oldstate) return;
  state_ = newstate;
  switch (newstate) {
  case UNMAPPED:
    throw_focus();
    set_state_flag(IGNORE_UNMAP);
    XUnmapWindow(fl_display, fl_xid(this));
    XUnmapWindow(fl_display, window_);
    XRemoveFromSaveSet(fl_display, window_);
    break;
  case NORMAL:
    if (oldstate == UNMAPPED) XAddToSaveSet(fl_display, window_);
    if (w() &gt; dwidth) XMapWindow(fl_display, window_);
    XMapWindow(fl_display, fl_xid(this));
    clear_state_flag(IGNORE_UNMAP);
    break;
  default:
    if (oldstate == UNMAPPED) {
      XAddToSaveSet(fl_display, window_);
    } else if (oldstate == NORMAL) {
      throw_focus();
      set_state_flag(IGNORE_UNMAP);
      XUnmapWindow(fl_display, fl_xid(this));
      XUnmapWindow(fl_display, window_);
    } else {
      return; // don't setStateProperty IconicState multiple times
    }
    break;
  }
  setStateProperty();
}
</t>
<t tx="davidmcnab.041604122248.410">
void Frame::setStateProperty() const {
  long data[2];
  switch (state()) {
  case UNMAPPED :
    data[0] = WithdrawnState; break;
  case NORMAL :
  case OTHER_DESKTOP :
    data[0] = NormalState; break;
  default :
    data[0] = IconicState; break;
  }
  data[1] = (long)None;
  XChangeProperty(fl_display, window_, wm_state, wm_state,
		  32, PropModeReplace, (unsigned char *)data, 2);
}
</t>
<t tx="davidmcnab.041604122248.411">@ Public state modifiers that move all transient_for(this) children
with the frame and do the desktops right:
@c

void Frame::raise() {
  Frame* newtop = 0;
  Frame* previous = 0;
  int previous_state = state_;
  Frame** p;
  // Find all the transient-for windows and this one, and raise them,
  // preserving stacking order:
  for (p = &amp;first; *p;) {
    Frame* f = *p;
    if (f == this || f-&gt;is_transient_for(this) &amp;&amp; f-&gt;state() != UNMAPPED) {
      *p = f-&gt;next; // remove it from list
      if (previous) {
	XWindowChanges w;
	w.sibling = fl_xid(previous);
	w.stack_mode = Below;
	XConfigureWindow(fl_display, fl_xid(f), CWSibling|CWStackMode, &amp;w);
	previous-&gt;next = f;
      } else {
	XRaiseWindow(fl_display, fl_xid(f));
	newtop = f;
      }
#if DESKTOPS
      if (f-&gt;desktop_ &amp;&amp; f-&gt;desktop_ != Desktop::current())
       f-&gt;state(OTHER_DESKTOP);
      else
#endif
	f-&gt;state(NORMAL);
      previous = f;
    } else {
      p = &amp;((*p)-&gt;next);
    }
  }
  previous-&gt;next = first;
  first = newtop;
#if DESKTOPS
  if (!transient_for() &amp;&amp; desktop_ &amp;&amp; desktop_ != Desktop::current()) {
    // for main windows we also must move to the current desktop
    desktop(Desktop::current());
  }
#endif
  if (previous_state != NORMAL &amp;&amp; newtop-&gt;state_==NORMAL)
    newtop-&gt;activate_if_transient();
}
</t>
<t tx="davidmcnab.041604122248.412">
void Frame::lower() {
  Frame* t = transient_for(); if (t) t-&gt;lower();
  if (!next || next == t) return; // already on bottom
  // pull it out of the list:
  Frame** p = &amp;first;
  for (; *p != this; p = &amp;((*p)-&gt;next)) {}
  *p = next;
  // find end of list:
  Frame* f = next; while (f-&gt;next != t) f = f-&gt;next;
  // insert it after that:
  f-&gt;next = this; next = t;
  // and move the X window:
  XWindowChanges w;
  w.sibling = fl_xid(f);
  w.stack_mode = Below;
  XConfigureWindow(fl_display, fl_xid(this), CWSibling|CWStackMode, &amp;w);
}
</t>
<t tx="davidmcnab.041604122248.413">
void Frame::iconize() {
  for (Frame* c = first; c; c = c-&gt;next) {
    if (c == this || c-&gt;is_transient_for(this) &amp;&amp; c-&gt;state() != UNMAPPED)
      c-&gt;state(ICONIC);
  }
}
</t>
<t tx="davidmcnab.041604122248.414">
#if DESKTOPS
void Frame::desktop(Desktop* d) {
  if (d == desktop_) return;
  // Put all the relatives onto the desktop as well:
  for (Frame* c = first; c; c = c-&gt;next) {
    if (c == this || c-&gt;is_transient_for(this)) {
      c-&gt;desktop_ = d;
      c-&gt;setProperty(_win_state, XA_CARDINAL, !d);
      c-&gt;setProperty(kwm_win_sticky, kwm_win_sticky, !d);
      if (d) {
	c-&gt;setProperty(kwm_win_desktop, kwm_win_desktop, d-&gt;number());
	c-&gt;setProperty(_win_workspace, XA_CARDINAL, d-&gt;number()-1);
      }
      if (!d || d == Desktop::current()) {
	if (c-&gt;state() == OTHER_DESKTOP) c-&gt;state(NORMAL);
      } else {
	if (c-&gt;state() == NORMAL) c-&gt;state(OTHER_DESKTOP);
      }
    }
  }
}
</t>
<t tx="davidmcnab.041604122248.415">void Frame::setBorder(int mode)
{
    clear_flag(THIN_BORDER);
    clear_flag(NO_BORDER);
    
    switch (mode)
    {
    case 1:
      set_flag(THIN_BORDER);
      break;
    case 2:
      set_flag(NO_BORDER);
      break;
    default:
      break;
    }
    
    updateBorder();
}


</t>
<t tx="davidmcnab.041604122248.416">
void Frame::sendConfigureNotify() const {
  XConfigureEvent ce;
  ce.type   = ConfigureNotify;
  ce.event  = window_;
  ce.window = window_;
  ce.x = x()+left-app_border_width;
  ce.y = y()+top-app_border_width;
  ce.width  = w()-dwidth;
  ce.height = h()-dheight;
  ce.border_width = app_border_width;
  ce.above = None;
  ce.override_redirect = 0;
  XSendEvent(fl_display, window_, False, StructureNotifyMask, (XEvent*)&amp;ce);
}
</t>
<t tx="davidmcnab.041604122248.417">@ move the pointer inside the window:
@c

void Frame::warp_pointer() {
  int X,Y; Fl::get_mouse(X,Y);
  X -= x();
  int Xi = X;
  if (X &lt;= 0) X = left/2+1;
  if (X &gt;= w()) X = w()-(RIGHT/2+1);
  Y -= y();
  int Yi = Y;
  if (Y &lt; 0) Y = TOP/2+1;
  if (Y &gt;= h()) Y = h()-(BOTTOM/2+1);
  if (X != Xi || Y != Yi)
    XWarpPointer(fl_display, None, fl_xid(this), 0,0,0,0, X, Y);
}
</t>
<t tx="davidmcnab.041604122248.418">@ Resize the frame to match the current border type:
@c

void Frame::updateBorder() {
  int nx = x()+left;
  int ny = y()+top;
  int nw = w()-dwidth;
  int nh = h()-dheight;
  if (flag(NO_BORDER)) {
    left = top = dwidth = dheight = 0;
  } else {
    left = flag(THIN_BORDER) ? LEFT : LEFT+TITLE_WIDTH;
    dwidth = left+RIGHT;
    top = TOP;
    dheight = TOP+BOTTOM;
  }
  nx -= left;
  ny -= top;
  nw += dwidth;
  nh += dheight;
  if (x()==nx &amp;&amp; y()==ny &amp;&amp; w()==nw &amp;&amp; h()==nh) return;
  x(nx); y(ny); w(nw); h(nh);
  if (!shown()) return; // this is so constructor can call this
  // try to make the contents not move while the border changes around it:
  XSetWindowAttributes a;
  a.win_gravity = StaticGravity;
  XChangeWindowAttributes(fl_display, window_, CWWinGravity, &amp;a);
  XMoveResizeWindow(fl_display, fl_xid(this), nx, ny, nw, nh);
  a.win_gravity = NorthWestGravity;
  XChangeWindowAttributes(fl_display, window_, CWWinGravity, &amp;a);
  // fix the window position if the X server didn't do the gravity:
  XMoveWindow(fl_display, window_, left, top);
}
</t>
<t tx="davidmcnab.041604122248.419">@ position and show the buttons according to current border, size,
and other state information:
@c

void Frame::show_hide_buttons() {
  if (flag(THIN_BORDER|NO_BORDER)) {
    iconize_button.hide();
    max_w_button.hide();
    min_w_button.hide();
    max_h_button.hide();
    close_button.hide();
    return;
  }
  int by = BUTTON_TOP;
  if (transient_for()) {
    iconize_button.hide();
    min_w_button.hide();
  } else {
    //iconize_button.position(BUTTON_LEFT,by);
    //by += BUTTON_H;
    iconize_button.position(BUTTON_LEFT,h()-(BUTTON_BOTTOM+(BUTTON_H*3)));
    iconize_button.show();
#if MINIMIZE_BOX
    //min_w_button.position(BUTTON_LEFT,by);
    min_w_button.position(BUTTON_LEFT,h()-(BUTTON_BOTTOM+(BUTTON_H * 2)));
    //by += BUTTON_H;
    min_w_button.show();
#else
    min_w_button.hide();
#endif
  }
  if (min_h == max_h || flag(KEEP_ASPECT|NO_RESIZE) ||
      !max_h_button.value() &amp;&amp; by+label_w+2*BUTTON_H &gt; h()-BUTTON_BOTTOM) {
    max_h_button.hide();
  } else {
    max_h_button.position(BUTTON_LEFT,by);
    max_h_button.show();
    by += BUTTON_H;
  }
  if (min_w == max_w || flag(KEEP_ASPECT|NO_RESIZE) ||
      !max_w_button.value() &amp;&amp; by+label_w+2*BUTTON_H &gt; h()-BUTTON_BOTTOM) {
    max_w_button.hide();
  } else {
    max_w_button.position(BUTTON_LEFT,by);
    max_w_button.show();
    by += BUTTON_H;
  }
  if (label_y != by &amp;&amp; shown())
    XClearArea(fl_display,fl_xid(this), 1, by, left-1, label_h+label_y-by, 1);
  label_y = by;
#if CLOSE_BOX
  if (by+BUTTON_H &gt; h()-BUTTON_BOTTOM || flag(NO_CLOSE)) {
#endif
    label_h = h()-BOTTOM-by;
    close_button.hide();
#if CLOSE_BOX
  } else {
    close_button.show();
    close_button.position(BUTTON_LEFT,h()-(BUTTON_BOTTOM+BUTTON_H));
    label_h = close_button.y()-by;
  }
#endif
}

</t>
<t tx="davidmcnab.041604122248.420">@ make sure fltk does not try to set the window size:
@c

void Frame::resize(int, int, int, int) {}
</t>
<t tx="davidmcnab.041604122248.421">
////////////////////////////////////////////////////////////////

void Frame::close() {
  if (flag(DELETE_WINDOW_PROTOCOL))
    sendMessage(wm_protocols, wm_delete_window);
  else if (flag(QUIT_PROTOCOL))
    sendMessage(wm_protocols, _wm_quit_app);
  else
    kill();
}

</t>
<t tx="davidmcnab.041604122248.422">
void Frame::kill() {
  XKillClient(fl_display, window_);
}
</t>
<t tx="davidmcnab.041604122248.423">@ this is called when window manager exits:
@c

void Frame::save_protocol() {
  Frame* f;
  for (f = first; f; f = f-&gt;next) if (f-&gt;flag(SAVE_PROTOCOL)) {
    f-&gt;set_state_flag(SAVE_PROTOCOL_WAIT);
    f-&gt;sendMessage(wm_protocols, wm_save_yourself);
  }
  double t = 10.0; // number of seconds to wait before giving up
  while (t &gt; 0.0) {
    for (f = first; ; f = f-&gt;next) {
      if (!f) return;
      if (f-&gt;flag(SAVE_PROTOCOL) &amp;&amp; f-&gt;state_flags_&amp;SAVE_PROTOCOL_WAIT) break;
    }
    t = Fl::wait(t);
  }
}
</t>
<t tx="davidmcnab.041604122248.424">@ Drawing code:
@c

void Frame::draw() {
  if (flag(NO_BORDER)) return;
  if (!flag(THIN_BORDER)) Fl_Window::draw();
  if (damage() != FL_DAMAGE_CHILD) {
#if ACTIVE_COLOR
    fl_frame2(active() ? "AAAAJJWW" : "AAAAJJWWNNTT",0,0,w(),h());
    if (active()) {
      fl_color(FL_GRAY_RAMP+('N'-'A'));
      fl_xyline(2, h()-3, w()-3, 2);
    }
#else
    fl_frame("AAAAWWJJTTNN",0,0,w(),h());
#endif
    if (!flag(THIN_BORDER) &amp;&amp; label_h &gt; 3) {
#ifdef SHOW_CLOCK
      if (active()) {
	  int clkw = int(fl_width(clock_buf));
	  if (clock_alarm_on) {
	      fl_font(TITLE_FONT_SLOT, TITLE_FONT_SIZE);
	      fl_rectf(LEFT-1, label_y + label_h - 3 - clkw, TITLE_WIDTH, clkw,
		       (ALARM_BG_COLOR&gt;&gt;16)&amp;0xff,
		       (ALARM_BG_COLOR&gt;&gt;8)&amp;0xff,
		       ALARM_BG_COLOR&amp;0xff);
	      fl_color((ALARM_FG_COLOR&gt;&gt;16)&amp;0xff,
		       (ALARM_FG_COLOR&gt;&gt;8)&amp;0xff,
		       ALARM_FG_COLOR&amp;0xff);
	  } else
	      fl_font(MENU_FONT_SLOT, TITLE_FONT_SIZE);
	  // This might overlay the label if the label is long enough
	  // and the window height is short enough.  For now, we'll
	  // assume this is not enough of a problem to be concerned
	  // about.
	  draw_rotated90(clock_buf, 1, label_y+3, left-1, label_h-6,
			 Fl_Align(FL_ALIGN_BOTTOM|FL_ALIGN_CLIP));
      } else
	  // Only show the clock on the active frame.
	  XClearArea(fl_display, fl_xid(this), 1, label_y+3,
		     left-1, label_h-3, 0);
#endif      
      fl_color(labelcolor());
      fl_font(TITLE_FONT_SLOT, TITLE_FONT_SIZE);
      draw_rotated90(label(), 1, label_y+3, left-1, label_h-3,
		     Fl_Align(FL_ALIGN_TOP|FL_ALIGN_CLIP));
    }
  }
}
</t>
<t tx="davidmcnab.041604122248.425">
#ifdef SHOW_CLOCK
void Frame::redraw_clock() {
    double clkw = fl_width(clock_buf);
    XClearArea(fl_display, fl_xid(this),
	       1, label_y+label_h-3-(int)clkw,
	       left-1, (int)clkw, 1);
}
</t>
<t tx="davidmcnab.041604122248.426">#endif

void FrameButton::draw() {
  Fl_Widget::draw_box(value() ? FL_DOWN_FRAME : FL_UP_FRAME, FL_GRAY);
  fl_color(parent()-&gt;labelcolor());
  switch (label()[0]) {
  case 'W':
#if MINIMIZE_ARROW
    fl_line (x()+2,y()+(h())/2,x()+w()-4,y()+h()/2);
    fl_line (x()+2,y()+(h())/2,x()+2+4,y()+h()/2+4);
    fl_line (x()+2,y()+(h())/2,x()+2+4,y()+h()/2-4);
#else
    fl_rect(x()+(h()-7)/2,y()+3,2,h()-6);
#endif
    return;
  case 'w':
    fl_rect(x()+2,y()+(h()-7)/2,w()-4,7);
    return;
  case 'h':
    fl_rect(x()+(h()-7)/2,y()+2,7,h()-4);
    return;
  case 'X':
#if CLOSE_X
    fl_line(x()+2,y()+3,x()+w()-5,y()+h()-4);
    fl_line(x()+3,y()+3,x()+w()-4,y()+h()-4);
    fl_line(x()+2,y()+h()-4,x()+w()-5,y()+3);
    fl_line(x()+3,y()+h()-4,x()+w()-4,y()+3);
#endif
#if CLOSE_HITTITE_LIGHTNING
    fl_arc(x()+3,y()+3,w()-6,h()-6,0,360);
    fl_line(x()+7,y()+3, x()+7,y()+11);
#endif
    return;
  case 'i':
#if ICONIZE_BOX
    fl_rect(x()+w()/2-1,y()+h()/2-1,3,3);
#endif
    return;
  }
}
</t>
<t tx="davidmcnab.041604122248.427">@ User interface code:
this is called when user clicks the buttons:
@c

void Frame::button_cb(Fl_Button* b) {
  switch (b-&gt;label()[0]) {
  case 'W':	// minimize button
    if (b-&gt;value()) {
      if (!max_w_button.value()) {
        restore_x = x()+left;
	restore_y = y()+top;
#if MINIMIZE_HEIGHT
	restore_w=w()-dwidth;
	restore_h = h()-dwidth;
#endif
      }
#if MINIMIZE_HEIGHT
      set_size(x(), y(), dwidth-1,
	       min(h(),min(350,label_w+3*BUTTON_H+BUTTON_TOP+BUTTON_BOTTOM)),
	       1);
#else
      set_size(x(), y(), dwidth-1, h(), 1);
#endif
    } else {
#if MINIMIZE_HEIGHT
      set_size(x(), y(), restore_w+dwidth, restore_h+dwidth, 1);
#else
      set_size(x(), y(), restore_w+dwidth, h(), 1);
#endif
    }
    show_hide_buttons();
    break;
  case 'w':	// max-width button
    if (b-&gt;value()) {
      if (!min_w_button.value()) {restore_x=x()+left; restore_w=w()-dwidth;}
      int W = maximize_width()+dwidth;
      int X = force_x_onscreen(x() + (w()-W)/2, W);
      set_size(X, y(), W, h(), 3);
    } else {
      set_size(restore_x-left, y(), restore_w+dwidth, h(), 1);
    }
    show_hide_buttons();
    break;
  case 'h':	// max-height button
    if (b-&gt;value()) {
      restore_y = y()+top;
      restore_h = h()-dwidth;
      int H = maximize_height()+dheight;
      int Y = force_y_onscreen(y() + (h()-H)/2, H);
      set_size(x(), Y, w(), H, 3);
    } else {
      set_size(x(), restore_y-top, w(), restore_h+dwidth, 1);
    }
    break;
  case 'X':
    close();
    break;
  default: // iconize button
    iconize();
    break;
  }
}
</t>
<t tx="davidmcnab.041604122248.428">@ static callback for fltk:
@c

void Frame::button_cb_static(Fl_Widget* w, void*) {
  ((Frame*)(w-&gt;parent()))-&gt;button_cb((Fl_Button*)w);
}
</t>
<t tx="davidmcnab.041604122248.429">@ This method figures out what way the mouse will resize the window.
It is used to set the cursor and to actually control what you grab.
If the window cannot be resized in some direction this should not
return that direction.
@c

int Frame::mouse_location() {
  int x = Fl::event_x();
  int y = Fl::event_y();
  int r = 0;
  if (flag(NO_RESIZE)) return 0;
  if (min_h != max_h) {
    if (y &lt; RESIZE_EDGE) r |= FL_ALIGN_TOP;
    else if (y &gt;= h()-RESIZE_EDGE) r |= FL_ALIGN_BOTTOM;
  }
  if (min_w != max_w) {
#if RESIZE_LEFT
    if (x &lt; RESIZE_EDGE) r |= FL_ALIGN_LEFT;
#else
    if (x &lt; RESIZE_EDGE &amp;&amp; r) r |= FL_ALIGN_LEFT;
#endif
    else if (x &gt;= w()-RESIZE_EDGE) r |= FL_ALIGN_RIGHT;
  }
  return r;
}
</t>
<t tx="davidmcnab.041604122248.430">@ set the cursor correctly for a return value from mouse_location():
@c

void Frame::set_cursor(int r) {
  Fl_Cursor c = r ? FL_CURSOR_ARROW : FL_CURSOR_MOVE;
  switch (r) {
  case FL_ALIGN_TOP:
  case FL_ALIGN_BOTTOM:
    c = FL_CURSOR_NS;
    break;
  case FL_ALIGN_LEFT:
  case FL_ALIGN_RIGHT:
    c = FL_CURSOR_WE;
    break;
  case FL_ALIGN_LEFT|FL_ALIGN_TOP:
  case FL_ALIGN_RIGHT|FL_ALIGN_BOTTOM:
    c = FL_CURSOR_NWSE;
    break;
  case FL_ALIGN_LEFT|FL_ALIGN_BOTTOM:
  case FL_ALIGN_RIGHT|FL_ALIGN_TOP:
    c = FL_CURSOR_NESW;
    break;
  }
  static Frame* previous_frame;
  static Fl_Cursor previous_cursor;
  if (this != previous_frame || c != previous_cursor) {
    previous_frame = this;
    previous_cursor = c;
    cursor(c, CURSOR_FG_SLOT, CURSOR_BG_SLOT);
  }
}
</t>
<t tx="davidmcnab.041604122248.431">
#ifdef AUTO_RAISE
// timeout callback to cause autoraise:
void auto_raise(void*) {
  if (Frame::activeFrame() &amp;&amp; !Fl::grab() &amp;&amp; !Fl::pushed())
    Frame::activeFrame()-&gt;raise();
}
</t>
<t tx="davidmcnab.041604122248.432">#endif

extern void ShowMenu();

// If cursor is in the contents of a window this is set to that window.
// This is only used to force the cursor to an arrow even though X keeps
// sending mysterious erroneous move events:
static Frame* cursor_inside = 0;

// Handle an fltk event.
int Frame::handle(int e) {
  static int what, dx, dy, ix, iy, iw, ih;
  // see if child widget handles event:
  if (Fl_Window::handle(e) &amp;&amp; e != FL_ENTER &amp;&amp; e != FL_MOVE) {
    if (e == FL_PUSH) set_cursor(-1);
    return 1;
  }
  switch (e) {

  case FL_SHOW:
  case FL_HIDE:
    return 0; // prevent fltk from messing things up

  case FL_ENTER:
#if !CLICK_TO_TYPE
    if (Fl::pushed() || Fl::grab()) return 1;
    if (activate()) {
#ifdef AUTO_RAISE
      Fl::remove_timeout(auto_raise);
      Fl::add_timeout(AUTO_RAISE, auto_raise);
#endif
    }
#endif
    goto GET_CROSSINGS;

  case FL_LEAVE:
#if !CLICK_TO_TYPE &amp;&amp; !STICKY_FOCUS
    if (active()) {
      deactivate();
      XSetInputFocus(fl_display, PointerRoot, RevertToPointerRoot,
		     fl_event_time);
      active_ = 0;
    }
#endif
    goto GET_CROSSINGS;

  case 0:
  GET_CROSSINGS:
    // set cursor_inside to true when the mouse is inside a window
    // set it false when mouse is on a frame or outside a window.
    // fltk mangles the X enter/leave events, we need the original ones:

    switch (fl_xevent-&gt;type) {
    case EnterNotify:

      // see if cursor skipped over frame and directly to interior:
      if (fl_xevent-&gt;xcrossing.detail == NotifyVirtual ||
	  fl_xevent-&gt;xcrossing.detail == NotifyNonlinearVirtual)
	cursor_inside = this;

      else {
	// cursor is now pointing at frame:
	cursor_inside = 0;
      }

      // fall through to FL_MOVE:
      break;

    case LeaveNotify:
      if (fl_xevent-&gt;xcrossing.detail == NotifyInferior) {
	// cursor moved from frame to interior
	cursor_inside = this;
	set_cursor(-1);
	return 1;
      }
      return 1;

    default:
      return 0; // other X event we don't understand
    }

  case FL_MOVE:
    if (Fl::belowmouse() != this || cursor_inside == this)
      set_cursor(-1);
    else
      set_cursor(mouse_location());
    return 1;

  case FL_PUSH:
    if (Fl::event_button() &gt; 2) {
      set_cursor(-1);
      ShowMenu();
      return 1;
    }
    ix = x(); iy = y(); iw = w(); ih = h();
    if (!max_w_button.value() &amp;&amp; !min_w_button.value()) {
      restore_x = ix+left; restore_w = iw-dwidth;
    }
#if MINIMIZE_HEIGHT
    if (!min_w_button.value())
#endif
    if (!max_h_button.value()) {
      restore_y = iy+top; restore_h = ih-dwidth;
    }
    what = mouse_location();
    if (Fl::event_button() &gt; 1) what = 0; // middle button does drag
    dx = Fl::event_x_root()-ix;
    if (what &amp; FL_ALIGN_RIGHT) dx -= iw;
    dy = Fl::event_y_root()-iy;
    if (what &amp; FL_ALIGN_BOTTOM) dy -= ih;
    set_cursor(what);
    return 1;
  case FL_DRAG:
    if (Fl::event_is_click()) return 1; // don't drag yet
  case FL_RELEASE:
    if (Fl::event_is_click()) {
      if (Fl::grab()) return 1;
#if CLICK_TO_TYPE
      if (activate()) {
	if (Fl::event_button() &lt;= 1) raise();
	return 1;
      }
#endif
      if (Fl::event_button() &gt; 1) lower(); else raise();
    } else if (!what) {
      int nx = Fl::event_x_root()-dx;
      int W = Root-&gt;x()+Root-&gt;w();
      if (nx+iw &gt; W &amp;&amp; nx+iw &lt; W+SCREEN_SNAP) {
	int t = W+1-iw;
	if (iw &gt;= Root-&gt;w() || x() &gt; t || nx+iw &gt;= W+EDGE_SNAP)
	  t = W+(dwidth-left)-iw;
	if (t &gt;= x() &amp;&amp; t &lt; nx) nx = t;
      }
      int X = Root-&gt;x();
      if (nx &lt; X &amp;&amp; nx &gt; X-SCREEN_SNAP) {
	int t = X-1;
	if (iw &gt;= Root-&gt;w() || x() &lt; t || nx &lt;= X-EDGE_SNAP) t = X-BUTTON_LEFT;
	if (t &lt;= x() &amp;&amp; t &gt; nx) nx = t;
      }
      int ny = Fl::event_y_root()-dy;
      int H = Root-&gt;y()+Root-&gt;h();
      if (ny+ih &gt; H &amp;&amp; ny+ih &lt; H+SCREEN_SNAP) {
	int t = H+1-ih;
	if (ih &gt;= Root-&gt;h() || y() &gt; t || ny+ih &gt;= H+EDGE_SNAP)
	  t = H+(dheight-top)-ih;
	if (t &gt;= y() &amp;&amp; t &lt; ny) ny = t;
      }
      int Y = Root-&gt;y();
      if (ny &lt; Y &amp;&amp; ny &gt; Y-SCREEN_SNAP) {
	int t = Y-1;
	if (ih &gt;= H || y() &lt; t || ny &lt;= Y-EDGE_SNAP) t = Y-top;
	if (t &lt;= y() &amp;&amp; t &gt; ny) ny = t;
      }
      set_size(nx, ny, iw, ih);
    } else {
      int nx = ix;
      int ny = iy;
      int nw = iw;
      int nh = ih;
      if (what &amp; FL_ALIGN_RIGHT)
	nw = Fl::event_x_root()-dx-nx;
      else if (what &amp; FL_ALIGN_LEFT)
	nw = ix+iw-(Fl::event_x_root()-dx);
      else {nx = x(); nw = w();}
      if (what &amp; FL_ALIGN_BOTTOM)
	nh = Fl::event_y_root()-dy-ny;
      else if (what &amp; FL_ALIGN_TOP)
	nh = iy+ih-(Fl::event_y_root()-dy);
      else {ny = y(); nh = h();}
      if (flag(KEEP_ASPECT)) {
	if (nw-dwidth &gt; nh-dwidth
	    &amp;&amp; (what&amp;(FL_ALIGN_LEFT|FL_ALIGN_RIGHT))
	    || !(what&amp;(FL_ALIGN_TOP|FL_ALIGN_BOTTOM)))
	  nh = nw-dwidth+dheight;
	else
	  nw = nh-dheight+dwidth;
      }
      int MINW = min_w+dwidth;
      if (nw &lt;= dwidth &amp;&amp; dwidth &gt; TITLE_WIDTH) {
	nw = dwidth-1;
#if MINIMIZE_HEIGHT
	restore_h = nh;
#endif
      } else {
	if (inc_w &gt; 1) nw = ((nw-MINW+inc_w/2)/inc_w)*inc_w+MINW;
	if (nw &lt; MINW) nw = MINW;
	else if (max_w &amp;&amp; nw &gt; max_w+dwidth) nw = max_w+dwidth;
      }
      int MINH = min_h+dheight;
      const int MINH_B = BUTTON_H+BUTTON_TOP+BUTTON_BOTTOM;
      if (MINH_B &gt; MINH) MINH = MINH_B;
      if (inc_h &gt; 1) nh = ((nh-MINH+inc_h/2)/inc_h)*inc_h+MINH;
      if (nh &lt; MINH) nh = MINH;
      else if (max_h &amp;&amp; nh &gt; max_h+dheight) nh = max_h+dheight;
      if (what &amp; FL_ALIGN_LEFT) nx = ix+iw-nw;
      if (what &amp; FL_ALIGN_TOP) ny = iy+ih-nh;
      set_size(nx,ny,nw,nh);
    }
    return 1;
  }
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.433">@ Handle events that fltk did not recognize (mostly ones directed
at the desktop):
@c

int Frame::handle(const XEvent* ei) {

  switch (ei-&gt;type) {

  case ConfigureRequest: {
    const XConfigureRequestEvent* e = &amp;(ei-&gt;xconfigurerequest);
    unsigned long mask = e-&gt;value_mask;
    if (mask &amp; CWBorderWidth) app_border_width = e-&gt;border_width;
    // Try to detect if the application is really trying to move the
    // window, or is simply echoing it's postion, possibly with some
    // variation (such as echoing the parent window position), and
    // dont' move it in that case:
    int X = (mask &amp; CWX &amp;&amp; e-&gt;x != x()) ? e-&gt;x+app_border_width-left : x();
    int Y = (mask &amp; CWY &amp;&amp; e-&gt;y != y()) ? e-&gt;y+app_border_width-top : y();
    int W = (mask &amp; CWWidth) ? e-&gt;width+dwidth : w();
    int H = (mask &amp; CWHeight) ? e-&gt;height+dheight : h();
    // Generally we want to obey any application positioning of the
    // window, except when it appears the app is trying to position
    // the window "at the edge".
    if (!(mask &amp; CWX) || (X &gt;= -2*left &amp;&amp; X &lt; 0)) X = force_x_onscreen(X,W);
    if (!(mask &amp; CWY) || (Y &gt;= -2*top &amp;&amp; Y &lt; 0)) Y = force_y_onscreen(Y,H);
    // Fix Rick Sayre's program that resizes it's windows bigger than the
    // maximum size:
    if (W &gt; max_w+dwidth) max_w = 0;
    if (H &gt; max_h+dheight) max_h = 0;
    set_size(X, Y, W, H, 2);
    if (e-&gt;value_mask &amp; CWStackMode &amp;&amp; e-&gt;detail == Above &amp;&amp; state()==NORMAL)
      raise();
    return 1;}

  case MapRequest: {
    //const XMapRequestEvent* e = &amp;(ei-&gt;xmaprequest);
    raise();
    return 1;}

  case UnmapNotify: {
    const XUnmapEvent* e = &amp;(ei-&gt;xunmap);
    if (e-&gt;from_configure);
    else if (state_flags_&amp;IGNORE_UNMAP) clear_state_flag(IGNORE_UNMAP);
    else state(UNMAPPED);
    return 1;}

  case DestroyNotify: {
    //const XDestroyWindowEvent* e = &amp;(ei-&gt;xdestroywindow);
    delete this;
    return 1;}

  case ReparentNotify: {
    const XReparentEvent* e = &amp;(ei-&gt;xreparent);
    if (e-&gt;parent==fl_xid(this)) return 1; // echo
    if (e-&gt;parent==fl_xid(Root)) return 1; // app is trying to tear-off again?
    delete this; // guess they are trying to paste tear-off thing back?
    return 1;}

  case ClientMessage: {
    const XClientMessageEvent* e = &amp;(ei-&gt;xclient);
    if (e-&gt;message_type == wm_change_state &amp;&amp; e-&gt;format == 32) {
      if (e-&gt;data.l[0] == NormalState) raise();
      else if (e-&gt;data.l[0] == IconicState) iconize();
    } else
      // we may want to ignore _WIN_LAYER from xmms?
      Fl::warning("flwm: unexpected XClientMessageEvent, type 0x%lx, "
	      "window 0x%lx\n", e-&gt;message_type, e-&gt;window);
    return 1;}

  case ColormapNotify: {
    const XColormapEvent* e = &amp;(ei-&gt;xcolormap);
    if (e-&gt;c_new) {  // this field is called "new" in the old C++-unaware Xlib
      colormap = e-&gt;colormap;
      if (active()) installColormap();
    }
    return 1;}

  case PropertyNotify: {
    const XPropertyEvent* e = &amp;(ei-&gt;xproperty);
    Atom a = e-&gt;atom;

    // case XA_WM_ICON_NAME: (do something similar to name)
    if (a == XA_WM_NAME) {
      getLabel(e-&gt;state == PropertyDelete);

    } else if (a == wm_state) {
      // it's not clear if I really need to look at this.  Need to make
      // sure it is not seeing the state echoed by the application by
      // checking for it being different...
      switch (getIntProperty(wm_state, wm_state, state())) {
      case IconicState:
	if (state() == NORMAL || state() == OTHER_DESKTOP) iconize(); break;
      case NormalState:
	if (state() != NORMAL &amp;&amp; state() != OTHER_DESKTOP) raise(); break;
      }

    } else if (a == wm_colormap_windows) {
      getColormaps();
      if (active()) installColormap();

    } else if (a == _motif_wm_hints) {
      // some #%&amp;%$# SGI Motif programs change this after mapping the window!
      // :-( :=( :-( :=( :-( :=( :-( :=( :-( :=( :-( :=(
      if (getMotifHints()) { // returns true if any flags changed
	fix_transient_for();
	updateBorder();
	show_hide_buttons();
      }

    } else if (a == wm_protocols) {
      getProtocols();
      // get Motif hints since they may do something with QUIT:
      getMotifHints();

    } else if (a == XA_WM_NORMAL_HINTS || a == XA_WM_SIZE_HINTS) {
      getSizes();
      show_hide_buttons();

    } else if (a == XA_WM_TRANSIENT_FOR) {
      XGetTransientForHint(fl_display, window_, &amp;transient_for_xid);
      fix_transient_for();
      show_hide_buttons();

    } else if (a == XA_WM_COMMAND) {
      clear_state_flag(SAVE_PROTOCOL_WAIT);

    }
    return 1;}

  }
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.434">@ X utility routines:
@c

void* Frame::getProperty(Atom a, Atom type, int* np) const {
  return ::getProperty(window_, a, type, np);
}
</t>
<t tx="davidmcnab.041604122248.435">
void* getProperty(Window w, Atom a, Atom type, int* np) {
  Atom realType;
  int format;
  unsigned long n, extra;
  int status;
  void* prop;
  status = XGetWindowProperty(fl_display, w,
			      a, 0L, 256L, False, type, &amp;realType,
			      &amp;format, &amp;n, &amp;extra, (uchar**)&amp;prop);
  if (status != Success) return 0;
  if (!prop) return 0;
  if (!n) {XFree(prop); return 0;}
  if (np) *np = (int)n;
  return prop;
}
</t>
<t tx="davidmcnab.041604122248.436">
int Frame::getIntProperty(Atom a, Atom type, int deflt) const {
  return ::getIntProperty(window_, a, type, deflt);
}
</t>
<t tx="davidmcnab.041604122248.437">
int getIntProperty(Window w, Atom a, Atom type, int deflt) {
  void* prop = getProperty(w, a, type);
  if (!prop) return deflt;
  int r = int(*(long*)prop);
  XFree(prop);
  return r;
}
</t>
<t tx="davidmcnab.041604122248.438">
void setProperty(Window w, Atom a, Atom type, int v) {
  long prop = v;
  XChangeProperty(fl_display, w, a, type, 32, PropModeReplace, (uchar*)&amp;prop,1);
}
</t>
<t tx="davidmcnab.041604122248.439">
void Frame::setProperty(Atom a, Atom type, int v) const {
  ::setProperty(window_, a, type, v);
}
</t>
<t tx="davidmcnab.041604122248.440">
void Frame::sendMessage(Atom a, Atom l) const {
  XEvent ev;
  long mask;
  memset(&amp;ev, 0, sizeof(ev));
  ev.xclient.type = ClientMessage;
  ev.xclient.window = window_;
  ev.xclient.message_type = a;
  ev.xclient.format = 32;
  ev.xclient.data.l[0] = long(l);
  ev.xclient.data.l[1] = long(fl_event_time);
  mask = 0L;
  XSendEvent(fl_display, window_, False, mask, &amp;ev);
}
</t>
<t tx="davidmcnab.041604122248.441">@language c
// FrameWindow.H


// X does not echo back the window-map events (it probably should when
// override_redirect is off).  Unfortunately this means you have to use
// this subclass if you want a "normal" fltk window, it will force a
// Frame to be created and destroy it upon hide.

// Warning: modal() does not work!  Don't turn it on as it screws up the
// interface with the window borders.  You can use set_non_modal() to
// disable the iconize box but the window manager must be written to
// not be modal.

#ifndef FrameWindow_H
#define FrameWindow_H

#include &lt;FL/Fl_Window.H&gt;
class Frame;

class FrameWindow : public Fl_Window {
  Frame* frame;
public:
  void hide();
  void show();
  int handle(int);
  FrameWindow(int X, int Y, int W, int H, const char* L = 0) :
    Fl_Window(X,Y,W,H,L) {}
  FrameWindow(int W, int H, const char* L = 0) :
    Fl_Window(W,H,L) {}
};

#endif
</t>
<t tx="davidmcnab.041604122248.442">@language c

// FrameWindow.C

// X does not echo back the window-map events (it probably should when
// override_redirect is off).  Unfortunately this means you have to use
// this subclass if you want a "normal" fltk window, it will force a
// Frame to be created and destroy it upon hide.

// Warning: modal() does not work!  Don't turn it on as it screws up the
// interface with the window borders.  You can use set_non_modal() to
// disable the iconize box but the window manager must be written to
// not be modal.

&lt;&lt; FrameWindow #includes &gt;&gt;
&lt;&lt; FrameWindow declarations &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.443">#include &lt;FL/Fl.H&gt;

#include "FrameWindow.h"
#include "Frame.h"

#include "pycallbacks.h"
</t>
<t tx="davidmcnab.041604122248.444">
extern int dont_set_event_mask;
</t>
<t tx="davidmcnab.041604122248.445">
void FrameWindow::show() {
  if (shown()) {Fl_Window::show(); return;}
  Fl_Window::show();
  dont_set_event_mask = 1;
  frame = new Frame(fl_xid(this));
  dont_set_event_mask = 0;
}
</t>
<t tx="davidmcnab.041604122248.446">
void FrameWindow::hide() {
  if (shown()) {
    Fl_Window::hide();
    delete frame;
  }
}
</t>
<t tx="davidmcnab.041604122248.447">
int FrameWindow::handle(int e) {
  if (Fl_Window::handle(e)) return 1;
  // make Esc close the window:
  if (e == FL_SHORTCUT &amp;&amp; Fl::event_key()==FL_Escape) {
    do_callback();
    return 1;
  }
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.448">@language c

// Menu.cxx

&lt;&lt; Menu #includes &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.449">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;FL/Fl_Box.H&gt;
#include &lt;FL/Fl_Return_Button.H&gt;
#include &lt;FL/Fl_Input.H&gt;
#include &lt;FL/Fl_Menu_Item.H&gt;
#include &lt;FL/fl_draw.H&gt;

#include "config.h"

#if DESKTOPS
#include "Desktop.h"
#endif
#include "FrameWindow.h"
#include "Frame.h"

#include "pycallbacks.h"

</t>
<t tx="davidmcnab.041604122248.450">// it is possible for the window to be deleted or withdrawn while
// the menu is up.  This will detect that case (with reasonable
// reliability):
static int
window_deleted(Frame* c)
{
  return c-&gt;state() != NORMAL
    &amp;&amp; c-&gt;state() != ICONIC
    &amp;&amp; c-&gt;state() != OTHER_DESKTOP;
}
</t>
<t tx="davidmcnab.041604122248.451">
static void
frame_callback(Fl_Widget*, void*d)
{
  Frame* c = (Frame*)d;
  if (window_deleted(c)) return;
  c-&gt;raise();
  c-&gt;activate(2);
}
</t>
<t tx="davidmcnab.041604122248.452">
#if DESKTOPS
// raise it but also put it on the current desktop:
static void
move_frame_callback(Fl_Widget*, void*d)
{
  Frame* c = (Frame*)d;
  if (window_deleted(c)) return;
  c-&gt;desktop(Desktop::current());
  c-&gt;raise();
  c-&gt;activate(2);
}
</t>
<t tx="davidmcnab.041604122248.453">#endif

#define SCREEN_DX 1	// offset to corner of contents area
#define SCREEN_W (MENU_ICON_W-2)	// size of area to draw contents in
#define SCREEN_H (MENU_ICON_H-2)	// size of area to draw contents in

#define	MAX_NESTING_DEPTH	32

extern Fl_Window* Root;

static void
frame_label_draw(const Fl_Label* o, int X, int Y, int W, int H, Fl_Align align)
{
  Frame* f = (Frame*)(o-&gt;value);
  if (window_deleted(f)) return;
  fl_draw_box(FL_THIN_DOWN_BOX, X, Y, MENU_ICON_W, MENU_ICON_H, FL_GRAY);
  for (Frame* c = Frame::first; c; c = c-&gt;next) {
    if (c-&gt;state() != UNMAPPED &amp;&amp; (c==f || c-&gt;is_transient_for(f))) {
      int x = ((c-&gt;x()-Root-&gt;x())*SCREEN_W+Root-&gt;w()/2)/Root-&gt;w();
      int w = (c-&gt;w()*SCREEN_W+Root-&gt;w()-1)/Root-&gt;w();
      if (w &gt; SCREEN_W) w = SCREEN_W;
      if (w &lt; 3) w = 3;
      if (x+w &gt; SCREEN_W) x = SCREEN_W-w;
      if (x &lt; 0) x = 0;
      int y = ((c-&gt;y()-Root-&gt;y())*SCREEN_H+Root-&gt;h()/2)/Root-&gt;h();
      int h = (c-&gt;h()*SCREEN_H+Root-&gt;h()-1)/Root-&gt;h();
      if (h &gt; SCREEN_H) h = SCREEN_H;
      if (h &lt; 3) h = 3;
      if (y+h &gt; SCREEN_H) y = SCREEN_H-h;
      if (y &lt; 0) y = 0;
      fl_color(FL_BLACK);
      if (c-&gt;state() == ICONIC)
	fl_rect(X+x+SCREEN_DX, Y+y+SCREEN_DX, w, h);
      else
	fl_rectf(X+x+SCREEN_DX, Y+y+SCREEN_DX, w, h);
    }
  }
  fl_font(o-&gt;font, o-&gt;size);
  fl_color((Fl_Color)o-&gt;color);
  const char* l = f-&gt;label(); if (!l) l = "unnamed";
  fl_draw(l, X+MENU_ICON_W+3, Y, W-MENU_ICON_W-3, H, align);
}
</t>
<t tx="davidmcnab.041604122248.454">
static void
frame_label_measure(const Fl_Label* o, int&amp; W, int&amp; H)
{
  Frame* f = (Frame*)(o-&gt;value);
  if (window_deleted(f)) {W = MENU_ICON_W+3; H = MENU_ICON_H; return;}
  const char* l = f-&gt;label(); if (!l) l = "unnamed";
  fl_font(o-&gt;font, o-&gt;size);
  fl_measure(l, W, H);
  W += MENU_ICON_W+3;
  if (W &gt; MAX_MENU_WIDTH) W = MAX_MENU_WIDTH;
  if (H &lt; MENU_ICON_H) H = MENU_ICON_H;
}
</t>
<t tx="davidmcnab.041604122248.455">@ This labeltype is used for non-frame items so the text can line
up with the icons:
@c

static void
label_draw(const Fl_Label* o, int X, int Y, int W, int H, Fl_Align align)
{
  fl_font(o-&gt;font, o-&gt;size);
  fl_color((Fl_Color)o-&gt;color);
  fl_draw(o-&gt;value, X+MENU_ICON_W+3, Y, W-MENU_ICON_W-3, H, align);
}
</t>
<t tx="davidmcnab.041604122248.456">
static void
label_measure(const Fl_Label* o, int&amp; W, int&amp; H)
{
  fl_font(o-&gt;font, o-&gt;size);
  fl_measure(o-&gt;value, W, H);
  W += MENU_ICON_W+3;
  if (W &gt; MAX_MENU_WIDTH) W = MAX_MENU_WIDTH;
  if (H &lt; MENU_ICON_H) H = MENU_ICON_H;
}
</t>
<t tx="davidmcnab.041604122248.457">
#define FRAME_LABEL FL_FREE_LABELTYPE
#define TEXT_LABEL Fl_Labeltype(FL_FREE_LABELTYPE+1)

////////////////////////////////////////////////////////////////

static void
cancel_cb(Fl_Widget* w, void*)
{
  w-&gt;window()-&gt;hide();
}
</t>
<t tx="davidmcnab.041604122248.458">
#if DESKTOPS

static void
desktop_cb(Fl_Widget*, void* v)
{
  Desktop::current((Desktop*)v);
}
</t>
<t tx="davidmcnab.041604122248.459">
static void
delete_desktop_cb(Fl_Widget*, void* v)
{
  delete (Desktop*)v;
}
</t>
<t tx="davidmcnab.041604122248.460">
#if ASK_FOR_NEW_DESKTOP_NAME

static Fl_Input* new_desktop_input;

static void
new_desktop_ok_cb(Fl_Widget* w, void*)
{
  w-&gt;window()-&gt;hide();
  Desktop::current(new Desktop(new_desktop_input-&gt;value(), Desktop::available_number()));
}
</t>
<t tx="davidmcnab.041604122248.461">
static void
new_desktop_cb(Fl_Widget*, void*)
{
  if (!new_desktop_input) {
    FrameWindow* w = new FrameWindow(190,90);
    new_desktop_input = new Fl_Input(10,30,170,25,"New desktop name:");
    new_desktop_input-&gt;align(FL_ALIGN_TOP_LEFT);
    new_desktop_input-&gt;labelfont(FL_BOLD);
    Fl_Return_Button* b = new Fl_Return_Button(100,60,80,20,"OK");
    b-&gt;callback(new_desktop_ok_cb);
    Fl_Button* b2 = new Fl_Button(10,60,80,20,"Cancel");
    b2-&gt;callback(cancel_cb);
    w-&gt;set_non_modal();
    w-&gt;end();
  }
  char buf[120];
  sprintf(buf, "Desktop %d", Desktop::available_number());
  new_desktop_input-&gt;value(buf);
  new_desktop_input-&gt;window()-&gt;hotspot(new_desktop_input);
  new_desktop_input-&gt;window()-&gt;show();
}
</t>
<t tx="davidmcnab.041604122248.462">
#else // !ASK_FOR_NEW_DESKTOP_NAME

static void
new_desktop_cb(Fl_Widget*, void*)
{
  char buf[120];
  int i = Desktop::available_number();
  sprintf(buf, "Desktop %d", i);
  Desktop::current(new Desktop(buf, i));
}
</t>
<t tx="davidmcnab.041604122248.463">
#endif

#endif
////////////////////////////////////////////////////////////////

static void
exit_cb(Fl_Widget*, void*)
{
  Frame::save_protocol();
  exit(0);
}
</t>
<t tx="davidmcnab.041604122248.464">
static void
logout_cb(Fl_Widget*, void*)
{
  static FrameWindow* w;
  if (!w) {
    w = new FrameWindow(190,90);
    Fl_Box* l = new Fl_Box(0, 0, 190, 60, "Really log out?");
    l-&gt;labelfont(FL_BOLD);
    Fl_Return_Button* b = new Fl_Return_Button(100,60,80,20,"OK");
    b-&gt;callback(exit_cb);
    Fl_Button* b2 = new Fl_Button(10,60,80,20,"Cancel");
    b2-&gt;callback(cancel_cb);
    w-&gt;set_non_modal();
    w-&gt;end();
  }
  w-&gt;hotspot(w);
  w-&gt;show();
}
</t>
<t tx="davidmcnab.041604122248.465">
////////////////////////////////////////////////////////////////

#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;errno.h&gt;

#if XTERM_MENU_ITEM || WMX_MENU_ITEMS

static const char* xtermname = "xterm";

static void
spawn_cb(Fl_Widget*, void*n)
{
  char* name = (char*)n;
  // strange code thieved from 9wm to avoid leaving zombies
  if (fork() == 0) {
    if (fork() == 0) {
      close(ConnectionNumber(fl_display));
      if (name == xtermname) execlp(name, name, "-ut", 0);
      else execl(name, name, 0);
      fprintf(stderr, "flwm: can't run %s, %s\n", name, strerror(errno));
      XBell(fl_display, 70);
      exit(1);
    }
    exit(0);
  }
  wait((int *) 0);
}
</t>
<t tx="davidmcnab.041604122248.466">
#endif

static Fl_Menu_Item other_menu_items[] = {
#if XTERM_MENU_ITEM
  {"New xterm", 0, spawn_cb, (void*)xtermname, 0, 0, 0, MENU_FONT_SIZE},
#endif
#if DESKTOPS
  {"New desktop", 0, new_desktop_cb, 0, 0, 0, 0, MENU_FONT_SIZE},
#endif
  {"Logout", 0, logout_cb, 0, 0, 0, 0, MENU_FONT_SIZE},
  {0}};
#define num_other_items (sizeof(other_menu_items)/sizeof(Fl_Menu_Item))

// use this to fill in a menu location:
static void
init(Fl_Menu_Item&amp; m, const char* data)
{
#ifdef HAVE_STYLES
  m.style = 0;
#endif
  m.label(data);
  m.flags = 0;
  m.labeltype(FL_NORMAL_LABEL);
  if (data)
    m.shortcut(tolower(data[0]));
  m.labelfont(MENU_FONT_SLOT);
  m.labelsize(MENU_FONT_SIZE);
  m.labelcolor(FL_BLACK);
}

</t>
<t tx="davidmcnab.041604122248.467">
#if WMX_MENU_ITEMS

// wmxlist is an array of char* pointers (for efficient sorting purposes), 
// which are stored in wmxbuffer (for memory efficiency and to avoid
// freeing and fragmentation)
static char** wmxlist = NULL;
static int wmxlistsize = 0;
// wmx commands are read from ~/.wmx,
// they are stored null-separated here:
static char* wmxbuffer = NULL;
static int wmxbufsize = 0;
static int num_wmx = 0;
static time_t wmx_time = 0;
static int wmx_pathlen = 0;

static int
scan_wmx_dir (char *path, int bufindex, int nest)
{
  DIR* dir = opendir(path);
  struct stat st;
  int pathlen = strlen (path);
  if (dir) {
    struct dirent* ent;
    while ((ent=readdir(dir))) {
    if (ent-&gt;d_name[0] == '.')
        continue;
      strcpy(path+pathlen, ent-&gt;d_name);
      if (stat(path, &amp;st) &lt; 0) continue;
      int len = pathlen+strlen(ent-&gt;d_name);
	// worst-case alloc needs
      if (bufindex+len+nest+1 &gt; wmxbufsize)
	wmxbuffer = (char*)realloc(wmxbuffer, (wmxbufsize+=1024));
      for (int i=0; i&lt;nest; i++)
	wmxbuffer[bufindex++] = '/'; // extra slash marks menu titles
      if (S_ISDIR(st.st_mode) &amp;&amp; (st.st_mode &amp; 0555) &amp;&amp; nest&lt;MAX_NESTING_DEPTH){
	strcpy(wmxbuffer+bufindex, path);
        bufindex += len+1;
        strcat(path, "/");
        bufindex = scan_wmx_dir (path, bufindex, nest+1);
	num_wmx++;
      } else if (S_ISREG(st.st_mode) &amp;&amp; (st.st_mode &amp; 0111)) {
	// make sure it exists and is an executable file:
	strcpy(wmxbuffer+bufindex, path);
	bufindex += len+1;
	num_wmx++;
      }
    }
    closedir(dir);
  }
  return bufindex;
}
</t>
<t tx="davidmcnab.041604122248.468">@ comparison for qsort
We keep submenus together by noting that they're proper superstrings
@c

static int
wmxCompare(const void *A, const void *B)
{
  char	*pA, *pB;
  pA = *(char **)A;
  pB = *(char **)B;

  pA += strspn(pA, "/");
  pB += strspn(pB, "/");

  // caseless compare
  while (*pA &amp;&amp; *pB) {
    if (toupper(*pA) &gt; toupper(*pB))
      return(1);
    if (toupper(*pA) &lt; toupper(*pB))
      return(-1);
    pA++;
    pB++;
  }
  if (*pA)
    return(1);
  if (*pB)
    return(-1);
  return(0);
}
</t>
<t tx="davidmcnab.041604122248.469">
static void
load_wmx()
{
  const char* home=getenv("HOME"); if (!home) home = ".";
  char path[1024];
  strcpy(path, home);
  if (path[strlen(path)-1] != '/') strcat(path, "/");
  strcat(path, ".wmx/");
  struct stat st; if (stat(path, &amp;st) &lt; 0) return;
  if (st.st_mtime == wmx_time) return;
  wmx_time = st.st_mtime;
  num_wmx = 0;
  wmx_pathlen = strlen(path);
  scan_wmx_dir(path, 0, 0);

  // Build wmxlist
  if (num_wmx &gt; wmxlistsize) {
    if (wmxlist)
      delete [] wmxlist;
    wmxlist = new char *[num_wmx];
    wmxlistsize = num_wmx;
  }
  for (int i=0; i&lt;num_wmx; i++) {
    char* cmd = wmxbuffer;

    for (int j = 0; j &lt; num_wmx; j++) {
      wmxlist[j] = cmd;
      cmd += strlen(cmd)+1;
    }
  }

  qsort(wmxlist, num_wmx, sizeof(char *), wmxCompare);
}
</t>
<t tx="davidmcnab.041604122248.470">
#endif

////////////////////////////////////////////////////////////////

int exit_flag; // set by the -x switch

static int is_active_frame(Frame* c) {
  for (Frame* a = Frame::activeFrame(); a; a = a-&gt;transient_for())
    if (a == c) return 1;
  return 0;
}
</t>
<t tx="davidmcnab.041604122248.471">void testhook(){}

</t>
<t tx="davidmcnab.041604122248.472">
void
ShowTabMenu(int tab)
{

  static char beenhere;
  if (!beenhere) {
    beenhere = 1;
    Fl::set_labeltype(FRAME_LABEL, frame_label_draw, frame_label_measure);
    Fl::set_labeltype(TEXT_LABEL, label_draw, label_measure);
    if (exit_flag) {
      Fl_Menu_Item* m = other_menu_items+num_other_items-2;
      m-&gt;label("Exit");
      m-&gt;callback(exit_cb);
    }
  }

  static Fl_Menu_Item* menu = 0;
  static int arraysize = 0;

#if DESKTOPS
  int one_desktop = !Desktop::first-&gt;next;
#endif

  // count up how many items are on the menu:

  int n = num_other_items;
#if WMX_MENU_ITEMS
  load_wmx();
  if (num_wmx) {
    n -= 1; // delete "new xterm"
    // add wmx items
    int	level = 0;
    for (int i=0; i&lt;num_wmx; i++) {
      int nextlev = (i==num_wmx-1)?0:strspn(wmxlist[i+1], "/")-1;
      if (nextlev &lt; level) {
	n += level-nextlev;
	level = nextlev;
      } else if (nextlev &gt; level)
	level++;
      n++;
    }
  }
#endif

#if DESKTOPS
  // count number of items per desktop in these variables:
  int numsticky = 0;
  Desktop* d;
  for (d = Desktop::first; d; d = d-&gt;next) d-&gt;junk = 0;
#endif

  // every frame contributes 1 item:
  Frame* c;
  for (c = Frame::first; c; c = c-&gt;next) {
    if (c-&gt;state() == UNMAPPED || c-&gt;transient_for()) continue;
#if DESKTOPS
    if (!c-&gt;desktop()) {
      numsticky++;
    } else {
      c-&gt;desktop()-&gt;junk++;
    }
#endif
    n++;
  }

#if DESKTOPS
  if (!one_desktop) {
    // add the sticky "desktop":
    n += 2; if (!numsticky) n++;
    if (Desktop::current()) {
      n += numsticky;
      Desktop::current()-&gt;junk += numsticky;
    }
    // every desktop contributes menu title, null terminator,
    // and possible delete:
    for (d = Desktop::first; d; d = d-&gt;next) {
      n += 2; if (!d-&gt;junk) n++;
    }
  }
#endif

  if (n &gt; arraysize) {
    delete[] menu;
    menu = new Fl_Menu_Item[arraysize = n];
  }

  // build the menu:
  n = 0;
  const Fl_Menu_Item* preset = 0;
  const Fl_Menu_Item* first_on_desk = 0;
#if DESKTOPS
  if (one_desktop) {
#endif
    for (c = Frame::first; c; c = c-&gt;next) {
      if (c-&gt;state() == UNMAPPED || c-&gt;transient_for()) continue;
      init(menu[n],(char*)c);
      menu[n].labeltype(FRAME_LABEL);
      menu[n].callback(frame_callback, c);
      if (is_active_frame(c)) preset = menu+n;
      n++;
    }
    if (n &gt; 0) first_on_desk = menu;
#if DESKTOPS
  } else for (d = Desktop::first; ; d = d-&gt;next) {
    // this loop adds the "sticky" desktop last, when d==0
    if (d == Desktop::current()) preset = menu+n;
    init(menu[n], d ? d-&gt;name() : "Sticky");
    menu[n].callback(desktop_cb, d);
    menu[n].flags = FL_SUBMENU;
    n++;
    if (d &amp;&amp; !d-&gt;junk) {
      init(menu[n],"delete this desktop");
      menu[n].callback(delete_desktop_cb, d);
      n++;
    } else if (!d &amp;&amp; !numsticky) {
      init(menu[n],"(empty)");
      menu[n].callback_ = 0;
      menu[n].deactivate();
      n++;
    } else {
      if (d == Desktop::current()) first_on_desk = menu+n;
      for (c = Frame::first; c; c = c-&gt;next) {
	if (c-&gt;state() == UNMAPPED || c-&gt;transient_for()) continue;
	if (c-&gt;desktop() == d || !c-&gt;desktop() &amp;&amp; d == Desktop::current()) {
	  init(menu[n],(char*)c);
	  menu[n].labeltype(FRAME_LABEL);
	  menu[n].callback(d == Desktop::current() ?
			   frame_callback : move_frame_callback, c);
	  if (d == Desktop::current() &amp;&amp; is_active_frame(c)) preset = menu+n;
	  n++;
	}
      }
    }
    menu[n].label(0); n++; // terminator for submenu
    if (!d) break;
  }
#endif

  // For ALT+Tab, move the selection forward or backward:
  if (tab &gt; 0 &amp;&amp; first_on_desk) {
    if (!preset)
      preset = first_on_desk;
    else {
      preset++;
      if (!preset-&gt;label() || preset-&gt;callback_ != frame_callback)
	preset = first_on_desk;
    }
  } else if (tab &lt; 0 &amp;&amp; first_on_desk) {
    if (preset &amp;&amp; preset != first_on_desk)
      preset--;
    else {
      // go to end of menu
      preset = first_on_desk;
      while (preset[1].label() &amp;&amp; preset[1].callback_ == frame_callback)
	preset++;
    }
  }
// SUSS

  printf("tab=%d preset=0x%x\n", tab, (void *)preset);
  if (tab != 0 &amp;&amp; preset)
  {
       preset-&gt;do_callback(0);
       return;
  }

#if WMX_MENU_ITEMS
  // put wmx-style commands above that:
  if (num_wmx &gt; 0) {
    char* cmd;
    int pathlen[MAX_NESTING_DEPTH];
    int level = 0;
    pathlen[0] = wmx_pathlen;
    for (int i = 0; i &lt; num_wmx; i++) {
      cmd = wmxlist[i];
      cmd += strspn(cmd, "/")-1;
      init(menu[n], cmd+pathlen[level]);
#if DESKTOPS
      if (one_desktop)
#endif
	if (!level)
	  menu[n].labeltype(TEXT_LABEL);

      //menu[n].selection_color(FL_SELECTION_COLOR);

      int	nextlev = (i==num_wmx-1)?0:strspn(wmxlist[i+1], "/")-1;
      if (nextlev &lt; level) {
	menu[n].callback(spawn_cb, cmd);
	// Close 'em off
	for (; level&gt;nextlev; level--)
	  init(menu[++n], 0);
      } else if (nextlev &gt; level) {
	// This should be made a submenu
	pathlen[++level] = strlen(cmd)+1; // extra for next trailing /
	menu[n].flags = FL_SUBMENU;
	menu[n].callback((Fl_Callback*)0);
      } else {
	menu[n].callback(spawn_cb, cmd);
      }
      n++;
    }
  }

  // put the fixed menu items at the bottom:
#if XTERM_MENU_ITEM
  if (num_wmx) // if wmx commands, delete the built-in xterm item:
    memcpy(menu+n, other_menu_items+1, sizeof(other_menu_items)-sizeof(Fl_Menu_Item));
  else
#endif
#endif
    memcpy(menu+n, other_menu_items, sizeof(other_menu_items));
#if DESKTOPS
  if (one_desktop)
#endif
    // fix the menus items so they are indented to align with window names:
    while (menu[n].label()) menu[n++].labeltype(TEXT_LABEL);

  const Fl_Menu_Item* picked =
    menu-&gt;popup(Fl::event_x(), Fl::event_y(), 0, preset);
  if (picked &amp;&amp; picked-&gt;callback()) picked-&gt;do_callback(0);
}
</t>
<t tx="davidmcnab.041604122248.473">
void ShowMenu() {ShowTabMenu(0);}
</t>
<t tx="davidmcnab.041604122248.474">@language c
// Hotkeys.C

// If you want to change what the hotkeys are, see the table at the bottom!

&lt;&lt; Hotkeys #includes &gt;&gt;
&lt;&lt; Hotkeys declarations &gt;&gt;
@others
</t>
<t tx="davidmcnab.041604122248.475">#include &lt;stdio.h&gt;

#include "config.h"
#include "Frame.h"
#include "Desktop.h"

#include "pycallbacks.h"

</t>
<t tx="davidmcnab.041604122248.476">
extern void ShowMenu();
extern void ShowTabMenu(int tab);
</t>
<t tx="davidmcnab.041604122248.477">
#if STANDARD_HOTKEYS

void NextWindow() { // Alt+Tab
  ShowTabMenu(1);
}
</t>
<t tx="davidmcnab.041604122248.478">
void PreviousWindow() { // Alt+Shift+Tab
  ShowTabMenu(-1);
}
</t>
<t tx="davidmcnab.041604122248.479">
#endif

#if DESKTOPS

void NextDesk() {
  if (Desktop::current()) {
    Desktop::current(Desktop::current()-&gt;next?
		     Desktop::current()-&gt;next:Desktop::first);
  } else {
    Desktop::current(Desktop::first);
  }
}
</t>
<t tx="davidmcnab.041604122248.480">
void PreviousDesk() {
  Desktop* search=Desktop::first;
  while (search-&gt;next &amp;&amp; search-&gt;next!=Desktop::current()){
    search=search-&gt;next;
  }
  Desktop::current(search);
}
</t>
<t tx="davidmcnab.041604122248.481">@ warning: this assummes it is bound to Fn key:
@c

static void DeskNumber() {
  Desktop::current(Desktop::number(Fl::event_key()-FL_F, 1));
}
</t>
<t tx="davidmcnab.041604122248.482">#endif

#if WMX_HOTKEYS || CDE_HOTKEYS

static void Raise() { // Alt+Up
  Frame* f = Frame::activeFrame();
  if (f) f-&gt;raise();
}
</t>
<t tx="davidmcnab.041604122248.483">
static void Lower() { // Alt+Down
  Frame* f = Frame::activeFrame();
  if (f) f-&gt;lower();
}
</t>
<t tx="davidmcnab.041604122248.484">
static void Iconize() { // Alt+Enter
  Frame* f = Frame::activeFrame();
  if (f) f-&gt;iconize();
  else ShowMenu(); // so they can deiconize stuff
}
</t>
<t tx="davidmcnab.041604122248.485">
static void Close() { // Alt+Delete
  Frame* f = Frame::activeFrame();
  if (f) f-&gt;close();
}
</t>
<t tx="davidmcnab.041604122248.486">////////////////////////////////////////////////////////////////

static struct {int key; void (*func)();} keybindings[] = {

#if STANDARD_HOTKEYS || MINIMUM_HOTKEYS
  // these are very common and tend not to conflict, due to Windoze:
  {FL_ALT+FL_Escape,	ShowMenu},
  {FL_ALT+FL_Menu,	ShowMenu},
#endif

#if STANDARD_HOTKEYS
  {FL_ALT+FL_Tab+FL_SHIFT,	NextWindow},
  {FL_ALT+FL_Tab,PreviousWindow},
  {FL_ALT+FL_SHIFT+0xfe20,PreviousWindow}, // XK_ISO_Left_Tab
#endif

#if KWM_HOTKEYS &amp;&amp; DESKTOPS // KWM uses these to switch desktops
//   {FL_CTRL+FL_Tab,	NextDesk},
//   {FL_CTRL+FL_SHIFT+FL_Tab,PreviousDesk},
//   {FL_CTRL+FL_SHIFT+0xfe20,PreviousDesk}, // XK_ISO_Left_Tab
  {FL_CTRL+FL_F+1,	DeskNumber},
  {FL_CTRL+FL_F+2,	DeskNumber},
  {FL_CTRL+FL_F+3,	DeskNumber},
  {FL_CTRL+FL_F+4,	DeskNumber},
  {FL_CTRL+FL_F+5,	DeskNumber},
  {FL_CTRL+FL_F+6,	DeskNumber},
  {FL_CTRL+FL_F+7,	DeskNumber},
  {FL_CTRL+FL_F+8,	DeskNumber},
  {FL_CTRL+FL_F+9,	DeskNumber},
  {FL_CTRL+FL_F+10,	DeskNumber},
  {FL_CTRL+FL_F+11,	DeskNumber},
  {FL_CTRL+FL_F+12,	DeskNumber},
#endif

#if WMX_HOTKEYS
  // wmx also sets all these, they seem pretty useful:
  {FL_ALT+FL_SHIFT+FL_Up,	Raise},
  {FL_ALT+FL_SHIFT+FL_Down,	Lower},
  {FL_ALT+FL_SHIFT+FL_Enter,	Iconize},
  {FL_ALT+FL_SHIFT+FL_Delete,	Close},
  //{FL_ALT+FL_Page_Up,	ToggleMaxH},
  //{FL_ALT+FL_Page_Down,ToggleMaxW},
#endif

#if WMX_DESK_HOTKEYS &amp;&amp; DESKTOPS
  // these wmx keys are not set by default as they break NetScape:
  {FL_ALT+FL_Left,	PreviousDesk},
  {FL_ALT+FL_Right,	NextDesk},
#endif

#if CDE_HOTKEYS
  // CDE hotkeys (or at least what SGI's 4DWM uses):
  {FL_ALT+FL_F+1,	Raise},
//{FL_ALT+FL_F+2,	unknown}, // KWM uses this to run a typed-in command
  {FL_ALT+FL_F+3,	Lower},
  {FL_ALT+FL_F+4,	Close}, // this matches KWM
//{FL_ALT+FL_F+5,	Restore}, // useless because no icons visible
//{FL_ALT+FL_F+6,	unknown}, // ?
//{FL_ALT+FL_F+7,	Move}, // grabs the window for movement
//{FL_ALT+FL_F+8,	Resize}, // grabs the window for resizing
  {FL_ALT+FL_F+9,	Iconize},
//{FL_ALT+FL_F+10,	Maximize},
//{FL_ALT+FL_F+11,	unknown}, // ?
  {FL_ALT+FL_F+12,	Close}, // actually does "quit"
#else
#if DESKTOPS &amp;&amp; DESKTOP_HOTKEYS
  // seem to be common to Linux window managers
  {FL_ALT+FL_F+1,	DeskNumber},
  {FL_ALT+FL_F+2,	DeskNumber},
  {FL_ALT+FL_F+3,	DeskNumber},
  {FL_ALT+FL_F+4,	DeskNumber},
  {FL_ALT+FL_F+5,	DeskNumber},
  {FL_ALT+FL_F+6,	DeskNumber},
  {FL_ALT+FL_F+7,	DeskNumber},
  {FL_ALT+FL_F+8,	DeskNumber},
  {FL_ALT+FL_F+9,	DeskNumber},
  {FL_ALT+FL_F+10,	DeskNumber},
  {FL_ALT+FL_F+11,	DeskNumber},
  {FL_ALT+FL_F+12,	DeskNumber},
#endif
#endif
  {0}};

</t>
<t tx="davidmcnab.041604122248.487">
extern Fl_Window* Root;

void Grab_Hotkeys() {
  Window root = fl_xid(Root);
  for (int i = 0; keybindings[i].key; i++)
  {
    int k = keybindings[i].key;
    int keycode = XKeysymToKeycode(fl_display, k &amp; 0xFFFF);
    if (!keycode)
        continue;
    // Silly X!  we need to ignore caps lock &amp; numlock keys by grabbing
    // all the combinations:
    XGrabKey(fl_display, keycode, k&gt;&gt;16,     root, 0, 1, 1);
    XGrabKey(fl_display, keycode, (k&gt;&gt;16)|2, root, 0, 1, 1); // CapsLock
    XGrabKey(fl_display, keycode, (k&gt;&gt;16)|16, root, 0, 1, 1); // NumLock
    XGrabKey(fl_display, keycode, (k&gt;&gt;16)|18, root, 0, 1, 1); // both
  }
}
</t>
<t tx="davidmcnab.041604122248.488">@language c
// Rotated text drawing with X.


// Original code:
// Copyright (c) 1992 Alan Richardson (mppa3@uk.ac.sussex.syma) */
//
// Modifications for fltk:
// Copyright (c) 1997 Bill Spitzak (spitzak@d2.com)

#ifndef Rotated_H
#define Rotated_H

void draw_rotated(const char* text, int n, int x, int y, int angle);
void draw_rotated(const char* text, int x, int y, int angle);
void draw_rotated90(const char*, int x, int y, int w, int h, Fl_Align);
void draw_rotated270(const char*, int x, int y, int w, int h, Fl_Align);
void draw_rotated180(const char*, int x, int y, int w, int h, Fl_Align);

#endif 
</t>
<t tx="davidmcnab.041604122248.489">@language c

// Rotated text drawing with X.

// Original code:
// Copyright (c) 1992 Alan Richardson (mppa3@uk.ac.sussex.syma) */
//
// Modifications for fltk:
// Copyright (c) 1997 Bill Spitzak (spitzak@d2.com)
// Modifications are to draw using the current fl_font.  All fonts
// used are cached in local structures.  This can get real expensive,
// use "

/* xvertext, Copyright (c) 1992 Alan Richardson (mppa3@uk.ac.sussex.syma)
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both the
 * copyright notice and this permission notice appear in supporting
 * documentation.  All work developed as a consequence of the use of
 * this program should duly acknowledge such use. No representations are
 * made about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 */

// if not defined then portions not used by flwm are included:
#define FLWM 1

/* ********************************************************************** */

&lt;&lt; Rotated #includes &gt;&gt;
&lt;&lt; Rotated declarations &gt;&gt;
@others
#endif

</t>
<t tx="davidmcnab.041604122248.490">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#include &lt;FL/x.H&gt;
#include &lt;FL/fl_draw.H&gt;
#include "Rotated.h"

#include "pycallbacks.h"


</t>
<t tx="davidmcnab.041604122248.491">
struct BitmapStruct {
  int			 bit_w;
  int			 bit_h;
  Pixmap bm;
};

struct XRotCharStruct {
  int			 ascent;
  int			 descent;
  int			 lbearing;
  int			 rbearing;
  int			 width;
  BitmapStruct	 glyph;
};

struct XRotFontStruct {
  int			 dir;
  int			 height;
  int			 max_ascent;
  int			 max_descent;
  int			 max_char;
  int			 min_char;
  XFontStruct*		 xfontstruct;
  XRotCharStruct	 per_char[256];
};
</t>
<t tx="davidmcnab.041604122248.492">@ *** Load the rotated version of a given font ***
@c

static XRotFontStruct*
XRotLoadFont(Display *dpy, XFontStruct* fontstruct, int dir)
{
  char val;
  XImage *I1, *I2;
  Pixmap canvas;
  Window root;
  int screen;
  GC font_gc;
  char text[3];/*, errstr[300];*/
  
  XRotFontStruct *rotfont;
  int ichar, i, j, index, boxlen = 60;
  int vert_w, vert_h, vert_len, bit_w, bit_h, bit_len;
  int min_char, max_char;
  unsigned char *vertdata, *bitdata;
  int ascent, descent, lbearing, rbearing;
  int on = 1, off = 0;

  /* useful macros ... */
  screen = DefaultScreen(dpy);
  root = DefaultRootWindow(dpy);

  /* create the depth 1 canvas bitmap ... */
  canvas = XCreatePixmap(dpy, root, boxlen, boxlen, 1);
 
  /* create a GC ... */
  font_gc = XCreateGC(dpy, canvas, 0, 0);
  XSetBackground(dpy, font_gc, off);

  XSetFont(dpy, font_gc, fontstruct-&gt;fid);

  /* allocate space for rotated font ... */
  rotfont = (XRotFontStruct *)malloc((unsigned)sizeof(XRotFontStruct));
   
  /* determine which characters are defined in font ... */
  min_char = fontstruct-&gt;min_char_or_byte2; 
  if (min_char&lt;0)  min_char = 0;
  rotfont-&gt;min_char = min_char;
  max_char = fontstruct-&gt;max_char_or_byte2;
  if (max_char&gt;255) max_char = 255;
  rotfont-&gt;max_char = max_char;
     
  /* some overall font data ... */
  rotfont-&gt;dir = dir;
  rotfont-&gt;max_ascent = fontstruct-&gt;max_bounds.ascent;
  rotfont-&gt;max_descent = fontstruct-&gt;max_bounds.descent;   
  rotfont-&gt;height = rotfont-&gt;max_ascent+rotfont-&gt;max_descent;

  rotfont-&gt;xfontstruct = fontstruct;
  /* remember xfontstruct for `normal' text ... */
  if (dir != 0) {
    /* font needs rotation ... */
    /* loop through each character ... */
    for (ichar = min_char; ichar &lt;= max_char; ichar++) {

      index = ichar-fontstruct-&gt;min_char_or_byte2;
 
      /* per char dimensions ... */
      ascent =   rotfont-&gt;per_char[ichar].ascent = 
	fontstruct-&gt;per_char[index].ascent;
      descent =  rotfont-&gt;per_char[ichar].descent = 
	fontstruct-&gt;per_char[index].descent;
      lbearing = rotfont-&gt;per_char[ichar].lbearing = 
	fontstruct-&gt;per_char[index].lbearing;
      rbearing = rotfont-&gt;per_char[ichar].rbearing = 
	fontstruct-&gt;per_char[index].rbearing;
      rotfont-&gt;per_char[ichar].width = 
	fontstruct-&gt;per_char[index].width;

      /* some space chars have zero body, but a bitmap can't have ... */
      if (!ascent &amp;&amp; !descent)   
	ascent =   rotfont-&gt;per_char[ichar].ascent =   1;
      if (!lbearing &amp;&amp; !rbearing) 
	rbearing = rotfont-&gt;per_char[ichar].rbearing = 1;

      /* glyph width and height when vertical ... */
      vert_w = rbearing-lbearing;
      vert_h = ascent+descent;

      /* width in bytes ... */
      vert_len = (vert_w-1)/8+1;   
 
      XSetForeground(dpy, font_gc, off);
      XFillRectangle(dpy, canvas, font_gc, 0, 0, boxlen, boxlen);

      /* draw the character centre top right on canvas ... */
      sprintf(text, "%c", ichar);
      XSetForeground(dpy, font_gc, on);
      XDrawImageString(dpy, canvas, font_gc, boxlen/2 - lbearing,
		       boxlen/2 - descent, text, 1);

      /* reserve memory for first XImage ... */
      vertdata = (unsigned char *) malloc((unsigned)(vert_len*vert_h));
  
      /* create the XImage ... */
      I1 = XCreateImage(dpy, DefaultVisual(dpy, screen), 1, XYBitmap,
			0, (char *)vertdata, vert_w, vert_h, 8, 0);

//      if (I1 == NULL) ... do something here
  
      I1-&gt;byte_order = I1-&gt;bitmap_bit_order = MSBFirst;
   
      /* extract character from canvas ... */
      XGetSubImage(dpy, canvas, boxlen/2, boxlen/2-vert_h,
		   vert_w, vert_h, 1, XYPixmap, I1, 0, 0);
      I1-&gt;format = XYBitmap; 
 
      /* width, height of rotated character ... */
      if (dir == 2) { 
	bit_w = vert_w;
	bit_h = vert_h; 
      } else {
	bit_w = vert_h;
	bit_h = vert_w; 
      }

      /* width in bytes ... */
      bit_len = (bit_w-1)/8 + 1;

      rotfont-&gt;per_char[ichar].glyph.bit_w = bit_w;
      rotfont-&gt;per_char[ichar].glyph.bit_h = bit_h;

      /* reserve memory for the rotated image ... */
      bitdata = (unsigned char *)calloc((unsigned)(bit_h*bit_len), 1);

      /* create the image ... */
      I2 = XCreateImage(dpy, DefaultVisual(dpy, screen), 1, XYBitmap, 0,
			(char *)bitdata, bit_w, bit_h, 8, 0); 
 
//    if (I2 == NULL) ... error

      I2-&gt;byte_order = I2-&gt;bitmap_bit_order = MSBFirst;
 
      /* map vertical data to rotated character ... */
      for (j = 0; j &lt; bit_h; j++) {
	for (i = 0; i &lt; bit_w; i++) {
	  /* map bits ... */
	  if (dir == 1)
	    val = vertdata[i*vert_len + (vert_w-j-1)/8] &amp;
	      (128&gt;&gt;((vert_w-j-1)%8));
   
	  else if (dir == 2)
	    val = vertdata[(vert_h-j-1)*vert_len + (vert_w-i-1)/8] &amp;
	      (128&gt;&gt;((vert_w-i-1)%8));
                    
	  else 
	    val = vertdata[(vert_h-i-1)*vert_len + j/8] &amp; 
	      (128&gt;&gt;(j%8));
        
	  if (val) 
	    bitdata[j*bit_len + i/8] = bitdata[j*bit_len + i/8] |
	      (128&gt;&gt;(i%8));
	}
      }
   
      /* create this character's bitmap ... */
      rotfont-&gt;per_char[ichar].glyph.bm = 
	XCreatePixmap(dpy, root, bit_w, bit_h, 1);
     
      /* put the image into the bitmap ... */
      XPutImage(dpy, rotfont-&gt;per_char[ichar].glyph.bm, 
		font_gc, I2, 0, 0, 0, 0, bit_w, bit_h);
  
      /* free the image and data ... */
      XDestroyImage(I1);
      XDestroyImage(I2);
      /*      free((char *)bitdata);  -- XDestroyImage does this
	      free((char *)vertdata);*/
    }

  }
  
  for (ichar = 0; ichar &lt; min_char; ichar++)
    rotfont-&gt;per_char[ichar] = rotfont-&gt;per_char['?'];
  for (ichar = max_char+1; ichar &lt; 256; ichar++)
    rotfont-&gt;per_char[ichar] = rotfont-&gt;per_char['?'];

  /* free pixmap and GC ... */
  XFreePixmap(dpy, canvas);
  XFreeGC(dpy, font_gc);

  return rotfont;
}
</t>
<t tx="davidmcnab.041604122248.493">@ *** Free the resources associated with a rotated font ***
@c

static void XRotUnloadFont(Display *dpy, XRotFontStruct *rotfont)
{
  int ichar;

  if (rotfont-&gt;dir != 0) {
    /* loop through each character, freeing its pixmap ... */
    for (ichar = rotfont-&gt;min_char; ichar &lt;= rotfont-&gt;max_char; ichar++)
      XFreePixmap(dpy, rotfont-&gt;per_char[ichar].glyph.bm);
  }
  /* rotfont should never be referenced again ... */
  free((char *)rotfont);
}
</t>
<t tx="davidmcnab.041604122248.494">@ ----------------------------------------------------------------------
*** A front end to XRotPaintString : mimics XDrawString ***
@c

static void
XRotDrawString(Display *dpy, XRotFontStruct *rotfont, Drawable drawable,
	       GC gc, int x, int y, const char *str, int len)
{            
  int i, xp, yp, dir, ichar;

  if (str == NULL || len&lt;1) return;

  dir = rotfont-&gt;dir;

  /* a horizontal string is easy ... */
  if (dir == 0) {
    XSetFont(dpy, gc, rotfont-&gt;xfontstruct-&gt;fid);
    XDrawString(dpy, drawable, gc, x, y, str, len);
    return;
  }

  /* vertical or upside down ... */

  XSetFillStyle(dpy, gc, FillStippled);

  /* loop through each character in string ... */
  for (i = 0; i&lt;len; i++) {
    ichar = ((unsigned char*)str)[i];

    /* suitable offset ... */
    if (dir == 1) {
      xp = x-rotfont-&gt;per_char[ichar].ascent;
      yp = y-rotfont-&gt;per_char[ichar].rbearing; 
    }
    else if (dir == 2) {
      xp = x-rotfont-&gt;per_char[ichar].rbearing;
      yp = y-rotfont-&gt;per_char[ichar].descent+1; 
    }
    else {
      xp = x-rotfont-&gt;per_char[ichar].descent+1;  
      yp = y+rotfont-&gt;per_char[ichar].lbearing; 
    }
                   
    /* draw the glyph ... */
    XSetStipple(dpy, gc, rotfont-&gt;per_char[ichar].glyph.bm);

    XSetTSOrigin(dpy, gc, xp, yp);

    XFillRectangle(dpy, drawable, gc, xp, yp,
		   rotfont-&gt;per_char[ichar].glyph.bit_w,
		   rotfont-&gt;per_char[ichar].glyph.bit_h);

    /* advance position ... */
    if (dir == 1)
      y -= rotfont-&gt;per_char[ichar].width;
    else if (dir == 2)
      x -= rotfont-&gt;per_char[ichar].width;
    else 
      y += rotfont-&gt;per_char[ichar].width;
  }
  XSetFillStyle(dpy, gc, FillSolid);
}
</t>
<t tx="davidmcnab.041604122248.495">
#ifndef FLWM
/* *** Return the width of a string *** */

static int XRotTextWidth(XRotFontStruct *rotfont, const char *str, int len)
{
  int i, width = 0, ichar;

  if (str == NULL) return 0;

  if (rotfont-&gt;dir == 0)
    width = XTextWidth(rotfont-&gt;xfontstruct, str, strlen(str));

  else
    for (i = 0; i&lt;len; i++) {
      width += rotfont-&gt;per_char[((unsigned char*)str)[i]].width;
    }

  return width;
}
</t>
<t tx="davidmcnab.041604122248.496">#endif

/* ---------------------------------------------------------------------- */

// the public functions use the fltk global variables for font &amp; gc:

static XRotFontStruct* font;

void draw_rotated(const char* text, int n, int x, int y, int angle) {
  if (!text || !*text) return;
  /* make angle positive ... */
  if (angle &lt; 0) do angle += 360; while (angle &lt; 0);
  /* get nearest vertical or horizontal direction ... */
  int dir = ((angle+45)/90)%4;

  if (font &amp;&amp; font-&gt;xfontstruct == fl_xfont &amp;&amp; font-&gt;dir == dir) {
    ;
  } else {
    if (font) XRotUnloadFont(fl_display, font);
    font = XRotLoadFont(fl_display, fl_xfont, dir);
  }
  XRotDrawString(fl_display, font, fl_window, fl_gc, x, y, text, n);
}
</t>
<t tx="davidmcnab.041604122248.497">
#ifndef FLWM
void draw_rotated(const char* text, int x, int y, int angle) {
  if (!text || !*text) return;
  draw_rotated(text, strlen(text), x, y, angle);
}
</t>
<t tx="davidmcnab.041604122248.498">#endif

static void draw_rot90(const char* str, int n, int x, int y) {
  draw_rotated(str, n, y, -x, 90);
}
</t>
<t tx="davidmcnab.041604122248.499">void draw_rotated90(
  const char* str, 	// the (multi-line) string
  int x, int y, int w, int h, 	// bounding box
  Fl_Align align) {
  if (!str || !*str) return;
  if (w &amp;&amp; h &amp;&amp; !fl_not_clipped(x, y, w, h)) return;
  if (align &amp; FL_ALIGN_CLIP) fl_clip(x, y, w, h);
  int a1 = align&amp;(-16);
  if (align &amp; FL_ALIGN_LEFT) a1 |= FL_ALIGN_TOP;
  if (align &amp; FL_ALIGN_RIGHT) a1 |= FL_ALIGN_BOTTOM;
  if (align &amp; FL_ALIGN_TOP) a1 |= FL_ALIGN_RIGHT;
  if (align &amp; FL_ALIGN_BOTTOM) a1 |= FL_ALIGN_LEFT;
  fl_draw(str, -(y+h), x, h, w, (Fl_Align)a1, draw_rot90);
  if (align &amp; FL_ALIGN_CLIP) fl_pop_clip();
}
</t>
<t tx="davidmcnab.041604122248.500">
#ifndef FLWM
static void draw_rot180(const char* str, int n, int x, int y) {
  draw_rotated(str, n, -x, -y, 180);
}
</t>
<t tx="davidmcnab.041604122248.501">void draw_rotated180(
  const char* str, 	// the (multi-line) string
  int x, int y, int w, int h, 	// bounding box
  Fl_Align align) {
  int a1 = align&amp;(-16);
  if (align &amp; FL_ALIGN_LEFT) a1 |= FL_ALIGN_RIGHT;
  if (align &amp; FL_ALIGN_RIGHT) a1 |= FL_ALIGN_LEFT;
  if (align &amp; FL_ALIGN_TOP) a1 |= FL_ALIGN_BOTTOM;
  if (align &amp; FL_ALIGN_BOTTOM) a1 |= FL_ALIGN_TOP;
  fl_draw(str, -(x+w), -(y+h), w, h, (Fl_Align)a1, draw_rot180);
}
</t>
<t tx="davidmcnab.041604122248.502">
static void draw_rot270(const char* str, int n, int x, int y) {
  draw_rotated(str, n, -y, x, 270);
}
</t>
<t tx="davidmcnab.041604122248.503">void draw_rotated270(
  const char* str, 	// the (multi-line) string
  int x, int y, int w, int h, 	// bounding box
  Fl_Align align) {
  int a1 = align&amp;(-16);
  if (align &amp; FL_ALIGN_LEFT) a1 |= FL_ALIGN_BOTTOM;
  if (align &amp; FL_ALIGN_RIGHT) a1 |= FL_ALIGN_TOP;
  if (align &amp; FL_ALIGN_TOP) a1 |= FL_ALIGN_LEFT;
  if (align &amp; FL_ALIGN_BOTTOM) a1 |= FL_ALIGN_RIGHT;
  fl_draw(str, y, -(x+w), h, w, (Fl_Align)a1, draw_rot270);
}
</t>
<t tx="davidmcnab.041604132426">def _on_keyEvent(self, key):
    print "myWM.on_keyEvent callback: key=%d" % key

</t>
</tnodes>
</leo_file>
